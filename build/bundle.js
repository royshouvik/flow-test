/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(3);\nvar isBuffer = __webpack_require__(18);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzPzcwNjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar normalizeHeaderName = __webpack_require__(20);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(21);\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(26);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzPzI4MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(5);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/MTZkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcz8yNGZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(2);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzP2RiNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzP2I3Y2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/MGQwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCI/OGU0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiPzEwZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("var url = __webpack_require__(10);\nvar http = __webpack_require__(7);\nvar https = __webpack_require__(8);\nvar assert = __webpack_require__(27);\nvar Writable = __webpack_require__(28).Writable;\nvar debug = __webpack_require__(29)(\"follow-redirects\");\n\n// RFC7231ยง4.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  var currentRequest = this._currentRequest;\n  if (!data) {\n    currentRequest.end(null, null, callback);\n  }\n  else {\n    this.write(data, encoding, function () {\n      currentRequest.end(null, null, callback);\n    });\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var requestBodyBuffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (requestBodyBuffers.length !== 0) {\n        var buffer = requestBodyBuffers.pop();\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC7231ยง6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC7231ยง6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC7231ยง6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe [โฆ],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC7231ยง6.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcz82MGQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUMsRUFBRTtBQUMvRCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG52YXIgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuV3JpdGFibGU7XG52YXIgZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIikoXCJmb2xsb3ctcmVkaXJlY3RzXCIpO1xuXG4vLyBSRkM3MjMxwqc0LjIuMTogT2YgdGhlIHJlcXVlc3QgbWV0aG9kcyBkZWZpbmVkIGJ5IHRoaXMgc3BlY2lmaWNhdGlvbixcbi8vIHRoZSBHRVQsIEhFQUQsIE9QVElPTlMsIGFuZCBUUkFDRSBtZXRob2RzIGFyZSBkZWZpbmVkIHRvIGJlIHNhZmUuXG52YXIgU0FGRV9NRVRIT0RTID0geyBHRVQ6IHRydWUsIEhFQUQ6IHRydWUsIE9QVElPTlM6IHRydWUsIFRSQUNFOiB0cnVlIH07XG5cbi8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzXG52YXIgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5bXCJhYm9ydFwiLCBcImFib3J0ZWRcIiwgXCJlcnJvclwiLCBcInNvY2tldFwiLCBcInRpbWVvdXRcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnRIYW5kbGVyc1tldmVudF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RhYmxlLmVtaXQoZXZlbnQsIGFyZyk7XG4gIH07XG59KTtcblxuLy8gQW4gSFRUUChTKSByZXF1ZXN0IHRoYXQgY2FuIGJlIHJlZGlyZWN0ZWRcbmZ1bmN0aW9uIFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VDYWxsYmFjaykge1xuICAvLyBJbml0aWFsaXplIHRoZSByZXF1ZXN0XG4gIFdyaXRhYmxlLmNhbGwodGhpcyk7XG4gIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX3JlZGlyZWN0Q291bnQgPSAwO1xuICB0aGlzLl9yZWRpcmVjdHMgPSBbXTtcbiAgdGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggPSAwO1xuICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcblxuICAvLyBBdHRhY2ggYSBjYWxsYmFjayBpZiBwYXNzZWRcbiAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgcmVzcG9uc2VDYWxsYmFjayk7XG4gIH1cblxuICAvLyBSZWFjdCB0byByZXNwb25zZXMgb2YgbmF0aXZlIHJlcXVlc3RzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fb25OYXRpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHNlbGYuX3Byb2Nlc3NSZXNwb25zZShyZXNwb25zZSk7XG4gIH07XG5cbiAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkge1xuICAgIHZhciBzZWFyY2hQb3MgPSBvcHRpb25zLnBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaFBvcyA8IDApIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoUG9zKTtcbiAgICAgIG9wdGlvbnMuc2VhcmNoID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhzZWFyY2hQb3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBlcmZvcm0gdGhlIGZpcnN0IHJlcXVlc3RcbiAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcbn1cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4vLyBXcml0ZXMgYnVmZmVyZWQgZGF0YSB0byB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIChcImxlbmd0aFwiIGluIGRhdGEpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgc2hvdWxkIGJlIGEgc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheVwiKTtcbiAgfVxuICBpZiAodGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKyBkYXRhLmxlbmd0aCA8PSB0aGlzLl9vcHRpb25zLm1heEJvZHlMZW5ndGgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMucHVzaCh7IGRhdGE6IGRhdGEsIGVuY29kaW5nOiBlbmNvZGluZyB9KTtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC53cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcIlJlcXVlc3QgYm9keSBsYXJnZXIgdGhhbiBtYXhCb2R5TGVuZ3RoIGxpbWl0XCIpKTtcbiAgICB0aGlzLmFib3J0KCk7XG4gIH1cbn07XG5cbi8vIEVuZHMgdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gIGlmICghZGF0YSkge1xuICAgIGN1cnJlbnRSZXF1ZXN0LmVuZChudWxsLCBudWxsLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gU2V0cyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xufTtcblxuLy8gQ2xlYXJzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWxldGUgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVIZWFkZXIobmFtZSk7XG59O1xuXG4vLyBQcm94eSBhbGwgb3RoZXIgcHVibGljIENsaWVudFJlcXVlc3QgbWV0aG9kc1xuW1xuICBcImFib3J0XCIsIFwiZmx1c2hIZWFkZXJzXCIsIFwiZ2V0SGVhZGVyXCIsXG4gIFwic2V0Tm9EZWxheVwiLCBcInNldFNvY2tldEtlZXBBbGl2ZVwiLCBcInNldFRpbWVvdXRcIixcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFttZXRob2RdKGEsIGIpO1xuICB9O1xufSk7XG5cbi8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzXG5bXCJhYm9ydGVkXCIsIFwiY29ubmVjdGlvblwiLCBcInNvY2tldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sXG4gIH0pO1xufSk7XG5cbi8vIEV4ZWN1dGVzIHRoZSBuZXh0IG5hdGl2ZSByZXF1ZXN0IChpbml0aWFsIG9yIHJlZGlyZWN0KVxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3BlcmZvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBMb2FkIHRoZSBuYXRpdmUgcHJvdG9jb2xcbiAgdmFyIHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbDtcbiAgdmFyIG5hdGl2ZVByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5uYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdO1xuXG4gIC8vIElmIHNwZWNpZmllZCwgdXNlIHRoZSBhZ2VudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyAoSFRUUCBhbmQgSFRUUFMgdXNlIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMpXG4gIGlmICh0aGlzLl9vcHRpb25zLmFnZW50cykge1xuICAgIHZhciBzY2hlbWUgPSBwcm90b2NvbC5zdWJzdHIoMCwgcHJvdG9jb2wubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5fb3B0aW9ucy5hZ2VudCA9IHRoaXMuX29wdGlvbnMuYWdlbnRzW3NjaGVtZV07XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5hdGl2ZSByZXF1ZXN0XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3QgPVxuICAgICAgICBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0KHRoaXMuX29wdGlvbnMsIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UpO1xuICB0aGlzLl9jdXJyZW50VXJsID0gdXJsLmZvcm1hdCh0aGlzLl9vcHRpb25zKTtcblxuICAvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnNcbiAgcmVxdWVzdC5fcmVkaXJlY3RhYmxlID0gdGhpcztcbiAgZm9yICh2YXIgZXZlbnQgaW4gZXZlbnRIYW5kbGVycykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICByZXF1ZXN0Lm9uKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5kIGEgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZClcbiAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHtcbiAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCBlbnRpdHkgYW5kIGVuZC5cbiAgICB2YXIgcmVxdWVzdEJvZHlCdWZmZXJzID0gdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzO1xuICAgIChmdW5jdGlvbiB3cml0ZU5leHQoKSB7XG4gICAgICBpZiAocmVxdWVzdEJvZHlCdWZmZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gcmVxdWVzdEJvZHlCdWZmZXJzLnBvcCgpO1xuICAgICAgICByZXF1ZXN0LndyaXRlKGJ1ZmZlci5kYXRhLCBidWZmZXIuZW5jb2RpbmcsIHdyaXRlTmV4dCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KCkpO1xuICB9XG59O1xuXG4vLyBQcm9jZXNzZXMgYSByZXNwb25zZSBmcm9tIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIC8vIFN0b3JlIHRoZSByZWRpcmVjdGVkIHJlc3BvbnNlXG4gIGlmICh0aGlzLl9vcHRpb25zLnRyYWNrUmVkaXJlY3RzKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RzLnB1c2goe1xuICAgICAgdXJsOiB0aGlzLl9jdXJyZW50VXJsLFxuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSRkM3MjMxwqc2LjQ6IFRoZSAzeHggKFJlZGlyZWN0aW9uKSBjbGFzcyBvZiBzdGF0dXMgY29kZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBmdXJ0aGVyIGFjdGlvbiBuZWVkcyB0byBiZSB0YWtlbiBieSB0aGUgdXNlciBhZ2VudCBpbiBvcmRlciB0b1xuICAvLyBmdWxmaWxsIHRoZSByZXF1ZXN0LiBJZiBhIExvY2F0aW9uIGhlYWRlciBmaWVsZCBpcyBwcm92aWRlZCxcbiAgLy8gdGhlIHVzZXIgYWdlbnQgTUFZIGF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaXRzIHJlcXVlc3QgdG8gdGhlIFVSSVxuICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBMb2NhdGlvbiBmaWVsZCB2YWx1ZSxcbiAgLy8gZXZlbiBpZiB0aGUgc3BlY2lmaWMgc3RhdHVzIGNvZGUgaXMgbm90IHVuZGVyc3Rvb2QuXG4gIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gIGlmIChsb2NhdGlvbiAmJiB0aGlzLl9vcHRpb25zLmZvbGxvd1JlZGlyZWN0cyAhPT0gZmFsc2UgJiZcbiAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAvLyBSRkM3MjMxwqc2LjQ6IEEgY2xpZW50IFNIT1VMRCBkZXRlY3QgYW5kIGludGVydmVuZVxuICAgIC8vIGluIGN5Y2xpY2FsIHJlZGlyZWN0aW9ucyAoaS5lLiwgXCJpbmZpbml0ZVwiIHJlZGlyZWN0aW9uIGxvb3BzKS5cbiAgICBpZiAoKyt0aGlzLl9yZWRpcmVjdENvdW50ID4gdGhpcy5fb3B0aW9ucy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcIk1heCByZWRpcmVjdHMgZXhjZWVkZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSRkM3MjMxwqc2LjQ6IEF1dG9tYXRpYyByZWRpcmVjdGlvbiBuZWVkcyB0byBkb25lIHdpdGhcbiAgICAvLyBjYXJlIGZvciBtZXRob2RzIG5vdCBrbm93biB0byBiZSBzYWZlIFvigKZdLFxuICAgIC8vIHNpbmNlIHRoZSB1c2VyIG1pZ2h0IG5vdCB3aXNoIHRvIHJlZGlyZWN0IGFuIHVuc2FmZSByZXF1ZXN0LlxuICAgIC8vIFJGQzcyMzHCpzYuNC43OiBUaGUgMzA3IChUZW1wb3JhcnkgUmVkaXJlY3QpIHN0YXR1cyBjb2RlIGluZGljYXRlc1xuICAgIC8vIHRoYXQgdGhlIHRhcmdldCByZXNvdXJjZSByZXNpZGVzIHRlbXBvcmFyaWx5IHVuZGVyIGEgZGlmZmVyZW50IFVSSVxuICAgIC8vIGFuZCB0aGUgdXNlciBhZ2VudCBNVVNUIE5PVCBjaGFuZ2UgdGhlIHJlcXVlc3QgbWV0aG9kXG4gICAgLy8gaWYgaXQgcGVyZm9ybXMgYW4gYXV0b21hdGljIHJlZGlyZWN0aW9uIHRvIHRoYXQgVVJJLlxuICAgIHZhciBoZWFkZXI7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9vcHRpb25zLmhlYWRlcnM7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDMwNyAmJiAhKHRoaXMuX29wdGlvbnMubWV0aG9kIGluIFNBRkVfTUVUSE9EUykpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgIC8vIERyb3AgYSBwb3NzaWJsZSBlbnRpdHkgYW5kIGhlYWRlcnMgcmVsYXRlZCB0byBpdFxuICAgICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gICAgICBmb3IgKGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICgvXmNvbnRlbnQtL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyb3AgdGhlIEhvc3QgaGVhZGVyLCBhcyB0aGUgcmVkaXJlY3QgbWlnaHQgbGVhZCB0byBhIGRpZmZlcmVudCBob3N0XG4gICAgaWYgKCF0aGlzLl9pc1JlZGlyZWN0KSB7XG4gICAgICBmb3IgKGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICgvXmhvc3QkL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxuICAgIHZhciByZWRpcmVjdFVybCA9IHVybC5yZXNvbHZlKHRoaXMuX2N1cnJlbnRVcmwsIGxvY2F0aW9uKTtcbiAgICBkZWJ1ZyhcInJlZGlyZWN0aW5nIHRvXCIsIHJlZGlyZWN0VXJsKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIHVybC5wYXJzZShyZWRpcmVjdFVybCkpO1xuICAgIHRoaXMuX2lzUmVkaXJlY3QgPSB0cnVlO1xuICAgIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gVGhlIHJlc3BvbnNlIGlzIG5vdCBhIHJlZGlyZWN0OyByZXR1cm4gaXQgYXMtaXNcbiAgICByZXNwb25zZS5yZXNwb25zZVVybCA9IHRoaXMuX2N1cnJlbnRVcmw7XG4gICAgcmVzcG9uc2UucmVkaXJlY3RzID0gdGhpcy5fcmVkaXJlY3RzO1xuICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcblxuICAgIC8vIENsZWFuIHVwXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gIH1cbn07XG5cbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMCAqIDEwMjQgKiAxMDI0LFxuICB9O1xuXG4gIC8vIFdyYXAgZWFjaCBwcm90b2NvbFxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgdmFyIHByb3RvY29sID0gc2NoZW1lICsgXCI6XCI7XG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIHdyYXBwZWRQcm90b2NvbC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVybC5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5tYXhSZWRpcmVjdHMgPSBleHBvcnRzLm1heFJlZGlyZWN0cztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgICAgICAgIG1heFJlZGlyZWN0czogZXhwb3J0cy5tYXhSZWRpcmVjdHMsXG4gICAgICAgICAgbWF4Qm9keUxlbmd0aDogZXhwb3J0cy5tYXhCb2R5TGVuZ3RoLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMubmF0aXZlUHJvdG9jb2xzID0gbmF0aXZlUHJvdG9jb2xzO1xuICAgICAgYXNzZXJ0LmVxdWFsKG9wdGlvbnMucHJvdG9jb2wsIHByb3RvY29sLCBcInByb3RvY29sIG1pc21hdGNoXCIpO1xuICAgICAgZGVidWcoXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0ZXMgYSBHRVQgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIHdyYXBwZWRQcm90b2NvbC5nZXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gd3JhcHBlZFByb3RvY29sLnJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZXhwb3J0cztcbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB3cmFwKHsgaHR0cDogaHR0cCwgaHR0cHM6IGh0dHBzIH0pO1xubW9kdWxlLmV4cG9ydHMud3JhcCA9IHdyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mb2xsb3ctcmVkaXJlY3RzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIj9jYWVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXJsXCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(31);\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzPzY5NjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZvbGxvdy1yZWRpcmVjdHMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcz9hNDFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanM/NzU1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _ApiClient = __webpack_require__(15);var _ApiClient2 = _interopRequireDefault(_ApiClient);var _flowRuntime = __webpack_require__(47);var _flowRuntime2 = _interopRequireDefault(_flowRuntime);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\nvar sum = _flowRuntime2.default.annotate(function sum(a, b) {var _aType = _flowRuntime2.default.number();var _bType = _flowRuntime2.default.number();var _returnType = _flowRuntime2.default.return(_flowRuntime2.default.number());_flowRuntime2.default.param(\"a\", _aType).assert(a);_flowRuntime2.default.param(\"b\", _bType).assert(b);return _returnType.assert(a + b);}, _flowRuntime2.default.function(_flowRuntime2.default.param(\"a\", _flowRuntime2.default.number()), _flowRuntime2.default.param(\"b\", _flowRuntime2.default.number()), _flowRuntime2.default.return(_flowRuntime2.default.number())));\n\nconsole.log(sum(1, 2));\n\nvar Post = _flowRuntime2.default.type(\"Post\", _flowRuntime2.default.object(\n_flowRuntime2.default.property(\"id\", _flowRuntime2.default.number()),\n_flowRuntime2.default.property(\"title\", _flowRuntime2.default.string()),\n_flowRuntime2.default.property(\"author\", _flowRuntime2.default.string())));\n\n\nvar Response = _flowRuntime2.default.type(\"Response\", _flowRuntime2.default.object(\n_flowRuntime2.default.property(\"status\", _flowRuntime2.default.string()),\n_flowRuntime2.default.property(\"data\", Post)));\n\n\nvar client = new _ApiClient2.default(\"faketoken\");\n\nclient.fetch(\"GET\", \"/posts/1\").then(_flowRuntime2.default.annotate(function (response) {var _responseType = Response;_flowRuntime2.default.param(\"response\", _responseType).assert(response);\n  var post = Post.assert(response.data);\n  console.log(post);\n}, _flowRuntime2.default.function(_flowRuntime2.default.param(\"response\", Response))));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhIiwiYiIsImNvbnNvbGUiLCJsb2ciLCJjbGllbnQiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImRhdGEiLCJwb3N0Il0sIm1hcHBpbmdzIjoiOztBQUVBLHdDOztBQUVBLElBQUlBLHFDQUFNLGFBQUNDLENBQUQsRUFBWUMsQ0FBWixnQkFBRSw4QkFBRixjQUFhLDhCQUFiLGdEQUF3Qiw4QkFBeEIsa0lBQWtDRCxJQUFJQyxDQUF0QyxHQUFOLEVBQU0sZ0VBQUUsOEJBQUYsb0NBQWEsOEJBQWIsZ0NBQXNCLDhCQUF0QixFQUFOLENBQUo7O0FBRUFDLFFBQVFDLEdBQVIsQ0FBWUosSUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaOztBQUVBLDhDQUFZO0FBQ1YscUNBQUksOEJBQUosQ0FEVTtBQUVWLHdDQUFPLDhCQUFQLENBRlU7QUFHVix5Q0FBUSw4QkFBUixDQUhVLENBQVo7OztBQU1BLHNEQUFnQjtBQUNkLHlDQUFRLDhCQUFSLENBRGM7QUFFZCx1Q0FBTSxJQUFOLENBRmMsQ0FBaEI7OztBQUtBLElBQU1LLFNBQVMsd0JBQWMsV0FBZCxDQUFmOztBQUVBQSxPQUFPQyxLQUFQLENBQWEsS0FBYixFQUFvQixVQUFwQixFQUFnQ0MsSUFBaEMsZ0NBQXFDLFVBQUNDLFFBQUQsRUFBd0IscUJBQWYsUUFBZTtBQUMzRCxhQUFVLElBQVYsUUFBbUJBLFNBQVNDLElBQTVCO0FBQ0FOLFVBQVFDLEdBQVIsQ0FBWU0sSUFBWjtBQUNELENBSEQsRUFBcUMsdUVBQVMsUUFBVCxFQUFyQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9zaG91dmlrL1Byb2plY3RzL2Zsb3ctdGVzdCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBBcGlDbGllbnQgZnJvbSBcIi4vQXBpQ2xpZW50XCI7XG5cbmxldCBzdW0gPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIgPT4gYSArIGI7XG5cbmNvbnNvbGUubG9nKHN1bSgxLCAyKSk7XG5cbnR5cGUgUG9zdCA9IHtcbiAgaWQ6IG51bWJlcixcbiAgdGl0bGU6IHN0cmluZyxcbiAgYXV0aG9yOiBzdHJpbmdcbn07XG5cbnR5cGUgUmVzcG9uc2UgPSB7XG4gIHN0YXR1czogc3RyaW5nLFxuICBkYXRhOiBQb3N0XG59O1xuXG5jb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KFwiZmFrZXRva2VuXCIpO1xuXG5jbGllbnQuZmV0Y2goXCJHRVRcIiwgXCIvcG9zdHMvMVwiKS50aGVuKChyZXNwb25zZTogUmVzcG9uc2UpID0+IHtcbiAgY29uc3QgcG9zdDogUG9zdCA9IHJlc3BvbnNlLmRhdGE7XG4gIGNvbnNvbGUubG9nKHBvc3QpO1xufSk7XG4iXX0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/ODc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSx5Q0FBd0MscURBQXFELDJDQUEyQyx5REFBeUQsc0NBQXNDLHNDQUFzQzs7QUFFN1EsNkRBQTZELDRDQUE0Qyw0Q0FBNEMsK0VBQStFLG1EQUFtRCxtREFBbUQsa0NBQWtDOztBQUU1Vzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSx5RkFBeUYsNkJBQTZCO0FBQ3RIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDLGNBQWMiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9BcGlDbGllbnQgPSByZXF1aXJlKFwiLi9BcGlDbGllbnRcIik7dmFyIF9BcGlDbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpQ2xpZW50KTt2YXIgX2Zsb3dSdW50aW1lID0gcmVxdWlyZShcImZsb3ctcnVudGltZVwiKTt2YXIgX2Zsb3dSdW50aW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zsb3dSdW50aW1lKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge3JldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O31cblxudmFyIHN1bSA9IF9mbG93UnVudGltZTIuZGVmYXVsdC5hbm5vdGF0ZShmdW5jdGlvbiBzdW0oYSwgYikge3ZhciBfYVR5cGUgPSBfZmxvd1J1bnRpbWUyLmRlZmF1bHQubnVtYmVyKCk7dmFyIF9iVHlwZSA9IF9mbG93UnVudGltZTIuZGVmYXVsdC5udW1iZXIoKTt2YXIgX3JldHVyblR5cGUgPSBfZmxvd1J1bnRpbWUyLmRlZmF1bHQucmV0dXJuKF9mbG93UnVudGltZTIuZGVmYXVsdC5udW1iZXIoKSk7X2Zsb3dSdW50aW1lMi5kZWZhdWx0LnBhcmFtKFwiYVwiLCBfYVR5cGUpLmFzc2VydChhKTtfZmxvd1J1bnRpbWUyLmRlZmF1bHQucGFyYW0oXCJiXCIsIF9iVHlwZSkuYXNzZXJ0KGIpO3JldHVybiBfcmV0dXJuVHlwZS5hc3NlcnQoYSArIGIpO30sIF9mbG93UnVudGltZTIuZGVmYXVsdC5mdW5jdGlvbihfZmxvd1J1bnRpbWUyLmRlZmF1bHQucGFyYW0oXCJhXCIsIF9mbG93UnVudGltZTIuZGVmYXVsdC5udW1iZXIoKSksIF9mbG93UnVudGltZTIuZGVmYXVsdC5wYXJhbShcImJcIiwgX2Zsb3dSdW50aW1lMi5kZWZhdWx0Lm51bWJlcigpKSwgX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnJldHVybihfZmxvd1J1bnRpbWUyLmRlZmF1bHQubnVtYmVyKCkpKSk7XG5cbmNvbnNvbGUubG9nKHN1bSgxLCAyKSk7XG5cbnZhciBQb3N0ID0gX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnR5cGUoXCJQb3N0XCIsIF9mbG93UnVudGltZTIuZGVmYXVsdC5vYmplY3QoXG5fZmxvd1J1bnRpbWUyLmRlZmF1bHQucHJvcGVydHkoXCJpZFwiLCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQubnVtYmVyKCkpLFxuX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnByb3BlcnR5KFwidGl0bGVcIiwgX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnN0cmluZygpKSxcbl9mbG93UnVudGltZTIuZGVmYXVsdC5wcm9wZXJ0eShcImF1dGhvclwiLCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQuc3RyaW5nKCkpKSk7XG5cblxudmFyIFJlc3BvbnNlID0gX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnR5cGUoXCJSZXNwb25zZVwiLCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQub2JqZWN0KFxuX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnByb3BlcnR5KFwic3RhdHVzXCIsIF9mbG93UnVudGltZTIuZGVmYXVsdC5zdHJpbmcoKSksXG5fZmxvd1J1bnRpbWUyLmRlZmF1bHQucHJvcGVydHkoXCJkYXRhXCIsIFBvc3QpKSk7XG5cblxudmFyIGNsaWVudCA9IG5ldyBfQXBpQ2xpZW50Mi5kZWZhdWx0KFwiZmFrZXRva2VuXCIpO1xuXG5jbGllbnQuZmV0Y2goXCJHRVRcIiwgXCIvcG9zdHMvMVwiKS50aGVuKF9mbG93UnVudGltZTIuZGVmYXVsdC5hbm5vdGF0ZShmdW5jdGlvbiAocmVzcG9uc2UpIHt2YXIgX3Jlc3BvbnNlVHlwZSA9IFJlc3BvbnNlO19mbG93UnVudGltZTIuZGVmYXVsdC5wYXJhbShcInJlc3BvbnNlXCIsIF9yZXNwb25zZVR5cGUpLmFzc2VydChyZXNwb25zZSk7XG4gIHZhciBwb3N0ID0gUG9zdC5hc3NlcnQocmVzcG9uc2UuZGF0YSk7XG4gIGNvbnNvbGUubG9nKHBvc3QpO1xufSwgX2Zsb3dSdW50aW1lMi5kZWZhdWx0LmZ1bmN0aW9uKF9mbG93UnVudGltZTIuZGVmYXVsdC5wYXJhbShcInJlc3BvbnNlXCIsIFJlc3BvbnNlKSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2V3lKemRXMGlMQ0poSWl3aVlpSXNJbU52Ym5OdmJHVWlMQ0pzYjJjaUxDSmpiR2xsYm5RaUxDSm1aWFJqYUNJc0luUm9aVzRpTENKeVpYTndiMjV6WlNJc0ltUmhkR0VpTENKd2IzTjBJbDBzSW0xaGNIQnBibWR6SWpvaU96dEJRVVZCTEhkRE96dEJRVVZCTEVsQlFVbEJMSEZEUVVGTkxHRkJRVU5ETEVOQlFVUXNSVUZCV1VNc1EwRkJXaXhuUWtGQlJTdzRRa0ZCUml4alFVRmhMRGhDUVVGaUxHZEVRVUYzUWl3NFFrRkJlRUlzYTBsQlFXdERSQ3hKUVVGSlF5eERRVUYwUXl4SFFVRk9MRVZCUVUwc1owVkJRVVVzT0VKQlFVWXNiME5CUVdFc09FSkJRV0lzWjBOQlFYTkNMRGhDUVVGMFFpeEZRVUZPTEVOQlFVbzdPMEZCUlVGRExGRkJRVkZETEVkQlFWSXNRMEZCV1Vvc1NVRkJTU3hEUVVGS0xFVkJRVThzUTBGQlVDeERRVUZhT3p0QlFVVkJMRGhEUVVGWk8wRkJRMVlzY1VOQlFVa3NPRUpCUVVvc1EwRkVWVHRCUVVWV0xIZERRVUZQTERoQ1FVRlFMRU5CUmxVN1FVRkhWaXg1UTBGQlVTdzRRa0ZCVWl4RFFVaFZMRU5CUVZvN096dEJRVTFCTEhORVFVRm5RanRCUVVOa0xIbERRVUZSTERoQ1FVRlNMRU5CUkdNN1FVRkZaQ3gxUTBGQlRTeEpRVUZPTEVOQlJtTXNRMEZCYUVJN096dEJRVXRCTEVsQlFVMUxMRk5CUVZNc2QwSkJRV01zVjBGQlpDeERRVUZtT3p0QlFVVkJRU3hQUVVGUFF5eExRVUZRTEVOQlFXRXNTMEZCWWl4RlFVRnZRaXhWUVVGd1FpeEZRVUZuUTBNc1NVRkJhRU1zWjBOQlFYRkRMRlZCUVVORExGRkJRVVFzUlVGQmQwSXNjVUpCUVdZc1VVRkJaVHRCUVVNelJDeGhRVUZWTEVsQlFWWXNVVUZCYlVKQkxGTkJRVk5ETEVsQlFUVkNPMEZCUTBGT0xGVkJRVkZETEVkQlFWSXNRMEZCV1Uwc1NVRkJXanRCUVVORUxFTkJTRVFzUlVGQmNVTXNkVVZCUVZNc1VVRkJWQ3hGUVVGeVF5SXNJbVpwYkdVaU9pSnBibVJsZUM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJdmFHOXRaUzl6YUc5MWRtbHJMMUJ5YjJwbFkzUnpMMlpzYjNjdGRHVnpkQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4dklFQm1iRzkzWEc1Y2JtbHRjRzl5ZENCQmNHbERiR2xsYm5RZ1puSnZiU0JjSWk0dlFYQnBRMnhwWlc1MFhDSTdYRzVjYm14bGRDQnpkVzBnUFNBb1lUb2diblZ0WW1WeUxDQmlPaUJ1ZFcxaVpYSXBPaUJ1ZFcxaVpYSWdQVDRnWVNBcklHSTdYRzVjYm1OdmJuTnZiR1V1Ykc5bktITjFiU2d4TENBeUtTazdYRzVjYm5SNWNHVWdVRzl6ZENBOUlIdGNiaUFnYVdRNklHNTFiV0psY2l4Y2JpQWdkR2wwYkdVNklITjBjbWx1Wnl4Y2JpQWdZWFYwYUc5eU9pQnpkSEpwYm1kY2JuMDdYRzVjYm5SNWNHVWdVbVZ6Y0c5dWMyVWdQU0I3WEc0Z0lITjBZWFIxY3pvZ2MzUnlhVzVuTEZ4dUlDQmtZWFJoT2lCUWIzTjBYRzU5TzF4dVhHNWpiMjV6ZENCamJHbGxiblFnUFNCdVpYY2dRWEJwUTJ4cFpXNTBLRndpWm1GclpYUnZhMlZ1WENJcE8xeHVYRzVqYkdsbGJuUXVabVYwWTJnb1hDSkhSVlJjSWl3Z1hDSXZjRzl6ZEhNdk1Wd2lLUzUwYUdWdUtDaHlaWE53YjI1elpUb2dVbVZ6Y0c5dWMyVXBJRDArSUh0Y2JpQWdZMjl1YzNRZ2NHOXpkRG9nVUc5emRDQTlJSEpsYzNCdmJuTmxMbVJoZEdFN1hHNGdJR052Ym5OdmJHVXViRzluS0hCdmMzUXBPMXh1ZlNrN1hHNGlYWDA9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}(); // @moduledoc\n//\n// This is the base API client, it acts as a container for Authentication,\n// Login, user settings, base endpoints, etc.\n// It is meant to be easy to mock.\n\nvar _axios = __webpack_require__(16);var _axios2 = _interopRequireDefault(_axios);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\nvar logRequests = typeof DEV !== \"undefined\" && DEV;\nvar requestColor = \"CornflowerBlue\";\nvar responseColor = \"Crimson\";\nvar API_URL = \"http://localhost:3000\";var\n\nApiClient = function () {_createClass(ApiClient, null, [{ key: \"createToken\", value: function createToken(\n    username, password) {\n      return \"Basic \" + btoa(username + \":\" + password);\n    } }]);\n\n  function ApiClient(authToken) {var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console.error.bind(console);_classCallCheck(this, ApiClient);\n    this.authToken = authToken;\n    this.errorHandler = errorHandler;\n  }_createClass(ApiClient, [{ key: \"encodeQueryParameters\", value: function encodeQueryParameters(\n\n    parameters) {\n      if (parameters) {\n        return (\n          \"?\" +\n          Object.keys(parameters).\n          map(\n          function (key) {return (\n              encodeURIComponent(key) + \"=\" + encodeURIComponent(\n              parameters[key]));}).\n\n\n          join(\"&\"));\n\n      }\n      return \"\";\n    } }, { key: \"requestJWT\", value: function requestJWT()\n\n    {var _this = this;\n      var method = \"GET\";\n      var path = \"/v2/token\";\n      var headers = {\n        Authorization: this.authToken };\n\n      if (logRequests) {\n        console.groupCollapsed(\"%c\" + method + \" \" + path, \"color: \" + requestColor);\n        console.log(\"method:\", method);\n        console.log(\"path:\", API_URL + path);\n        console.log(\"headers:\", headers);\n        console.groupEnd();\n      }\n      return new Promise(function (resolve, reject) {return (\n          (0, _axios2.default)(API_URL + path, {\n            method: method,\n            headers: headers,\n            mode: \"cors\" }).\n          then(function (response) {\n            if (logRequests) {\n              console.groupCollapsed(\"%c\" +\n              method + \" \" + path, \"color: \" +\n              responseColor);\n\n              console.groupEnd();\n            }\n            if (response.status === 401) {\n              reject(new Error(\"Invalid email or password\"));\n            }\n            response.\n            text().\n            then(function (token) {\n              if (token) {\n                _this.authToken = \"Bearer \" + token;\n                resolve(_this.authToken);\n              } else {\n                reject(new Error(\"The server did not send a\"));\n              }\n            }).\n            catch(reject);\n          }));});\n\n    } }, { key: \"fetch\", value: function fetch(\n\n    method, path, body) {var _this2 = this;var userHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var headers = Object.assign(\n      {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n        Authorization: this.authToken },\n\n      userHeaders);\n\n      if (logRequests) {\n        console.groupCollapsed(\"%c\" + method + \" \" + path, \"color: \" + requestColor);\n        console.log(\"method:\", method);\n        console.log(\"path:\", API_URL + path);\n        console.log(\"headers:\", headers);\n        if (body) {\n          console.log(\"body:\", body);\n        }\n        console.groupEnd();\n      }\n      return new Promise(function (resolve, reject) {return (\n          (0, _axios2.default)(API_URL + path, {\n            method: method,\n            headers: headers,\n            // mode: \"cors\",\n            data: body }).\n\n          then(function (response) {\n            if (logRequests) {\n              console.groupCollapsed(\"%c\" +\n              method + \" \" + path, \"color: \" +\n              responseColor);\n\n              console.groupEnd();\n            }\n            if (response.status === 401) {\n              window.location.pathname = \"/logout\";\n              resolve({\n                status: \"error\",\n                message: \"Insufficient access rights\",\n                code: response.status });\n\n            } else if (response.status === 403) {\n              resolve({\n                status: \"error\",\n                message: \"Insufficient access rights\",\n                code: response.status });\n\n            } else if (response.status >= 400 && response.status < 500) {\n              resolve({\n                status: \"error\",\n                message: \"Client error: Try refreshing the browser\",\n                code: response.status });\n\n            } else if (response.status >= 500) {\n              resolve({\n                status: \"error\",\n                message:\n                \"Server error: try refreshing the browser, or try again later.\",\n                code: response.status });\n\n            } else {\n              // response\n              //   .json()\n              //   .then(json => {\n              resolve({\n                status: \"ok\",\n                data: response.data });\n\n\n              //   .catch(() => {\n              //     // Server sent no response, which is ok in most cases. Not all\n              //     // requests will get a response (DELETE for example).\n              //     resolve({\n              //       status: \"ok\",\n              //       data: null\n              //     });\n              //   });\n            }\n          }).\n          catch(function (error) {\n            var result = {\n              status: \"error\",\n              message: \"An error occured talking to the server.\",\n              cause: error };\n\n            _this2.errorHandler(result);\n            resolve(result);\n          }));});\n\n    } }]);return ApiClient;}();exports.default = ApiClient;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9BcGlDbGllbnQuanMiXSwibmFtZXMiOlsibG9nUmVxdWVzdHMiLCJERVYiLCJyZXF1ZXN0Q29sb3IiLCJyZXNwb25zZUNvbG9yIiwiQVBJX1VSTCIsIkFwaUNsaWVudCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJidG9hIiwiYXV0aFRva2VuIiwiZXJyb3JIYW5kbGVyIiwiY29uc29sZSIsImVycm9yIiwiYmluZCIsInBhcmFtZXRlcnMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwia2V5Iiwiam9pbiIsIm1ldGhvZCIsInBhdGgiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImdyb3VwQ29sbGFwc2VkIiwibG9nIiwiZ3JvdXBFbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm1vZGUiLCJ0aGVuIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJFcnJvciIsInRleHQiLCJ0b2tlbiIsImNhdGNoIiwiYm9keSIsInVzZXJIZWFkZXJzIiwiYXNzaWduIiwiQWNjZXB0IiwiZGF0YSIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJtZXNzYWdlIiwiY29kZSIsInJlc3VsdCIsImNhdXNlIl0sIm1hcHBpbmdzIjoiaW5CQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEI7O0FBRUEsSUFBTUEsY0FBYyxPQUFPQyxHQUFQLEtBQWUsV0FBZixJQUE4QkEsR0FBbEQ7QUFDQSxJQUFNQyxlQUFlLGdCQUFyQjtBQUNBLElBQU1DLGdCQUFnQixTQUF0QjtBQUNBLElBQU1DLFVBQVUsdUJBQWhCLEM7O0FBRXFCQyxTO0FBQ0FDLFksRUFBVUMsUSxFQUFVO0FBQ3JDLGFBQU8sV0FBV0MsS0FBS0YsV0FBVyxHQUFYLEdBQWlCQyxRQUF0QixDQUFsQjtBQUNELEs7O0FBRUQscUJBQVlFLFNBQVosRUFBbUUsS0FBNUNDLFlBQTRDLHVFQUE3QkMsUUFBUUMsS0FBUixDQUFjQyxJQUFkLENBQW1CRixPQUFuQixD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TCxlQTNESCxDQTJEUyxpQkFBUztBQUNkLGdCQUFNVyxTQUFTO0FBQ2JmLHNCQUFRLE9BREs7QUFFYmEsdUJBQVMseUNBRkk7QUFHYkcscUJBQU90QyxLQUhNLEVBQWY7O0FBS0EsbUJBQUtGLFlBQUwsQ0FBa0J1QyxNQUFsQjtBQUNBcEIsb0JBQVFvQixNQUFSO0FBQ0QsV0FuRUgsQ0FEaUIsR0FBWixDQUFQOztBQXNFRCxLLDRDQWhLa0I1QyxTIiwiZmlsZSI6IkFwaUNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9zaG91dmlrL1Byb2plY3RzL2Zsb3ctdGVzdCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBtb2R1bGVkb2Ncbi8vXG4vLyBUaGlzIGlzIHRoZSBiYXNlIEFQSSBjbGllbnQsIGl0IGFjdHMgYXMgYSBjb250YWluZXIgZm9yIEF1dGhlbnRpY2F0aW9uLFxuLy8gTG9naW4sIHVzZXIgc2V0dGluZ3MsIGJhc2UgZW5kcG9pbnRzLCBldGMuXG4vLyBJdCBpcyBtZWFudCB0byBiZSBlYXN5IHRvIG1vY2suXG5cbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcblxuY29uc3QgbG9nUmVxdWVzdHMgPSB0eXBlb2YgREVWICE9PSBcInVuZGVmaW5lZFwiICYmIERFVjtcbmNvbnN0IHJlcXVlc3RDb2xvciA9IFwiQ29ybmZsb3dlckJsdWVcIjtcbmNvbnN0IHJlc3BvbnNlQ29sb3IgPSBcIkNyaW1zb25cIjtcbmNvbnN0IEFQSV9VUkwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcGlDbGllbnQge1xuICBzdGF0aWMgY3JlYXRlVG9rZW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIFwiQmFzaWMgXCIgKyBidG9hKHVzZXJuYW1lICsgXCI6XCIgKyBwYXNzd29yZCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhdXRoVG9rZW4sIGVycm9ySGFuZGxlciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSkge1xuICAgIHRoaXMuYXV0aFRva2VuID0gYXV0aFRva2VuO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICB9XG5cbiAgZW5jb2RlUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCI/XCIgK1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKVxuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICBrZXkgPT5cbiAgICAgICAgICAgICAgYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNba2V5XVxuICAgICAgICAgICAgICApfWBcbiAgICAgICAgICApXG4gICAgICAgICAgLmpvaW4oXCImXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHJlcXVlc3RKV1QoKSB7XG4gICAgY29uc3QgbWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCBwYXRoID0gXCIvdjIvdG9rZW5cIjtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy5hdXRoVG9rZW5cbiAgICB9O1xuICAgIGlmIChsb2dSZXF1ZXN0cykge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgJWMke21ldGhvZH0gJHtwYXRofWAsIGBjb2xvcjogJHtyZXF1ZXN0Q29sb3J9YCk7XG4gICAgICBjb25zb2xlLmxvZyhcIm1ldGhvZDpcIiwgbWV0aG9kKTtcbiAgICAgIGNvbnNvbGUubG9nKFwicGF0aDpcIiwgQVBJX1VSTCArIHBhdGgpO1xuICAgICAgY29uc29sZS5sb2coXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICBheGlvcyhBUElfVVJMICsgcGF0aCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG1vZGU6IFwiY29yc1wiXG4gICAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKGxvZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgICAgICAgIGAlYyR7bWV0aG9kfSAke3BhdGh9YCxcbiAgICAgICAgICAgIGBjb2xvcjogJHtyZXNwb25zZUNvbG9yfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAudGV4dCgpXG4gICAgICAgICAgLnRoZW4odG9rZW4gPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuID0gXCJCZWFyZXIgXCIgKyB0b2tlbjtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmF1dGhUb2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGhlIHNlcnZlciBkaWQgbm90IHNlbmQgYVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGZldGNoKG1ldGhvZCwgcGF0aCwgYm9keSwgdXNlckhlYWRlcnMgPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy5hdXRoVG9rZW5cbiAgICAgIH0sXG4gICAgICB1c2VySGVhZGVyc1xuICAgICk7XG4gICAgaWYgKGxvZ1JlcXVlc3RzKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGAlYyR7bWV0aG9kfSAke3BhdGh9YCwgYGNvbG9yOiAke3JlcXVlc3RDb2xvcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKFwibWV0aG9kOlwiLCBtZXRob2QpO1xuICAgICAgY29uc29sZS5sb2coXCJwYXRoOlwiLCBBUElfVVJMICsgcGF0aCk7XG4gICAgICBjb25zb2xlLmxvZyhcImhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJib2R5OlwiLCBib2R5KTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICBheGlvcyhBUElfVVJMICsgcGF0aCwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIC8vIG1vZGU6IFwiY29yc1wiLFxuICAgICAgICBkYXRhOiBib2R5XG4gICAgICB9KVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgaWYgKGxvZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICAgICAgICBgJWMke21ldGhvZH0gJHtwYXRofWAsXG4gICAgICAgICAgICAgIGBjb2xvcjogJHtyZXNwb25zZUNvbG9yfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lID0gXCIvbG9nb3V0XCI7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW5zdWZmaWNpZW50IGFjY2VzcyByaWdodHNcIixcbiAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW5zdWZmaWNpZW50IGFjY2VzcyByaWdodHNcIixcbiAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2xpZW50IGVycm9yOiBUcnkgcmVmcmVzaGluZyB0aGUgYnJvd3NlclwiLFxuICAgICAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgIFwiU2VydmVyIGVycm9yOiB0cnkgcmVmcmVzaGluZyB0aGUgYnJvd3Nlciwgb3IgdHJ5IGFnYWluIGxhdGVyLlwiLFxuICAgICAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXNwb25zZVxuICAgICAgICAgICAgLy8gICAuanNvbigpXG4gICAgICAgICAgICAvLyAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZS5kYXRhXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gICAgIC8vIFNlcnZlciBzZW50IG5vIHJlc3BvbnNlLCB3aGljaCBpcyBvayBpbiBtb3N0IGNhc2VzLiBOb3QgYWxsXG4gICAgICAgICAgICAvLyAgICAgLy8gcmVxdWVzdHMgd2lsbCBnZXQgYSByZXNwb25zZSAoREVMRVRFIGZvciBleGFtcGxlKS5cbiAgICAgICAgICAgIC8vICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIC8vICAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgICAgICAgLy8gICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkFuIGVycm9yIG9jY3VyZWQgdGFsa2luZyB0byB0aGUgc2VydmVyLlwiLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlcihyZXN1bHQpO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iXX0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBpQ2xpZW50LmpzPzAxMDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWEsOENBQThDLGNBQWMsRUFBRSxnQ0FBZ0MsMENBQTBDLGVBQWUsa0JBQWtCLE9BQU8sMEJBQTBCLHVEQUF1RCwrQkFBK0Isc0RBQXNELDREQUE0RCx3REFBd0Qsb0VBQW9FLDREQUE0RCxzQkFBc0IsR0FBRztBQUNobkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQThCLDZDQUE2QyxzQ0FBc0Msc0NBQXNDLGlCQUFpQixpREFBaUQseUNBQXlDOztBQUVsUTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxpQ0FBaUMsbUhBQW1IO0FBQ3BKO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsaUNBQWlDOzs7QUFHakM7O0FBRUE7QUFDQTtBQUNBLEtBQUssRUFBRSxHQUFHOztBQUVWLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXLElBQUk7O0FBRWYsS0FBSyxFQUFFLEdBQUc7O0FBRVYseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7OztBQUdyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsSUFBSTs7QUFFZixLQUFLLEVBQUUsR0FBRyxrQkFBa0IsR0FBRztBQUMvQiwyQ0FBMkMsY0FBYyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge2ZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHt2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7aWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge2lmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7aWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyAvLyBAbW9kdWxlZG9jXG4vL1xuLy8gVGhpcyBpcyB0aGUgYmFzZSBBUEkgY2xpZW50LCBpdCBhY3RzIGFzIGEgY29udGFpbmVyIGZvciBBdXRoZW50aWNhdGlvbixcbi8vIExvZ2luLCB1c2VyIHNldHRpbmdzLCBiYXNlIGVuZHBvaW50cywgZXRjLlxuLy8gSXQgaXMgbWVhbnQgdG8gYmUgZWFzeSB0byBtb2NrLlxuXG52YXIgX2F4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO3ZhciBfYXhpb3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXhpb3MpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7cmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7fX1cblxudmFyIGxvZ1JlcXVlc3RzID0gdHlwZW9mIERFViAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERVY7XG52YXIgcmVxdWVzdENvbG9yID0gXCJDb3JuZmxvd2VyQmx1ZVwiO1xudmFyIHJlc3BvbnNlQ29sb3IgPSBcIkNyaW1zb25cIjtcbnZhciBBUElfVVJMID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjt2YXJcblxuQXBpQ2xpZW50ID0gZnVuY3Rpb24gKCkge19jcmVhdGVDbGFzcyhBcGlDbGllbnQsIG51bGwsIFt7IGtleTogXCJjcmVhdGVUb2tlblwiLCB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVG9rZW4oXG4gICAgdXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gXCJCYXNpYyBcIiArIGJ0b2EodXNlcm5hbWUgKyBcIjpcIiArIHBhc3N3b3JkKTtcbiAgICB9IH1dKTtcblxuICBmdW5jdGlvbiBBcGlDbGllbnQoYXV0aFRva2VuKSB7dmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO19jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGlDbGllbnQpO1xuICAgIHRoaXMuYXV0aFRva2VuID0gYXV0aFRva2VuO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICB9X2NyZWF0ZUNsYXNzKEFwaUNsaWVudCwgW3sga2V5OiBcImVuY29kZVF1ZXJ5UGFyYW1ldGVyc1wiLCB2YWx1ZTogZnVuY3Rpb24gZW5jb2RlUXVlcnlQYXJhbWV0ZXJzKFxuXG4gICAgcGFyYW1ldGVycykge1xuICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBcIj9cIiArXG4gICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVycykuXG4gICAgICAgICAgbWFwKFxuICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4gKFxuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzW2tleV0pKTt9KS5cblxuXG4gICAgICAgICAgam9pbihcIiZcIikpO1xuXG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IH0sIHsga2V5OiBcInJlcXVlc3RKV1RcIiwgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3RKV1QoKVxuXG4gICAge3ZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgbWV0aG9kID0gXCJHRVRcIjtcbiAgICAgIHZhciBwYXRoID0gXCIvdjIvdG9rZW5cIjtcbiAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLmF1dGhUb2tlbiB9O1xuXG4gICAgICBpZiAobG9nUmVxdWVzdHMpIHtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjXCIgKyBtZXRob2QgKyBcIiBcIiArIHBhdGgsIFwiY29sb3I6IFwiICsgcmVxdWVzdENvbG9yKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJtZXRob2Q6XCIsIG1ldGhvZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicGF0aDpcIiwgQVBJX1VSTCArIHBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge3JldHVybiAoXG4gICAgICAgICAgKDAsIF9heGlvczIuZGVmYXVsdCkoQVBJX1VSTCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIG1vZGU6IFwiY29yc1wiIH0pLlxuICAgICAgICAgIHRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAobG9nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjXCIgK1xuICAgICAgICAgICAgICBtZXRob2QgKyBcIiBcIiArIHBhdGgsIFwiY29sb3I6IFwiICtcbiAgICAgICAgICAgICAgcmVzcG9uc2VDb2xvcik7XG5cbiAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLlxuICAgICAgICAgICAgdGV4dCgpLlxuICAgICAgICAgICAgdGhlbihmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXV0aFRva2VuID0gXCJCZWFyZXIgXCIgKyB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmF1dGhUb2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRoZSBzZXJ2ZXIgZGlkIG5vdCBzZW5kIGFcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5cbiAgICAgICAgICAgIGNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSkpO30pO1xuXG4gICAgfSB9LCB7IGtleTogXCJmZXRjaFwiLCB2YWx1ZTogZnVuY3Rpb24gZmV0Y2goXG5cbiAgICBtZXRob2QsIHBhdGgsIGJvZHkpIHt2YXIgX3RoaXMyID0gdGhpczt2YXIgdXNlckhlYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy5hdXRoVG9rZW4gfSxcblxuICAgICAgdXNlckhlYWRlcnMpO1xuXG4gICAgICBpZiAobG9nUmVxdWVzdHMpIHtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjXCIgKyBtZXRob2QgKyBcIiBcIiArIHBhdGgsIFwiY29sb3I6IFwiICsgcmVxdWVzdENvbG9yKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJtZXRob2Q6XCIsIG1ldGhvZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicGF0aDpcIiwgQVBJX1VSTCArIHBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiYm9keTpcIiwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtyZXR1cm4gKFxuICAgICAgICAgICgwLCBfYXhpb3MyLmRlZmF1bHQpKEFQSV9VUkwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAvLyBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgIGRhdGE6IGJvZHkgfSkuXG5cbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGxvZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCIlY1wiICtcbiAgICAgICAgICAgICAgbWV0aG9kICsgXCIgXCIgKyBwYXRoLCBcImNvbG9yOiBcIiArXG4gICAgICAgICAgICAgIHJlc3BvbnNlQ29sb3IpO1xuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBcIi9sb2dvdXRcIjtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnN1ZmZpY2llbnQgYWNjZXNzIHJpZ2h0c1wiLFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkluc3VmZmljaWVudCBhY2Nlc3MgcmlnaHRzXCIsXG4gICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2xpZW50IGVycm9yOiBUcnkgcmVmcmVzaGluZyB0aGUgYnJvd3NlclwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgXCJTZXJ2ZXIgZXJyb3I6IHRyeSByZWZyZXNoaW5nIHRoZSBicm93c2VyLCBvciB0cnkgYWdhaW4gbGF0ZXIuXCIsXG4gICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXNwb25zZVxuICAgICAgICAgICAgICAvLyAgIC5qc29uKClcbiAgICAgICAgICAgICAgLy8gICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2UuZGF0YSB9KTtcblxuXG4gICAgICAgICAgICAgIC8vICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gICAgIC8vIFNlcnZlciBzZW50IG5vIHJlc3BvbnNlLCB3aGljaCBpcyBvayBpbiBtb3N0IGNhc2VzLiBOb3QgYWxsXG4gICAgICAgICAgICAgIC8vICAgICAvLyByZXF1ZXN0cyB3aWxsIGdldCBhIHJlc3BvbnNlIChERUxFVEUgZm9yIGV4YW1wbGUpLlxuICAgICAgICAgICAgICAvLyAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIC8vICAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgICAgICAgICAvLyAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5cbiAgICAgICAgICBjYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkFuIGVycm9yIG9jY3VyZWQgdGFsa2luZyB0byB0aGUgc2VydmVyLlwiLFxuICAgICAgICAgICAgICBjYXVzZTogZXJyb3IgfTtcblxuICAgICAgICAgICAgX3RoaXMyLmVycm9ySGFuZGxlcihyZXN1bHQpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pKTt9KTtcblxuICAgIH0gfV0pO3JldHVybiBBcGlDbGllbnQ7fSgpO2V4cG9ydHMuZGVmYXVsdCA9IEFwaUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlCY0dsRGJHbGxiblF1YW5NaVhTd2libUZ0WlhNaU9sc2liRzluVW1WeGRXVnpkSE1pTENKRVJWWWlMQ0p5WlhGMVpYTjBRMjlzYjNJaUxDSnlaWE53YjI1elpVTnZiRzl5SWl3aVFWQkpYMVZTVENJc0lrRndhVU5zYVdWdWRDSXNJblZ6WlhKdVlXMWxJaXdpY0dGemMzZHZjbVFpTENKaWRHOWhJaXdpWVhWMGFGUnZhMlZ1SWl3aVpYSnliM0pJWVc1a2JHVnlJaXdpWTI5dWMyOXNaU0lzSW1WeWNtOXlJaXdpWW1sdVpDSXNJbkJoY21GdFpYUmxjbk1pTENKUFltcGxZM1FpTENKclpYbHpJaXdpYldGd0lpd2laVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBJaXdpYTJWNUlpd2lhbTlwYmlJc0ltMWxkR2h2WkNJc0luQmhkR2dpTENKb1pXRmtaWEp6SWl3aVFYVjBhRzl5YVhwaGRHbHZiaUlzSW1keWIzVndRMjlzYkdGd2MyVmtJaXdpYkc5bklpd2laM0p2ZFhCRmJtUWlMQ0pRY205dGFYTmxJaXdpY21WemIyeDJaU0lzSW5KbGFtVmpkQ0lzSW0xdlpHVWlMQ0owYUdWdUlpd2ljbVZ6Y0c5dWMyVWlMQ0p6ZEdGMGRYTWlMQ0pGY25KdmNpSXNJblJsZUhRaUxDSjBiMnRsYmlJc0ltTmhkR05vSWl3aVltOWtlU0lzSW5WelpYSklaV0ZrWlhKeklpd2lZWE56YVdkdUlpd2lRV05qWlhCMElpd2laR0YwWVNJc0luZHBibVJ2ZHlJc0lteHZZMkYwYVc5dUlpd2ljR0YwYUc1aGJXVWlMQ0p0WlhOellXZGxJaXdpWTI5a1pTSXNJbkpsYzNWc2RDSXNJbU5oZFhObElsMHNJbTFoY0hCcGJtZHpJam9pYVc1Q1FVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNPRUk3TzBGQlJVRXNTVUZCVFVFc1kwRkJZeXhQUVVGUFF5eEhRVUZRTEV0QlFXVXNWMEZCWml4SlFVRTRRa0VzUjBGQmJFUTdRVUZEUVN4SlFVRk5ReXhsUVVGbExHZENRVUZ5UWp0QlFVTkJMRWxCUVUxRExHZENRVUZuUWl4VFFVRjBRanRCUVVOQkxFbEJRVTFETEZWQlFWVXNkVUpCUVdoQ0xFTTdPMEZCUlhGQ1F5eFRPMEZCUTBGRExGa3NSVUZCVlVNc1VTeEZRVUZWTzBGQlEzSkRMR0ZCUVU4c1YwRkJWME1zUzBGQlMwWXNWMEZCVnl4SFFVRllMRWRCUVdsQ1F5eFJRVUYwUWl4RFFVRnNRanRCUVVORUxFczdPMEZCUlVRc2NVSkJRVmxGTEZOQlFWb3NSVUZCYlVVc1MwRkJOVU5ETEZsQlFUUkRMSFZGUVVFM1FrTXNVVUZCVVVNc1MwRkJVaXhEUVVGalF5eEpRVUZrTEVOQlFXMUNSaXhQUVVGdVFpeERRVUUyUWp0QlFVTnFSU3hUUVVGTFJpeFRRVUZNTEVkQlFXbENRU3hUUVVGcVFqdEJRVU5CTEZOQlFVdERMRmxCUVV3c1IwRkJiMEpCTEZsQlFYQkNPMEZCUTBRc1J6czdRVUZGY1VKSkxHTXNSVUZCV1R0QlFVTm9ReXhWUVVGSlFTeFZRVUZLTEVWQlFXZENPMEZCUTJRN1FVRkRSVHRCUVVOQlF5eHBRa0ZCVDBNc1NVRkJVQ3hEUVVGWlJpeFZRVUZhTzBGQlEwZEhMR0ZCUkVnN1FVRkZTVHRCUVVOTFF5eHBRMEZCYlVKRExFZEJRVzVDTEVOQlJFd3NVMEZEWjBORU8wRkJRelZDU2l4NVFrRkJWMHNzUjBGQldDeERRVVEwUWl4RFFVUm9ReXhIUVVaS096czdRVUZQUjBNc1kwRlFTQ3hEUVU5UkxFZEJVRklzUTBGR1JqczdRVUZYUkR0QlFVTkVMR0ZCUVU4c1JVRkJVRHRCUVVORUxFczdPMEZCUlZrN1FVRkRXQ3hWUVVGTlF5eFRRVUZUTEV0QlFXWTdRVUZEUVN4VlFVRk5ReXhQUVVGUExGZEJRV0k3UVVGRFFTeFZRVUZOUXl4VlFVRlZPMEZCUTJSRExIVkNRVUZsTEV0QlFVdG1MRk5CUkU0c1JVRkJhRUk3TzBGQlIwRXNWVUZCU1ZRc1YwRkJTaXhGUVVGcFFqdEJRVU5tVnl4blFrRkJVV01zWTBGQlVpeFJRVUUwUWtvc1RVRkJOVUlzVTBGQmMwTkRMRWxCUVhSRExHTkJRWGRFY0VJc1dVRkJlRVE3UVVGRFFWTXNaMEpCUVZGbExFZEJRVklzUTBGQldTeFRRVUZhTEVWQlFYVkNUQ3hOUVVGMlFqdEJRVU5CVml4blFrRkJVV1VzUjBGQlVpeERRVUZaTEU5QlFWb3NSVUZCY1VKMFFpeFZRVUZWYTBJc1NVRkJMMEk3UVVGRFFWZ3NaMEpCUVZGbExFZEJRVklzUTBGQldTeFZRVUZhTEVWQlFYZENTQ3hQUVVGNFFqdEJRVU5CV2l4blFrRkJVV2RDTEZGQlFWSTdRVUZEUkR0QlFVTkVMR0ZCUVU4c1NVRkJTVU1zVDBGQlNpeERRVUZaTEZWQlFVTkRMRTlCUVVRc1JVRkJWVU1zVFVGQlZqdEJRVU5xUWl3clFrRkJUVEZDTEZWQlFWVnJRaXhKUVVGb1FpeEZRVUZ6UWp0QlFVTndRa1FzTUVKQlJHOUNPMEZCUlhCQ1JTdzBRa0ZHYjBJN1FVRkhjRUpSTEd0Q1FVRk5MRTFCU0dNc1JVRkJkRUk3UVVGSlIwTXNZMEZLU0N4RFFVbFJMRzlDUVVGWk8wRkJRMnhDTEdkQ1FVRkphRU1zVjBGQlNpeEZRVUZwUWp0QlFVTm1WeXh6UWtGQlVXTXNZMEZCVWp0QlFVTlBTaXh2UWtGRVVDeFRRVU5wUWtNc1NVRkVha0k3UVVGRldXNUNMREpDUVVaYU96dEJRVWxCVVN4elFrRkJVV2RDTEZGQlFWSTdRVUZEUkR0QlFVTkVMR2RDUVVGSlRTeFRRVUZUUXl4TlFVRlVMRXRCUVc5Q0xFZEJRWGhDTEVWQlFUWkNPMEZCUXpOQ1NpeHhRa0ZCVHl4SlFVRkpTeXhMUVVGS0xFTkJRVlVzTWtKQlFWWXNRMEZCVUR0QlFVTkVPMEZCUTBSR08wRkJRMGRITEdkQ1FVUklPMEZCUlVkS0xHZENRVVpJTEVOQlJWRXNhVUpCUVZNN1FVRkRZaXhyUWtGQlNVc3NTMEZCU2l4RlFVRlhPMEZCUTFRc2MwSkJRVXMxUWl4VFFVRk1MRWRCUVdsQ0xGbEJRVmswUWl4TFFVRTNRanRCUVVOQlVpeDNRa0ZCVVN4TlFVRkxjRUlzVTBGQllqdEJRVU5FTEdWQlNFUXNUVUZIVHp0QlFVTk1jVUlzZFVKQlFVOHNTVUZCU1Vzc1MwRkJTaXhEUVVGVkxESkNRVUZXTEVOQlFWQTdRVUZEUkR0QlFVTkdMR0ZCVkVnN1FVRlZSMGNzYVVKQlZrZ3NRMEZWVTFJc1RVRldWRHRCUVZkRUxGZEJNVUpFTEVOQlJHbENMRWRCUVZvc1EwRkJVRHM3UVVFMlFrUXNTenM3UVVGRlMxUXNWU3hGUVVGUlF5eEpMRVZCUVUxcFFpeEpMRVZCUVhkQ0xIVkNRVUZzUWtNc1YwRkJhMElzZFVWQlFVb3NSVUZCU1R0QlFVTXhReXhWUVVGTmFrSXNWVUZCVlZJc1QwRkJUekJDTEUxQlFWQTdRVUZEWkR0QlFVTkZReXhuUWtGQlVTeHJRa0ZFVmp0QlFVVkZMSGRDUVVGblFpeHJRa0ZHYkVJN1FVRkhSV3hDTEhWQ1FVRmxMRXRCUVV0bUxGTkJTSFJDTEVWQlJHTTdPMEZCVFdRclFpeHBRa0ZPWXl4RFFVRm9RanM3UVVGUlFTeFZRVUZKZUVNc1YwRkJTaXhGUVVGcFFqdEJRVU5tVnl4blFrRkJVV01zWTBGQlVpeFJRVUUwUWtvc1RVRkJOVUlzVTBGQmMwTkRMRWxCUVhSRExHTkJRWGRFY0VJc1dVRkJlRVE3UVVGRFFWTXNaMEpCUVZGbExFZEJRVklzUTBGQldTeFRRVUZhTEVWQlFYVkNUQ3hOUVVGMlFqdEJRVU5CVml4blFrRkJVV1VzUjBGQlVpeERRVUZaTEU5QlFWb3NSVUZCY1VKMFFpeFZRVUZWYTBJc1NVRkJMMEk3UVVGRFFWZ3NaMEpCUVZGbExFZEJRVklzUTBGQldTeFZRVUZhTEVWQlFYZENTQ3hQUVVGNFFqdEJRVU5CTEZsQlFVbG5RaXhKUVVGS0xFVkJRVlU3UVVGRFVqVkNMR3RDUVVGUlpTeEhRVUZTTEVOQlFWa3NUMEZCV2l4RlFVRnhRbUVzU1VGQmNrSTdRVUZEUkR0QlFVTkVOVUlzWjBKQlFWRm5RaXhSUVVGU08wRkJRMFE3UVVGRFJDeGhRVUZQTEVsQlFVbERMRTlCUVVvc1EwRkJXU3hWUVVGRFF5eFBRVUZFTEVWQlFWVkRMRTFCUVZZN1FVRkRha0lzSzBKQlFVMHhRaXhWUVVGVmEwSXNTVUZCYUVJc1JVRkJjMEk3UVVGRGNFSkVMREJDUVVSdlFqdEJRVVZ3UWtVc05FSkJSbTlDTzBGQlIzQkNPMEZCUTBGdlFpeHJRa0ZCVFVvc1NVRktZeXhGUVVGMFFqczdRVUZOUjFBc1kwRk9TQ3hEUVUxUkxHOUNRVUZaTzBGQlEyaENMR2RDUVVGSmFFTXNWMEZCU2l4RlFVRnBRanRCUVVObVZ5eHpRa0ZCVVdNc1kwRkJVanRCUVVOUFNpeHZRa0ZFVUN4VFFVTnBRa01zU1VGRWFrSTdRVUZGV1c1Q0xESkNRVVphT3p0QlFVbEJVU3h6UWtGQlVXZENMRkZCUVZJN1FVRkRSRHRCUVVORUxHZENRVUZKVFN4VFFVRlRReXhOUVVGVUxFdEJRVzlDTEVkQlFYaENMRVZCUVRaQ08wRkJRek5DVlN4eFFrRkJUME1zVVVGQlVDeERRVUZuUWtNc1VVRkJhRUlzUjBGQk1rSXNVMEZCTTBJN1FVRkRRV3BDTEhOQ1FVRlJPMEZCUTA1TExIZENRVUZSTEU5QlJFWTdRVUZGVG1Fc2VVSkJRVk1zTkVKQlJrZzdRVUZIVGtNc2MwSkJRVTFtTEZOQlFWTkRMRTFCU0ZRc1JVRkJVanM3UVVGTFJDeGhRVkJFTEUxQlQwOHNTVUZCU1VRc1UwRkJVME1zVFVGQlZDeExRVUZ2UWl4SFFVRjRRaXhGUVVFMlFqdEJRVU5zUTB3c2MwSkJRVkU3UVVGRFRrc3NkMEpCUVZFc1QwRkVSanRCUVVWT1lTeDVRa0ZCVXl3MFFrRkdTRHRCUVVkT1F5eHpRa0ZCVFdZc1UwRkJVME1zVFVGSVZDeEZRVUZTT3p0QlFVdEVMR0ZCVGswc1RVRk5RU3hKUVVGSlJDeFRRVUZUUXl4TlFVRlVMRWxCUVcxQ0xFZEJRVzVDTEVsQlFUQkNSQ3hUUVVGVFF5eE5RVUZVTEVkQlFXdENMRWRCUVdoRUxFVkJRWEZFTzBGQlF6RkVUQ3h6UWtGQlVUdEJRVU5PU3l4M1FrRkJVU3hQUVVSR08wRkJSVTVoTEhsQ1FVRlRMREJEUVVaSU8wRkJSMDVETEhOQ1FVRk5aaXhUUVVGVFF5eE5RVWhVTEVWQlFWSTdPMEZCUzBRc1lVRk9UU3hOUVUxQkxFbEJRVWxFTEZOQlFWTkRMRTFCUVZRc1NVRkJiVUlzUjBGQmRrSXNSVUZCTkVJN1FVRkRha05NTEhOQ1FVRlJPMEZCUTA1TExIZENRVUZSTEU5QlJFWTdRVUZGVG1FN1FVRkRSU3dyUlVGSVNUdEJRVWxPUXl4elFrRkJUV1lzVTBGQlUwTXNUVUZLVkN4RlFVRlNPenRCUVUxRUxHRkJVRTBzVFVGUFFUdEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJUQ3h6UWtGQlVUdEJRVU5PU3l4M1FrRkJVU3hKUVVSR08wRkJSVTVUTEhOQ1FVRk5WaXhUUVVGVFZTeEpRVVpVTEVWQlFWSTdPenRCUVV0Qk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRSRHRCUVVOR0xGZEJNVVJJTzBGQk1rUkhUQ3hsUVRORVNDeERRVEpFVXl4cFFrRkJVenRCUVVOa0xHZENRVUZOVnl4VFFVRlRPMEZCUTJKbUxITkNRVUZSTEU5QlJFczdRVUZGWW1Fc2RVSkJRVk1zZVVOQlJrazdRVUZIWWtjc2NVSkJRVTkwUXl4TFFVaE5MRVZCUVdZN08wRkJTMEVzYlVKQlFVdEdMRmxCUVV3c1EwRkJhMEoxUXl4TlFVRnNRanRCUVVOQmNFSXNiMEpCUVZGdlFpeE5RVUZTTzBGQlEwUXNWMEZ1UlVnc1EwRkVhVUlzUjBGQldpeERRVUZRT3p0QlFYTkZSQ3hMTERSRFFXaExhMEkxUXl4VElpd2labWxzWlNJNklrRndhVU5zYVdWdWRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSXZhRzl0WlM5emFHOTFkbWxyTDFCeWIycGxZM1J6TDJac2IzY3RkR1Z6ZENJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHZJRUJ0YjJSMWJHVmtiMk5jYmk4dlhHNHZMeUJVYUdseklHbHpJSFJvWlNCaVlYTmxJRUZRU1NCamJHbGxiblFzSUdsMElHRmpkSE1nWVhNZ1lTQmpiMjUwWVdsdVpYSWdabTl5SUVGMWRHaGxiblJwWTJGMGFXOXVMRnh1THk4Z1RHOW5hVzRzSUhWelpYSWdjMlYwZEdsdVozTXNJR0poYzJVZ1pXNWtjRzlwYm5SekxDQmxkR011WEc0dkx5QkpkQ0JwY3lCdFpXRnVkQ0IwYnlCaVpTQmxZWE41SUhSdklHMXZZMnN1WEc1Y2JtbHRjRzl5ZENCaGVHbHZjeUJtY205dElGd2lZWGhwYjNOY0lqdGNibHh1WTI5dWMzUWdiRzluVW1WeGRXVnpkSE1nUFNCMGVYQmxiMllnUkVWV0lDRTlQU0JjSW5WdVpHVm1hVzVsWkZ3aUlDWW1JRVJGVmp0Y2JtTnZibk4wSUhKbGNYVmxjM1JEYjJ4dmNpQTlJRndpUTI5eWJtWnNiM2RsY2tKc2RXVmNJanRjYm1OdmJuTjBJSEpsYzNCdmJuTmxRMjlzYjNJZ1BTQmNJa055YVcxemIyNWNJanRjYm1OdmJuTjBJRUZRU1Y5VlVrd2dQU0JjSW1oMGRIQTZMeTlzYjJOaGJHaHZjM1E2TXpBd01Gd2lPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JqYkdGemN5QkJjR2xEYkdsbGJuUWdlMXh1SUNCemRHRjBhV01nWTNKbFlYUmxWRzlyWlc0b2RYTmxjbTVoYldVc0lIQmhjM04zYjNKa0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUZ3aVFtRnphV01nWENJZ0t5QmlkRzloS0hWelpYSnVZVzFsSUNzZ1hDSTZYQ0lnS3lCd1lYTnpkMjl5WkNrN1hHNGdJSDFjYmx4dUlDQmpiMjV6ZEhKMVkzUnZjaWhoZFhSb1ZHOXJaVzRzSUdWeWNtOXlTR0Z1Wkd4bGNpQTlJR052Ym5OdmJHVXVaWEp5YjNJdVltbHVaQ2hqYjI1emIyeGxLU2tnZTF4dUlDQWdJSFJvYVhNdVlYVjBhRlJ2YTJWdUlEMGdZWFYwYUZSdmEyVnVPMXh1SUNBZ0lIUm9hWE11WlhKeWIzSklZVzVrYkdWeUlEMGdaWEp5YjNKSVlXNWtiR1Z5TzF4dUlDQjlYRzVjYmlBZ1pXNWpiMlJsVVhWbGNubFFZWEpoYldWMFpYSnpLSEJoY21GdFpYUmxjbk1wSUh0Y2JpQWdJQ0JwWmlBb2NHRnlZVzFsZEdWeWN5a2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlDaGNiaUFnSUNBZ0lDQWdYQ0kvWENJZ0sxeHVJQ0FnSUNBZ0lDQlBZbXBsWTNRdWEyVjVjeWh3WVhKaGJXVjBaWEp6S1Z4dUlDQWdJQ0FnSUNBZ0lDNXRZWEFvWEc0Z0lDQWdJQ0FnSUNBZ0lDQnJaWGtnUFQ1Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWUNSN1pXNWpiMlJsVlZKSlEyOXRjRzl1Wlc1MEtHdGxlU2w5UFNSN1pXNWpiMlJsVlZKSlEyOXRjRzl1Wlc1MEtGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIQmhjbUZ0WlhSbGNuTmJhMlY1WFZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FwZldCY2JpQWdJQ0FnSUNBZ0lDQXBYRzRnSUNBZ0lDQWdJQ0FnTG1wdmFXNG9YQ0ltWENJcFhHNGdJQ0FnSUNBcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdYQ0pjSWp0Y2JpQWdmVnh1WEc0Z0lISmxjWFZsYzNSS1YxUW9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2JXVjBhRzlrSUQwZ1hDSkhSVlJjSWp0Y2JpQWdJQ0JqYjI1emRDQndZWFJvSUQwZ1hDSXZkakl2ZEc5clpXNWNJanRjYmlBZ0lDQmpiMjV6ZENCb1pXRmtaWEp6SUQwZ2UxeHVJQ0FnSUNBZ1FYVjBhRzl5YVhwaGRHbHZiam9nZEdocGN5NWhkWFJvVkc5clpXNWNiaUFnSUNCOU8xeHVJQ0FnSUdsbUlDaHNiMmRTWlhGMVpYTjBjeWtnZTF4dUlDQWdJQ0FnWTI5dWMyOXNaUzVuY205MWNFTnZiR3hoY0hObFpDaGdKV01rZTIxbGRHaHZaSDBnSkh0d1lYUm9mV0FzSUdCamIyeHZjam9nSkh0eVpYRjFaWE4wUTI5c2IzSjlZQ2s3WEc0Z0lDQWdJQ0JqYjI1emIyeGxMbXh2WnloY0ltMWxkR2h2WkRwY0lpd2diV1YwYUc5a0tUdGNiaUFnSUNBZ0lHTnZibk52YkdVdWJHOW5LRndpY0dGMGFEcGNJaXdnUVZCSlgxVlNUQ0FySUhCaGRHZ3BPMXh1SUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKb1pXRmtaWEp6T2x3aUxDQm9aV0ZrWlhKektUdGNiaUFnSUNBZ0lHTnZibk52YkdVdVozSnZkWEJGYm1Rb0tUdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0NoeVpYTnZiSFpsTENCeVpXcGxZM1FwSUQwK1hHNGdJQ0FnSUNCaGVHbHZjeWhCVUVsZlZWSk1JQ3NnY0dGMGFDd2dlMXh1SUNBZ0lDQWdJQ0J0WlhSb2IyUXNYRzRnSUNBZ0lDQWdJR2hsWVdSbGNuTXNYRzRnSUNBZ0lDQWdJRzF2WkdVNklGd2lZMjl5YzF3aVhHNGdJQ0FnSUNCOUtTNTBhR1Z1S0hKbGMzQnZibk5sSUQwK0lIdGNiaUFnSUNBZ0lDQWdhV1lnS0d4dloxSmxjWFZsYzNSektTQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVuY205MWNFTnZiR3hoY0hObFpDaGNiaUFnSUNBZ0lDQWdJQ0FnSUdBbFl5UjdiV1YwYUc5a2ZTQWtlM0JoZEdoOVlDeGNiaUFnSUNBZ0lDQWdJQ0FnSUdCamIyeHZjam9nSkh0eVpYTndiMjV6WlVOdmJHOXlmV0JjYmlBZ0lDQWdJQ0FnSUNBcE8xeHVJQ0FnSUNBZ0lDQWdJR052Ym5OdmJHVXVaM0p2ZFhCRmJtUW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCcFppQW9jbVZ6Y0c5dWMyVXVjM1JoZEhWeklEMDlQU0EwTURFcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WldwbFkzUW9ibVYzSUVWeWNtOXlLRndpU1c1MllXeHBaQ0JsYldGcGJDQnZjaUJ3WVhOemQyOXlaRndpS1NrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdjbVZ6Y0c5dWMyVmNiaUFnSUNBZ0lDQWdJQ0F1ZEdWNGRDZ3BYRzRnSUNBZ0lDQWdJQ0FnTG5Sb1pXNG9kRzlyWlc0Z1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSFJ2YTJWdUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WVhWMGFGUnZhMlZ1SUQwZ1hDSkNaV0Z5WlhJZ1hDSWdLeUIwYjJ0bGJqdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpiMngyWlNoMGFHbHpMbUYxZEdoVWIydGxiaWs3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpXcGxZM1FvYm1WM0lFVnljbTl5S0Z3aVZHaGxJSE5sY25abGNpQmthV1FnYm05MElITmxibVFnWVZ3aUtTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdmU2xjYmlBZ0lDQWdJQ0FnSUNBdVkyRjBZMmdvY21WcVpXTjBLVHRjYmlBZ0lDQWdJSDBwWEc0Z0lDQWdLVHRjYmlBZ2ZWeHVYRzRnSUdabGRHTm9LRzFsZEdodlpDd2djR0YwYUN3Z1ltOWtlU3dnZFhObGNraGxZV1JsY25NZ1BTQjdmU2tnZTF4dUlDQWdJR052Ym5OMElHaGxZV1JsY25NZ1BTQlBZbXBsWTNRdVlYTnphV2R1S0Z4dUlDQWdJQ0FnZTF4dUlDQWdJQ0FnSUNCQlkyTmxjSFE2SUZ3aVlYQndiR2xqWVhScGIyNHZhbk52Ymx3aUxGeHVJQ0FnSUNBZ0lDQmNJa052Ym5SbGJuUXRWSGx3WlZ3aU9pQmNJbUZ3Y0d4cFkyRjBhVzl1TDJwemIyNWNJaXhjYmlBZ0lDQWdJQ0FnUVhWMGFHOXlhWHBoZEdsdmJqb2dkR2hwY3k1aGRYUm9WRzlyWlc1Y2JpQWdJQ0FnSUgwc1hHNGdJQ0FnSUNCMWMyVnlTR1ZoWkdWeWMxeHVJQ0FnSUNrN1hHNGdJQ0FnYVdZZ0tHeHZaMUpsY1hWbGMzUnpLU0I3WEc0Z0lDQWdJQ0JqYjI1emIyeGxMbWR5YjNWd1EyOXNiR0Z3YzJWa0tHQWxZeVI3YldWMGFHOWtmU0FrZTNCaGRHaDlZQ3dnWUdOdmJHOXlPaUFrZTNKbGNYVmxjM1JEYjJ4dmNuMWdLVHRjYmlBZ0lDQWdJR052Ym5OdmJHVXViRzluS0Z3aWJXVjBhRzlrT2x3aUxDQnRaWFJvYjJRcE8xeHVJQ0FnSUNBZ1kyOXVjMjlzWlM1c2IyY29YQ0p3WVhSb09sd2lMQ0JCVUVsZlZWSk1JQ3NnY0dGMGFDazdYRzRnSUNBZ0lDQmpiMjV6YjJ4bExteHZaeWhjSW1obFlXUmxjbk02WENJc0lHaGxZV1JsY25NcE8xeHVJQ0FnSUNBZ2FXWWdLR0p2WkhrcElIdGNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvWENKaWIyUjVPbHdpTENCaWIyUjVLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR052Ym5OdmJHVXVaM0p2ZFhCRmJtUW9LVHRjYmlBZ0lDQjlYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlFjbTl0YVhObEtDaHlaWE52YkhabExDQnlaV3BsWTNRcElEMCtYRzRnSUNBZ0lDQmhlR2x2Y3loQlVFbGZWVkpNSUNzZ2NHRjBhQ3dnZTF4dUlDQWdJQ0FnSUNCdFpYUm9iMlFzWEc0Z0lDQWdJQ0FnSUdobFlXUmxjbk1zWEc0Z0lDQWdJQ0FnSUM4dklHMXZaR1U2SUZ3aVkyOXljMXdpTEZ4dUlDQWdJQ0FnSUNCa1lYUmhPaUJpYjJSNVhHNGdJQ0FnSUNCOUtWeHVJQ0FnSUNBZ0lDQXVkR2hsYmloeVpYTndiMjV6WlNBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHeHZaMUpsY1hWbGMzUnpLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtZHliM1Z3UTI5c2JHRndjMlZrS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JnSldNa2UyMWxkR2h2WkgwZ0pIdHdZWFJvZldBc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUdCamIyeHZjam9nSkh0eVpYTndiMjV6WlVOdmJHOXlmV0JjYmlBZ0lDQWdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpiMnhsTG1keWIzVndSVzVrS0NrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHlaWE53YjI1elpTNXpkR0YwZFhNZ1BUMDlJRFF3TVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZDJsdVpHOTNMbXh2WTJGMGFXOXVMbkJoZEdodVlXMWxJRDBnWENJdmJHOW5iM1YwWENJN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjM1JoZEhWek9pQmNJbVZ5Y205eVhDSXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVNklGd2lTVzV6ZFdabWFXTnBaVzUwSUdGalkyVnpjeUJ5YVdkb2RITmNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlRvZ2NtVnpjRzl1YzJVdWMzUmhkSFZ6WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tISmxjM0J2Ym5ObExuTjBZWFIxY3lBOVBUMGdOREF6S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhOdmJIWmxLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjM1JoZEhWek9pQmNJbVZ5Y205eVhDSXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHMWxjM05oWjJVNklGd2lTVzV6ZFdabWFXTnBaVzUwSUdGalkyVnpjeUJ5YVdkb2RITmNJaXhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdZMjlrWlRvZ2NtVnpjRzl1YzJVdWMzUmhkSFZ6WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tISmxjM0J2Ym5ObExuTjBZWFIxY3lBK1BTQTBNREFnSmlZZ2NtVnpjRzl1YzJVdWMzUmhkSFZ6SUR3Z05UQXdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE52YkhabEtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2MzUmhkSFZ6T2lCY0ltVnljbTl5WENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUcxbGMzTmhaMlU2SUZ3aVEyeHBaVzUwSUdWeWNtOXlPaUJVY25rZ2NtVm1jbVZ6YUdsdVp5QjBhR1VnWW5KdmQzTmxjbHdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjJSbE9pQnlaWE53YjI1elpTNXpkR0YwZFhOY2JpQWdJQ0FnSUNBZ0lDQWdJSDBwTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9jbVZ6Y0c5dWMyVXVjM1JoZEhWeklENDlJRFV3TUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemIyeDJaU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSE4wWVhSMWN6b2dYQ0psY25KdmNsd2lMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnRaWE56WVdkbE9seHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lGd2lVMlZ5ZG1WeUlHVnljbTl5T2lCMGNua2djbVZtY21WemFHbHVaeUIwYUdVZ1luSnZkM05sY2l3Z2IzSWdkSEo1SUdGbllXbHVJR3hoZEdWeUxsd2lMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMlJsT2lCeVpYTndiMjV6WlM1emRHRjBkWE5jYmlBZ0lDQWdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJ5WlhOd2IyNXpaVnh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdJQ0F1YW5OdmJpZ3BYRzRnSUNBZ0lDQWdJQ0FnSUNBdkx5QWdJQzUwYUdWdUtHcHpiMjRnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WemIyeDJaU2g3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSE4wWVhSMWN6b2dYQ0p2YTF3aUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhPaUJ5WlhOd2IyNXpaUzVrWVhSaFhHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2JseHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z0lDQXVZMkYwWTJnb0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnSUNBZ0lDOHZJRk5sY25abGNpQnpaVzUwSUc1dklISmxjM0J2Ym5ObExDQjNhR2xqYUNCcGN5QnZheUJwYmlCdGIzTjBJR05oYzJWekxpQk9iM1FnWVd4c1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlBZ0lDQWdMeThnY21WeGRXVnpkSE1nZDJsc2JDQm5aWFFnWVNCeVpYTndiMjV6WlNBb1JFVk1SVlJGSUdadmNpQmxlR0Z0Y0d4bEtTNWNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklDQWdJQ0J5WlhOdmJIWmxLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJQ0FnSUNBZ0lITjBZWFIxY3pvZ1hDSnZhMXdpTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnSUNBZ0lDQWdaR0YwWVRvZ2JuVnNiRnh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z0lDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMHBYRzRnSUNBZ0lDQWdJQzVqWVhSamFDaGxjbkp2Y2lBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdjbVZ6ZFd4MElEMGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2MzUmhkSFZ6T2lCY0ltVnljbTl5WENJc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J0WlhOellXZGxPaUJjSWtGdUlHVnljbTl5SUc5alkzVnlaV1FnZEdGc2EybHVaeUIwYnlCMGFHVWdjMlZ5ZG1WeUxsd2lMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRjFjMlU2SUdWeWNtOXlYRzRnSUNBZ0lDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TG1WeWNtOXlTR0Z1Wkd4bGNpaHlaWE4xYkhRcE8xeHVJQ0FnSUNBZ0lDQWdJSEpsYzI5c2RtVW9jbVZ6ZFd4MEtUdGNiaUFnSUNBZ0lDQWdmU2xjYmlBZ0lDQXBPMXh1SUNCOVhHNTlYRzRpWFgwPVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0FwaUNsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(17);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanM/OWFkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar bind = __webpack_require__(3);\nvar Axios = __webpack_require__(19);\nvar defaults = __webpack_require__(1);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(13);\naxios.CancelToken = __webpack_require__(45);\naxios.isCancel = __webpack_require__(12);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(46);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP2I0ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzPzQ1ZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaults = __webpack_require__(1);\nvar utils = __webpack_require__(0);\nvar InterceptorManager = __webpack_require__(40);\nvar dispatchRequest = __webpack_require__(41);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanM/NWU2NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0NBQWtDLGNBQWM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHttZXRob2Q6ICdnZXQnfSwgdGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz9lNTU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar settle = __webpack_require__(4);\nvar buildURL = __webpack_require__(6);\nvar parseHeaders = __webpack_require__(22);\nvar isURLSameOrigin = __webpack_require__(23);\nvar createError = __webpack_require__(2);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(24);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(25);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz9lYzZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnRvYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbiAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcbiAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgIC8vIERPTidUIGRvIHRoaXMgZm9yIHRlc3RpbmcgYi9jIFhNTEh0dHBSZXF1ZXN0IGlzIG1vY2tlZCwgbm90IFhEb21haW5SZXF1ZXN0LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcbiAgICAgIHhEb21haW4gPSB0cnVlO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MoKSB7fTtcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2EwOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzPzE4NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcz9iNjEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz9hNzU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsT0FBTzs7QUFFUDtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkJBQTZCLGFBQWEsRUFBRTtBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar settle = __webpack_require__(4);\nvar buildURL = __webpack_require__(6);\nvar http = __webpack_require__(7);\nvar https = __webpack_require__(8);\nvar httpFollow = __webpack_require__(9).http;\nvar httpsFollow = __webpack_require__(9).https;\nvar url = __webpack_require__(10);\nvar zlib = __webpack_require__(38);\nvar pkg = __webpack_require__(39);\nvar createError = __webpack_require__(2);\nvar enhanceError = __webpack_require__(5);\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolve, reject) {\n    var data = config.data;\n    var headers = config.headers;\n    var timer;\n\n    // Set User-Agent (required by some servers)\n    // Only set header if it hasn't been set in config\n    // See https://github.com/axios/axios/issues/69\n    if (!headers['User-Agent'] && !headers['user-agent']) {\n      headers['User-Agent'] = 'axios/' + pkg.version;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = new Buffer(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = new Buffer(data, 'utf-8');\n      } else {\n        return reject(createError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers['Content-Length'] = data.length;\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var parsed = url.parse(config.url);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth) {\n      delete headers.Authorization;\n    }\n\n    var isHttps = protocol === 'https:';\n    var agent = isHttps ? config.httpsAgent : config.httpAgent;\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method,\n      headers: headers,\n      agent: agent,\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        proxy = {\n          host: parsedProxyUrl.hostname,\n          port: parsedProxyUrl.port\n        };\n\n        if (parsedProxyUrl.auth) {\n          var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n          proxy.auth = {\n            username: proxyUrlAuth[0],\n            password: proxyUrlAuth[1]\n          };\n        }\n      }\n    }\n\n    if (proxy) {\n      options.hostname = proxy.host;\n      options.host = proxy.host;\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      options.port = proxy.port;\n      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;\n\n      // Basic proxy authorization\n      if (proxy.auth) {\n        var base64 = new Buffer(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n        options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n      }\n    }\n\n    var transport;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttps ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      transport = isHttps ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxContentLength && config.maxContentLength > -1) {\n      options.maxBodyLength = config.maxContentLength;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // Response has been received so kill timer that handles request timeout\n      clearTimeout(timer);\n      timer = null;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n      switch (res.headers['content-encoding']) {\n      /*eslint default-case:0*/\n      case 'gzip':\n      case 'compress':\n      case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n        stream = stream.pipe(zlib.createUnzip());\n\n        // remove the content-encoding in order to not confuse downstream operations\n        delete res.headers['content-encoding'];\n        break;\n      }\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              config, null, lastRequest));\n          }\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          var responseData = Buffer.concat(responseBuffer);\n          if (config.responseType !== 'arraybuffer') {\n            responseData = responseData.toString('utf8');\n          }\n\n          response.data = responseData;\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted) return;\n      reject(enhanceError(err, config, null, req));\n    });\n\n    // Handle request timeout\n    if (config.timeout && !timer) {\n      timer = setTimeout(function handleRequestTimeout() {\n        req.abort();\n        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));\n      }, config.timeout);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(cancel);\n      });\n    }\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2h0dHAuanM/MTgyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgaHR0cEZvbGxvdyA9IHJlcXVpcmUoJ2ZvbGxvdy1yZWRpcmVjdHMnKS5odHRwO1xudmFyIGh0dHBzRm9sbG93ID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpLmh0dHBzO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG52YXIgcGtnID0gcmVxdWlyZSgnLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2VuaGFuY2VFcnJvcicpO1xuXG4vKmVzbGludCBjb25zaXN0ZW50LXJldHVybjowKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cEFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaEh0dHBSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBkYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIGhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcbiAgICB2YXIgdGltZXI7XG5cbiAgICAvLyBTZXQgVXNlci1BZ2VudCAocmVxdWlyZWQgYnkgc29tZSBzZXJ2ZXJzKVxuICAgIC8vIE9ubHkgc2V0IGhlYWRlciBpZiBpdCBoYXNuJ3QgYmVlbiBzZXQgaW4gY29uZmlnXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvNjlcbiAgICBpZiAoIWhlYWRlcnNbJ1VzZXItQWdlbnQnXSAmJiAhaGVhZGVyc1sndXNlci1hZ2VudCddKSB7XG4gICAgICBoZWFkZXJzWydVc2VyLUFnZW50J10gPSAnYXhpb3MvJyArIHBrZy52ZXJzaW9uO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmICF1dGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLi4uXG4gICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCAndXRmLTgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgICAgJ0RhdGEgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIGEgQnVmZmVyLCBvciBhIFN0cmVhbScsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgQ29udGVudC1MZW5ndGggaGVhZGVyIGlmIGRhdGEgZXhpc3RzXG4gICAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gZGF0YS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIHZhciBhdXRoID0gdW5kZWZpbmVkO1xuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIGF1dGggPSB1c2VybmFtZSArICc6JyArIHBhc3N3b3JkO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHVybFxuICAgIHZhciBwYXJzZWQgPSB1cmwucGFyc2UoY29uZmlnLnVybCk7XG4gICAgdmFyIHByb3RvY29sID0gcGFyc2VkLnByb3RvY29sIHx8ICdodHRwOic7XG5cbiAgICBpZiAoIWF1dGggJiYgcGFyc2VkLmF1dGgpIHtcbiAgICAgIHZhciB1cmxBdXRoID0gcGFyc2VkLmF1dGguc3BsaXQoJzonKTtcbiAgICAgIHZhciB1cmxVc2VybmFtZSA9IHVybEF1dGhbMF0gfHwgJyc7XG4gICAgICB2YXIgdXJsUGFzc3dvcmQgPSB1cmxBdXRoWzFdIHx8ICcnO1xuICAgICAgYXV0aCA9IHVybFVzZXJuYW1lICsgJzonICsgdXJsUGFzc3dvcmQ7XG4gICAgfVxuXG4gICAgaWYgKGF1dGgpIHtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgfVxuXG4gICAgdmFyIGlzSHR0cHMgPSBwcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgdmFyIGFnZW50ID0gaXNIdHRwcyA/IGNvbmZpZy5odHRwc0FnZW50IDogY29uZmlnLmh0dHBBZ2VudDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcGF0aDogYnVpbGRVUkwocGFyc2VkLnBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpLFxuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGFnZW50OiBhZ2VudCxcbiAgICAgIGF1dGg6IGF1dGhcbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5zb2NrZXRQYXRoKSB7XG4gICAgICBvcHRpb25zLnNvY2tldFBhdGggPSBjb25maWcuc29ja2V0UGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlZC5wb3J0O1xuICAgIH1cblxuICAgIHZhciBwcm94eSA9IGNvbmZpZy5wcm94eTtcbiAgICBpZiAoIXByb3h5ICYmIHByb3h5ICE9PSBmYWxzZSkge1xuICAgICAgdmFyIHByb3h5RW52ID0gcHJvdG9jb2wuc2xpY2UoMCwgLTEpICsgJ19wcm94eSc7XG4gICAgICB2YXIgcHJveHlVcmwgPSBwcm9jZXNzLmVudltwcm94eUVudl0gfHwgcHJvY2Vzcy5lbnZbcHJveHlFbnYudG9VcHBlckNhc2UoKV07XG4gICAgICBpZiAocHJveHlVcmwpIHtcbiAgICAgICAgdmFyIHBhcnNlZFByb3h5VXJsID0gdXJsLnBhcnNlKHByb3h5VXJsKTtcbiAgICAgICAgcHJveHkgPSB7XG4gICAgICAgICAgaG9zdDogcGFyc2VkUHJveHlVcmwuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogcGFyc2VkUHJveHlVcmwucG9ydFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJzZWRQcm94eVVybC5hdXRoKSB7XG4gICAgICAgICAgdmFyIHByb3h5VXJsQXV0aCA9IHBhcnNlZFByb3h5VXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICAgICAgICBwcm94eS5hdXRoID0ge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHByb3h5VXJsQXV0aFswXSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwcm94eVVybEF1dGhbMV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3h5KSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gcHJveHkuaG9zdDtcbiAgICAgIG9wdGlvbnMuaG9zdCA9IHByb3h5Lmhvc3Q7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuaG9zdCA9IHBhcnNlZC5ob3N0bmFtZSArIChwYXJzZWQucG9ydCA/ICc6JyArIHBhcnNlZC5wb3J0IDogJycpO1xuICAgICAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgICAgIG9wdGlvbnMucGF0aCA9IHByb3RvY29sICsgJy8vJyArIHBhcnNlZC5ob3N0bmFtZSArIChwYXJzZWQucG9ydCA/ICc6JyArIHBhcnNlZC5wb3J0IDogJycpICsgb3B0aW9ucy5wYXRoO1xuXG4gICAgICAvLyBCYXNpYyBwcm94eSBhdXRob3JpemF0aW9uXG4gICAgICBpZiAocHJveHkuYXV0aCkge1xuICAgICAgICB2YXIgYmFzZTY0ID0gbmV3IEJ1ZmZlcihwcm94eS5hdXRoLnVzZXJuYW1lICsgJzonICsgcHJveHkuYXV0aC5wYXNzd29yZCwgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgKyBiYXNlNjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICBpZiAoY29uZmlnLnRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0ID0gY29uZmlnLnRyYW5zcG9ydDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5tYXhSZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHMgPyBodHRwcyA6IGh0dHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb25maWcubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gY29uZmlnLm1heFJlZGlyZWN0cztcbiAgICAgIH1cbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHMgPyBodHRwc0ZvbGxvdyA6IGh0dHBGb2xsb3c7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoICYmIGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEpIHtcbiAgICAgIG9wdGlvbnMubWF4Qm9keUxlbmd0aCA9IGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgIHZhciByZXEgPSB0cmFuc3BvcnQucmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXMpIHtcbiAgICAgIGlmIChyZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBSZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBzbyBraWxsIHRpbWVyIHRoYXQgaGFuZGxlcyByZXF1ZXN0IHRpbWVvdXRcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG5cbiAgICAgIC8vIHVuY29tcHJlc3MgdGhlIHJlc3BvbnNlIGJvZHkgdHJhbnNwYXJlbnRseSBpZiByZXF1aXJlZFxuICAgICAgdmFyIHN0cmVhbSA9IHJlcztcbiAgICAgIHN3aXRjaCAocmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkge1xuICAgICAgLyplc2xpbnQgZGVmYXVsdC1jYXNlOjAqL1xuICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICBjYXNlICdjb21wcmVzcyc6XG4gICAgICBjYXNlICdkZWZsYXRlJzpcbiAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudC1lbmNvZGluZyBpbiBvcmRlciB0byBub3QgY29uZnVzZSBkb3duc3RyZWFtIG9wZXJhdGlvbnNcbiAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gdGhlIGxhc3QgcmVxdWVzdCBpbiBjYXNlIG9mIHJlZGlyZWN0c1xuICAgICAgdmFyIGxhc3RSZXF1ZXN0ID0gcmVzLnJlcSB8fCByZXE7XG5cbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c01lc3NhZ2UsXG4gICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogbGFzdFJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICByZXNwb25zZS5kYXRhID0gc3RyZWFtO1xuICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzcG9uc2VCdWZmZXIgPSBbXTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRGF0YShjaHVuaykge1xuICAgICAgICAgIHJlc3BvbnNlQnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb250ZW50IGxlbmd0aCBpcyBub3Qgb3ZlciB0aGUgbWF4Q29udGVudExlbmd0aCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICBpZiAoY29uZmlnLm1heENvbnRlbnRMZW5ndGggPiAtMSAmJiBCdWZmZXIuY29uY2F0KHJlc3BvbnNlQnVmZmVyKS5sZW5ndGggPiBjb25maWcubWF4Q29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdtYXhDb250ZW50TGVuZ3RoIHNpemUgb2YgJyArIGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoICsgJyBleGNlZWRlZCcsXG4gICAgICAgICAgICAgIGNvbmZpZywgbnVsbCwgbGFzdFJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiBoYW5kbGVTdHJlYW1FcnJvcihlcnIpIHtcbiAgICAgICAgICBpZiAocmVxLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICByZWplY3QoZW5oYW5jZUVycm9yKGVyciwgY29uZmlnLCBudWxsLCBsYXN0UmVxdWVzdCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVuZCgpIHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2VEYXRhID0gQnVmZmVyLmNvbmNhdChyZXNwb25zZUJ1ZmZlcik7XG4gICAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlRGF0YS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZURhdGE7XG4gICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycikge1xuICAgICAgaWYgKHJlcS5hYm9ydGVkKSByZXR1cm47XG4gICAgICByZWplY3QoZW5oYW5jZUVycm9yKGVyciwgY29uZmlnLCBudWxsLCByZXEpKTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZXF1ZXN0IHRpbWVvdXRcbiAgICBpZiAoY29uZmlnLnRpbWVvdXQgJiYgIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxKSk7XG4gICAgICB9LCBjb25maWcudGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAocmVxLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgaWYgKHV0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICBkYXRhLnBpcGUocmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLmVuZChkYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9odHRwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIj8xZTQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYXNzZXJ0XCJcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIj9jOTNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwic3RyZWFtXCJcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = __webpack_require__(30);\n} else {\n  module.exports = __webpack_require__(32);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzPzljYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(11);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/YzNmOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZvbGxvdy1yZWRpcmVjdHMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MTFhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(33);\nvar util = __webpack_require__(34);\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(11);\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = __webpack_require__(35);\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/ZDlhYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25ELHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWyA2LCAyLCAzLCA0LCA1LCAxIF07XG5cbnRyeSB7XG4gIHZhciBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcbiAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgc3VwcG9ydHNDb2xvci5sZXZlbCA+PSAyKSB7XG4gICAgZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAyMCwgMjEsIDI2LCAyNywgMzIsIDMzLCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDU2LCA1NywgNjIsIDYzLCA2OCxcbiAgICAgIDY5LCA3NCwgNzUsIDc2LCA3NywgNzgsIDc5LCA4MCwgODEsIDkyLCA5MywgOTgsIDk5LCAxMTIsIDExMywgMTI4LCAxMjksIDEzNCxcbiAgICAgIDEzNSwgMTQ4LCAxNDksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsXG4gICAgICAxNzIsIDE3MywgMTc4LCAxNzksIDE4NCwgMTg1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LFxuICAgICAgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxNCwgMjE1LCAyMjAsIDIyMVxuICAgIF07XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICAvLyBzd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBjYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5XG4gICAgLnN1YnN0cmluZyg2KVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7IHJldHVybiBrLnRvVXBwZXJDYXNlKCkgfSk7XG5cbiAgLy8gY29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSB0cnVlO1xuICBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gZmFsc2U7XG4gIGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB2YWwgPSBudWxsO1xuICBlbHNlIHZhbCA9IE51bWJlcih2YWwpO1xuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0c1xuICAgID8gQm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycylcbiAgICA6IHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuICAgIC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKClcbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgaWYgKHVzZUNvbG9ycykge1xuICAgIHZhciBjID0gdGhpcy5jb2xvcjtcbiAgICB2YXIgY29sb3JDb2RlID0gJ1xcdTAwMWJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG4gICAgdmFyIHByZWZpeCA9ICcgICcgKyBjb2xvckNvZGUgKyAnOzFtJyArIG5hbWUgKyAnICcgKyAnXFx1MDAxYlswbSc7XG5cbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxYlswbScpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuICBpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0IChkZWJ1Zykge1xuICBkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgcHJvY2Vzcy5lbnYuREVCVUdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

eval("module.exports = require(\"tty\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0dHlcIj9iZjFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHR5XCJcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCI/NzBjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst os = __webpack_require__(36);\nconst hasFlag = __webpack_require__(37);\n\nconst env = process.env;\n\nconst support = level => {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n};\n\nlet supportLevel = (() => {\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn 1;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn 0;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Hyper':\n\t\t\t\treturn 3;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n})();\n\nif ('FORCE_COLOR' in env) {\n\tsupportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : (supportLevel || 1);\n}\n\nmodule.exports = process && support(supportLevel);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanM/MTI1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgaGFzRmxhZyA9IHJlcXVpcmUoJ2hhcy1mbGFnJyk7XG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52O1xuXG5jb25zdCBzdXBwb3J0ID0gbGV2ZWwgPT4ge1xuXHRpZiAobGV2ZWwgPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn07XG5cbmxldCBzdXBwb3J0TGV2ZWwgPSAoKCkgPT4ge1xuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5zdGRvdXQgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIE5vZGUuanMgNy41LjAgaXMgdGhlIGZpcnN0IHZlcnNpb24gb2YgTm9kZS5qcyB0byBpbmNsdWRlIGEgcGF0Y2ggdG9cblx0XHQvLyBsaWJ1diB0aGF0IGVuYWJsZXMgMjU2IGNvbG9yIG91dHB1dCBvbiBXaW5kb3dzLiBBbnl0aGluZyBlYXJsaWVyIGFuZCBpdFxuXHRcdC8vIHdvbid0IHdvcmsuIEhvd2V2ZXIsIGhlcmUgd2UgdGFyZ2V0IE5vZGUuanMgOCBhdCBtaW5pbXVtIGFzIGl0IGlzIGFuIExUU1xuXHRcdC8vIHJlbGVhc2UsIGFuZCBOb2RlLmpzIDcgaXMgbm90LiBXaW5kb3dzIDEwIGJ1aWxkIDEwNTg2IGlzIHRoZSBmaXJzdCBXaW5kb3dzXG5cdFx0Ly8gcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpWzBdKSA+PSA4ICYmXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODZcblx0XHQpIHtcblx0XHRcdHJldHVybiAyO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gZW52KSB7XG5cdFx0aWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSSddLnNvbWUoc2lnbiA9PiBzaWduIGluIGVudikgfHwgZW52LkNJX05BTUUgPT09ICdjb2Rlc2hpcCcpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52LlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnSHlwZXInOlxuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdGNhc2UgJ0FwcGxlX1Rlcm1pbmFsJzpcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHQvLyBObyBkZWZhdWx0XG5cdFx0fVxuXHR9XG5cblx0aWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmIChlbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRyZXR1cm4gMDtcbn0pKCk7XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRzdXBwb3J0TGV2ZWwgPSBwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSA9PT0gMCA/IDAgOiAoc3VwcG9ydExldmVsIHx8IDEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MgJiYgc3VwcG9ydChzdXBwb3J0TGV2ZWwpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiPzQ5YmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIm9zXCJcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (flag, argv) {\n\targv = argv || process.argv;\n\n\tvar terminatorPos = argv.indexOf('--');\n\tvar prefix = /^-{1,2}/.test(flag) ? '' : '--';\n\tvar pos = argv.indexOf(prefix + flag);\n\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanM/MmFhZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsSUFBSTtBQUN0Qjs7QUFFQTtBQUNBIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmxhZywgYXJndikge1xuXHRhcmd2ID0gYXJndiB8fCBwcm9jZXNzLmFyZ3Y7XG5cblx0dmFyIHRlcm1pbmF0b3JQb3MgPSBhcmd2LmluZGV4T2YoJy0tJyk7XG5cdHZhciBwcmVmaXggPSAvXi17MSwyfS8udGVzdChmbGFnKSA/ICcnIDogJy0tJztcblx0dmFyIHBvcyA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcblxuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvclBvcyA9PT0gLTEgPyB0cnVlIDogcG9zIDwgdGVybWluYXRvclBvcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCI/MzdiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ6bGliXCJcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

eval("module.exports = {\"name\":\"axios\",\"version\":\"0.18.0\",\"description\":\"Promise based HTTP client for the browser and node.js\",\"main\":\"index.js\",\"scripts\":{\"test\":\"grunt test && bundlesize\",\"start\":\"node ./sandbox/server.js\",\"build\":\"NODE_ENV=production grunt build\",\"preversion\":\"npm test\",\"version\":\"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\",\"postversion\":\"git push && git push --tags\",\"examples\":\"node ./examples/server.js\",\"coveralls\":\"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/axios/axios.git\"},\"keywords\":[\"xhr\",\"http\",\"ajax\",\"promise\",\"node\"],\"author\":\"Matt Zabriskie\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/axios/axios/issues\"},\"homepage\":\"https://github.com/axios/axios\",\"devDependencies\":{\"bundlesize\":\"^0.5.7\",\"coveralls\":\"^2.11.9\",\"es6-promise\":\"^4.0.5\",\"grunt\":\"^1.0.1\",\"grunt-banner\":\"^0.6.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-clean\":\"^1.0.0\",\"grunt-contrib-nodeunit\":\"^1.0.0\",\"grunt-contrib-watch\":\"^1.0.0\",\"grunt-eslint\":\"^19.0.0\",\"grunt-karma\":\"^2.0.0\",\"grunt-ts\":\"^6.0.0-beta.3\",\"grunt-webpack\":\"^1.0.18\",\"istanbul-instrumenter-loader\":\"^1.0.0\",\"jasmine-core\":\"^2.4.1\",\"karma\":\"^1.3.0\",\"karma-chrome-launcher\":\"^2.0.0\",\"karma-coverage\":\"^1.0.0\",\"karma-firefox-launcher\":\"^1.0.0\",\"karma-jasmine\":\"^1.0.2\",\"karma-jasmine-ajax\":\"^0.1.13\",\"karma-opera-launcher\":\"^1.0.0\",\"karma-safari-launcher\":\"^1.0.0\",\"karma-sauce-launcher\":\"^1.1.0\",\"karma-sinon\":\"^1.0.5\",\"karma-sourcemap-loader\":\"^0.3.7\",\"karma-webpack\":\"^1.7.0\",\"load-grunt-tasks\":\"^3.5.2\",\"minimist\":\"^1.2.0\",\"sinon\":\"^1.17.4\",\"webpack\":\"^1.13.1\",\"webpack-dev-server\":\"^1.14.1\",\"url-search-params\":\"^0.6.1\",\"typescript\":\"^2.0.3\"},\"browser\":{\"./lib/adapters/http.js\":\"./lib/adapters/xhr.js\"},\"typings\":\"./index.d.ts\",\"dependencies\":{\"follow-redirects\":\"^1.3.0\",\"is-buffer\":\"^1.1.5\"},\"bundlesize\":[{\"path\":\"./dist/axios.min.js\",\"threshold\":\"5kB\"}]}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvcGFja2FnZS5qc29uP2VmOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLHFJQUFxSSx5WkFBeVosZUFBZSx3REFBd0QscUdBQXFHLDhDQUE4QyxnRUFBZ0UsdTRCQUF1NEIsWUFBWSxpREFBaUQsMENBQTBDLGlEQUFpRCxnQkFBZ0IsK0NBQStDIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XCJuYW1lXCI6XCJheGlvc1wiLFwidmVyc2lvblwiOlwiMC4xOC4wXCIsXCJkZXNjcmlwdGlvblwiOlwiUHJvbWlzZSBiYXNlZCBIVFRQIGNsaWVudCBmb3IgdGhlIGJyb3dzZXIgYW5kIG5vZGUuanNcIixcIm1haW5cIjpcImluZGV4LmpzXCIsXCJzY3JpcHRzXCI6e1widGVzdFwiOlwiZ3J1bnQgdGVzdCAmJiBidW5kbGVzaXplXCIsXCJzdGFydFwiOlwibm9kZSAuL3NhbmRib3gvc2VydmVyLmpzXCIsXCJidWlsZFwiOlwiTk9ERV9FTlY9cHJvZHVjdGlvbiBncnVudCBidWlsZFwiLFwicHJldmVyc2lvblwiOlwibnBtIHRlc3RcIixcInZlcnNpb25cIjpcIm5wbSBydW4gYnVpbGQgJiYgZ3J1bnQgdmVyc2lvbiAmJiBnaXQgYWRkIC1BIGRpc3QgJiYgZ2l0IGFkZCBDSEFOR0VMT0cubWQgYm93ZXIuanNvbiBwYWNrYWdlLmpzb25cIixcInBvc3R2ZXJzaW9uXCI6XCJnaXQgcHVzaCAmJiBnaXQgcHVzaCAtLXRhZ3NcIixcImV4YW1wbGVzXCI6XCJub2RlIC4vZXhhbXBsZXMvc2VydmVyLmpzXCIsXCJjb3ZlcmFsbHNcIjpcImNhdCBjb3ZlcmFnZS9sY292LmluZm8gfCAuL25vZGVfbW9kdWxlcy9jb3ZlcmFsbHMvYmluL2NvdmVyYWxscy5qc1wifSxcInJlcG9zaXRvcnlcIjp7XCJ0eXBlXCI6XCJnaXRcIixcInVybFwiOlwiaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zLmdpdFwifSxcImtleXdvcmRzXCI6W1wieGhyXCIsXCJodHRwXCIsXCJhamF4XCIsXCJwcm9taXNlXCIsXCJub2RlXCJdLFwiYXV0aG9yXCI6XCJNYXR0IFphYnJpc2tpZVwiLFwibGljZW5zZVwiOlwiTUlUXCIsXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzXCJ9LFwiaG9tZXBhZ2VcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvc1wiLFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wiYnVuZGxlc2l6ZVwiOlwiXjAuNS43XCIsXCJjb3ZlcmFsbHNcIjpcIl4yLjExLjlcIixcImVzNi1wcm9taXNlXCI6XCJeNC4wLjVcIixcImdydW50XCI6XCJeMS4wLjFcIixcImdydW50LWJhbm5lclwiOlwiXjAuNi4wXCIsXCJncnVudC1jbGlcIjpcIl4xLjIuMFwiLFwiZ3J1bnQtY29udHJpYi1jbGVhblwiOlwiXjEuMC4wXCIsXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6XCJeMS4wLjBcIixcImdydW50LWNvbnRyaWItd2F0Y2hcIjpcIl4xLjAuMFwiLFwiZ3J1bnQtZXNsaW50XCI6XCJeMTkuMC4wXCIsXCJncnVudC1rYXJtYVwiOlwiXjIuMC4wXCIsXCJncnVudC10c1wiOlwiXjYuMC4wLWJldGEuM1wiLFwiZ3J1bnQtd2VicGFja1wiOlwiXjEuMC4xOFwiLFwiaXN0YW5idWwtaW5zdHJ1bWVudGVyLWxvYWRlclwiOlwiXjEuMC4wXCIsXCJqYXNtaW5lLWNvcmVcIjpcIl4yLjQuMVwiLFwia2FybWFcIjpcIl4xLjMuMFwiLFwia2FybWEtY2hyb21lLWxhdW5jaGVyXCI6XCJeMi4wLjBcIixcImthcm1hLWNvdmVyYWdlXCI6XCJeMS4wLjBcIixcImthcm1hLWZpcmVmb3gtbGF1bmNoZXJcIjpcIl4xLjAuMFwiLFwia2FybWEtamFzbWluZVwiOlwiXjEuMC4yXCIsXCJrYXJtYS1qYXNtaW5lLWFqYXhcIjpcIl4wLjEuMTNcIixcImthcm1hLW9wZXJhLWxhdW5jaGVyXCI6XCJeMS4wLjBcIixcImthcm1hLXNhZmFyaS1sYXVuY2hlclwiOlwiXjEuMC4wXCIsXCJrYXJtYS1zYXVjZS1sYXVuY2hlclwiOlwiXjEuMS4wXCIsXCJrYXJtYS1zaW5vblwiOlwiXjEuMC41XCIsXCJrYXJtYS1zb3VyY2VtYXAtbG9hZGVyXCI6XCJeMC4zLjdcIixcImthcm1hLXdlYnBhY2tcIjpcIl4xLjcuMFwiLFwibG9hZC1ncnVudC10YXNrc1wiOlwiXjMuNS4yXCIsXCJtaW5pbWlzdFwiOlwiXjEuMi4wXCIsXCJzaW5vblwiOlwiXjEuMTcuNFwiLFwid2VicGFja1wiOlwiXjEuMTMuMVwiLFwid2VicGFjay1kZXYtc2VydmVyXCI6XCJeMS4xNC4xXCIsXCJ1cmwtc2VhcmNoLXBhcmFtc1wiOlwiXjAuNi4xXCIsXCJ0eXBlc2NyaXB0XCI6XCJeMi4wLjNcIn0sXCJicm93c2VyXCI6e1wiLi9saWIvYWRhcHRlcnMvaHR0cC5qc1wiOlwiLi9saWIvYWRhcHRlcnMveGhyLmpzXCJ9LFwidHlwaW5nc1wiOlwiLi9pbmRleC5kLnRzXCIsXCJkZXBlbmRlbmNpZXNcIjp7XCJmb2xsb3ctcmVkaXJlY3RzXCI6XCJeMS4zLjBcIixcImlzLWJ1ZmZlclwiOlwiXjEuMS41XCJ9LFwiYnVuZGxlc2l6ZVwiOlt7XCJwYXRoXCI6XCIuL2Rpc3QvYXhpb3MubWluLmpzXCIsXCJ0aHJlc2hvbGRcIjpcIjVrQlwifV19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvcGFja2FnZS5qc29uXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzPzdlZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar transformData = __webpack_require__(42);\nvar isCancel = __webpack_require__(12);\nvar defaults = __webpack_require__(1);\nvar isAbsoluteURL = __webpack_require__(43);\nvar combineURLs = __webpack_require__(44);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzP2M0YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz80Y2Q1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcz83NDhjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/YTkxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(13);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz83MTZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzP2E3MTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnyType\", function() { return AnyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayType\", function() { return ArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanLiteralType\", function() { return BooleanLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanType\", function() { return BooleanType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyType\", function() { return EmptyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExistentialType\", function() { return ExistentialType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlowIntoType\", function() { return FlowIntoType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionType\", function() { return FunctionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeParam\", function() { return FunctionTypeParam; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeRestParam\", function() { return FunctionTypeRestParam; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeReturn\", function() { return FunctionTypeReturn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneratorType\", function() { return GeneratorType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenericType\", function() { return GenericType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntersectionType\", function() { return IntersectionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixedType\", function() { return MixedType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeAlias\", function() { return TypeAlias; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullableType\", function() { return NullableType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullLiteralType\", function() { return NullLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumberType\", function() { return NumberType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumericLiteralType\", function() { return NumericLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectType\", function() { return ObjectType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeCallProperty\", function() { return ObjectTypeCallProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeIndexer\", function() { return ObjectTypeIndexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeProperty\", function() { return ObjectTypeProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedTypeAlias\", function() { return ParameterizedTypeAlias; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedFunctionType\", function() { return ParameterizedFunctionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PartialType\", function() { return PartialType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefinementType\", function() { return RefinementType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringLiteralType\", function() { return StringLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringType\", function() { return StringType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolLiteralType\", function() { return SymbolLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolType\", function() { return SymbolType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThisType\", function() { return ThisType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TupleType\", function() { return TupleType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeBox\", function() { return TypeBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeConstructor\", function() { return TypeConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParameter\", function() { return TypeParameter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParameterApplication\", function() { return TypeParameterApplication; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeReference\", function() { return TypeReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeTDZ\", function() { return TypeTDZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnionType\", function() { return UnionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoidType\", function() { return VoidType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Declaration\", function() { return Declaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeDeclaration\", function() { return TypeDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VarDeclaration\", function() { return VarDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ModuleDeclaration\", function() { return ModuleDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ModuleExportsDeclaration\", function() { return ModuleExports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassDeclaration\", function() { return ClassDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedClassDeclaration\", function() { return ParameterizedClassDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtendsDeclaration\", function() { return ExtendsDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParametersSymbol\", function() { return TypeParametersSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeSymbol\", function() { return TypeSymbol; });\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nvar primitiveTypes = {};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction makeJSONError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var errors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : null;\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n      var field = stringifyPath(validation.path.concat(path));\n\n      var pointer = `/${path.join('/')}`;\n\n      errors.push({\n        pointer,\n        field,\n        message,\n        expected,\n        actual\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Tracks whether we're in validation of cyclic objects.\nvar cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\n\n\nvar cyclicToString = new WeakSet();\n\nfunction inValidationCycle(type, input) {\n  try {\n    var tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    } else {\n      return weakSetHas(tracked, input);\n    }\n  } catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nfunction startValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nfunction endValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nfunction inToStringCycle(type) {\n  return cyclicToString.has(type);\n}\n\nfunction startToStringCycle(type) {\n  cyclicToString.add(type);\n}\n\nfunction endToStringCycle(type) {\n  cyclicToString.delete(type);\n}\n\nfunction weakSetHas(weakset, value) {\n  try {\n    return weakset.has(value);\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction weakSetAdd(weakset, value) {\n  try {\n    weakset.add(value);\n  } catch (e) {}\n}\n\nfunction weakSetDelete(weakset, value) {\n  try {\n    weakset.delete(value);\n  } catch (e) {}\n}\n\nvar validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nvar Validation = function () {\n  function Validation(context, input) {\n    classCallCheck(this, Validation);\n    this.path = [];\n    this.prefix = '';\n    this.errors = [];\n    this.cyclic = new WeakMap();\n\n    this.context = context;\n    this.input = input;\n  }\n\n  // Tracks whether we're in validation of cyclic objects.\n\n\n  createClass(Validation, [{\n    key: 'inCycle',\n    value: function inCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        return false;\n      } else {\n        return weakSetHas(tracked, input);\n      }\n    }\n  }, {\n    key: 'startCycle',\n    value: function startCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        tracked = new WeakSet();\n        this.cyclic.set(type, tracked);\n      }\n      weakSetAdd(tracked, input);\n    }\n  }, {\n    key: 'endCycle',\n    value: function endCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (tracked) {\n        weakSetDelete(tracked, input);\n      }\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors(path) {\n      if (path) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var candidate = _ref2[0];\n\n            if (matchPath(path, candidate)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        return this.errors.length > 0;\n      }\n    }\n  }, {\n    key: 'addError',\n    value: function addError(path, expectedType, message) {\n      this.errors.push([path, message, expectedType]);\n      return this;\n    }\n  }, {\n    key: 'clearError',\n    value: function clearError(path) {\n      var didClear = false;\n      if (path) {\n        var _errors = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var error = _step2.value;\n\n            if (matchPath(path, error[0])) {\n              didClear = true;\n            } else {\n              _errors.push(error);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.errors = _errors;\n      } else {\n        didClear = this.errors.length > 0;\n        this.errors = [];\n      }\n      return didClear;\n    }\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path) {\n      return _resolvePath(this.input, path);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return makeJSONError(this);\n    }\n  }]);\n  return Validation;\n}();\n\nfunction stringifyPath(path) {\n  if (!path.length) {\n    return 'Value';\n  }\n  var length = path.length;\n\n  var parts = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    } else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    } else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    } else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nfunction _resolvePath(input, path) {\n  var subject = input;\n  var length = path.length;\n\n  for (var i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    } else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nfunction matchPath(path, candidate) {\n  var length = path.length;\n\n  if (length > candidate.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar RuntimeTypeError = function (_TypeError) {\n  inherits(RuntimeTypeError, _TypeError);\n\n  function RuntimeTypeError(message, options) {\n    classCallCheck(this, RuntimeTypeError);\n\n    var _this = possibleConstructorReturn(this, (RuntimeTypeError.__proto__ || Object.getPrototypeOf(RuntimeTypeError)).call(this, message));\n\n    _this.name = \"RuntimeTypeError\";\n\n    Object.assign(_this, options);\n    return _this;\n  }\n\n  return RuntimeTypeError;\n}(TypeError);\n\nvar delimiter = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeTypeError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var prefix = validation.prefix,\n      input = validation.input,\n      context = validation.context,\n      errors = validation.errors;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = _resolvePath(input, path);\n      var actualType = context.typeOf(actual).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      var actualAsString = makeString(actual);\n\n      if (typeof actualAsString === 'string') {\n        collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n      } else {\n        collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`, { errors });\n  } else {\n    return new RuntimeTypeError(collected.join(delimiter), { errors });\n  }\n}\n\nfunction makeString(value) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // Issue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        } catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}\n\nfunction makeError(expected, input) {\n  var context = expected.context;\n\n  var validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\n\n\nfunction compareTypes(a, b) {\n  var result = void 0;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  } else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  } else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  } else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  } else {\n    return result;\n  }\n}\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nvar Type = function () {\n  function Type(context) {\n    classCallCheck(this, Type);\n    this.typeName = 'Type';\n\n    this.context = context;\n  }\n\n  createClass(Type, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var validation = new Validation(this.context, input);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.errors(validation, [], input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n          // eslint-disable-line no-unused-vars\n          return false;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsType',\n    value: function acceptsType(input) {\n      if (compareTypes(this, input) === -1) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return -1;\n    }\n  }, {\n    key: 'assert',\n    value: function assert(input) {\n      var error = makeError(this, input);\n      if (error) {\n        if (typeof Error.captureStackTrace === 'function') {\n          Error.captureStackTrace(error, this.assert);\n        }\n        throw error;\n      }\n      return input;\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Type';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return Type;\n}();\n\nvar AnyType = function (_Type) {\n  inherits(AnyType, _Type);\n\n  function AnyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AnyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AnyType.__proto__ || Object.getPrototypeOf(AnyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'AnyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AnyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'any';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return AnyType;\n}(Type);\n\nvar errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nfunction getErrorMessage(key) {\n  for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, function (m, i) {\n      return String(params[i]);\n    });\n  } else {\n    return message;\n  }\n}\n\nvar TupleType = function (_Type) {\n  inherits(TupleType, _Type);\n\n  function TupleType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TupleType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TupleType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n      for (var i = 0; i < length; i++) {\n        yield* types[i].errors(validation, path.concat(i), input[i]);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n\n      if (!context.checkPredicate('Array', input) || input.length < length) {\n        return false;\n      }\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof TupleType)) {\n        return -1;\n      }\n      var types = this.types;\n      var inputTypes = input.types;\n      if (inputTypes.length < types.length) {\n        return -1;\n      }\n      var isGreater = false;\n      for (var i = 0; i < types.length; i++) {\n        var result = compareTypes(types[i], inputTypes[i]);\n        if (result === 1) {\n          isGreater = true;\n        } else if (result === -1) {\n          return -1;\n        }\n      }\n      if (types.length < inputTypes.length) {\n        return 0;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `[${this.types.join(', ')}]`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return TupleType;\n}(Type);\n\nvar ArrayType = function (_Type) {\n  inherits(ArrayType, _Type);\n\n  function ArrayType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ArrayType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ArrayType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ArrayType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n      if (validation.inCycle(this, input)) {\n        return;\n      }\n      validation.startCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n\n      for (var i = 0; i < length; i++) {\n        yield* elementType.errors(validation, path.concat(i), input[i]);\n      }\n      validation.endCycle(this, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n      for (var i = 0; i < length; i++) {\n        if (!elementType.accepts(input[i])) {\n          endValidationCycle(this, input);\n          return false;\n        }\n      }\n      endValidationCycle(this, input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var elementType = this.elementType;\n\n      if (input instanceof TupleType) {\n        var types = input.types;\n\n        for (var i = 0; i < types.length; i++) {\n          var result = compareTypes(elementType, types[i]);\n          if (result === -1) {\n            return -1;\n          }\n        }\n        return 1;\n      } else if (input instanceof ArrayType) {\n        return compareTypes(elementType, input.elementType);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var elementType = this.elementType;\n\n      if (inToStringCycle(this)) {\n        if (typeof elementType.name === 'string') {\n          return `Array<$Cycle<${elementType.name}>>`;\n        } else {\n          return `Array<$Cycle<Object>>`;\n        }\n      }\n      startToStringCycle(this);\n      var output = `Array<${elementType.toString()}>`;\n      endToStringCycle(this);\n      return output;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        elementType: this.elementType\n      };\n    }\n  }]);\n  return ArrayType;\n}(Type);\n\nvar BooleanLiteralType = function (_Type) {\n  inherits(BooleanLiteralType, _Type);\n\n  function BooleanLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanLiteralType.__proto__ || Object.getPrototypeOf(BooleanLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== this.value) {\n        yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.value ? 'true' : 'false';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        type: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return BooleanLiteralType;\n}(Type);\n\nvar BooleanType = function (_Type) {\n  inherits(BooleanType, _Type);\n\n  function BooleanType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanType.__proto__ || Object.getPrototypeOf(BooleanType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'boolean') {\n        yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'boolean';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType) {\n        return 1;\n      } else if (input instanceof BooleanType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'boolean';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return BooleanType;\n}(Type);\n\nvar EmptyType = function (_Type) {\n  inherits(EmptyType, _Type);\n\n  function EmptyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, EmptyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EmptyType.__proto__ || Object.getPrototypeOf(EmptyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'EmptyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(EmptyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return false; // empty types accepts nothing.\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof EmptyType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'empty';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return EmptyType;\n}(Type);\n\nvar ExistentialType = function (_Type) {\n  inherits(ExistentialType, _Type);\n\n  function ExistentialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExistentialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExistentialType.__proto__ || Object.getPrototypeOf(ExistentialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExistentialType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExistentialType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '*';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ExistentialType;\n}(Type);\n\n/**\n * # TypeParameterApplication\n *\n */\nvar TypeParameterApplication = function (_Type) {\n  inherits(TypeParameterApplication, _Type);\n\n  function TypeParameterApplication() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameterApplication);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameterApplication.__proto__ || Object.getPrototypeOf(TypeParameterApplication)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameterApplication', _this.typeInstances = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeParameterApplication, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      yield* parent.errors.apply(parent, [validation, path, input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      return parent.accepts.apply(parent, [input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var _parent;\n\n      return (_parent = this.parent).compareWith.apply(_parent, [input].concat(toConsumableArray(this.typeInstances)));\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.hasProperty === 'function') {\n        var _ref2;\n\n        return (_ref2 = inner).hasProperty.apply(_ref2, [name].concat(toConsumableArray(this.typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.getProperty === 'function') {\n        var _ref3;\n\n        return (_ref3 = inner).getProperty.apply(_ref3, [name].concat(toConsumableArray(this.typeInstances)));\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _parent2;\n\n      return (_parent2 = this.parent).unwrap.apply(_parent2, toConsumableArray(this.typeInstances));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n      var name = parent.name;\n\n      if (typeInstances.length) {\n        var items = [];\n        for (var i = 0; i < typeInstances.length; i++) {\n          var typeInstance = typeInstances[i];\n          items.push(typeInstance.toString());\n        }\n        return `${name}<${items.join(', ')}>`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeInstances: this.typeInstances\n      };\n    }\n  }]);\n  return TypeParameterApplication;\n}(Type);\n\n/**\n * Add constraints to the given subject type.\n */\nfunction addConstraints(subject) {\n  var _subject$constraints;\n\n  for (var _len = arguments.length, constraints = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    constraints[_key - 1] = arguments[_key];\n  }\n\n  (_subject$constraints = subject.constraints).push.apply(_subject$constraints, toConsumableArray(constraints));\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\n\n\nfunction* collectConstraintErrors(subject, validation, path) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len2 = arguments.length, input = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    input[_key2 - 3] = arguments[_key2];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    var violation = constraint.apply(undefined, toConsumableArray(input));\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nfunction constraintsAccept(subject) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len3 = arguments.length, input = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    input[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    if (typeof constraint.apply(undefined, toConsumableArray(input)) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar TypeAlias = function (_Type) {\n  inherits(TypeAlias, _Type);\n\n  function TypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeAlias.__proto__ || Object.getPrototypeOf(TypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeAlias', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeAlias, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          type = this.type;\n\n      if (withDeclaration) {\n        return `type ${name} = ${type.toString()};`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return this.type.properties;\n    }\n  }, {\n    key: 'hasConstraints',\n    get: function get$$1() {\n      return this.constraints.length > 0;\n    }\n  }]);\n  return TypeAlias;\n}(Type);\n\nvar FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\n\nvar TypeParameter = function (_Type) {\n  inherits(TypeParameter, _Type);\n\n  function TypeParameter() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  createClass(TypeParameter, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n\n      if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        yield* boundOrDefault.errors(validation, path, input);\n        return;\n      } else if (recorded) {\n        // we've already recorded a value for this type parameter\n        yield* recorded.errors(validation, path, input);\n        return;\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n          return;\n        } else {\n          var hasErrors = false;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = boundOrDefault.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var error = _step.value;\n\n              hasErrors = true;\n              yield error;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (hasErrors) {\n            return;\n          }\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n      if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        return boundOrDefault.accepts(input);\n      } else if (recorded) {\n        return recorded.accepts(input);\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n          return true;\n        } else if (!boundOrDefault.accepts(input)) {\n          return false;\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (input instanceof TypeParameter) {\n        // We don't need to check for `recorded` or `bound` fields\n        // because the input has already been unwrapped, so\n        // if we got a type parameter it must be totally generic and\n        // we treat it like Any.\n        return 1;\n      } else if (recorded) {\n        return compareTypes(recorded, input);\n      } else if (boundOrDefault) {\n        return compareTypes(boundOrDefault, input);\n      } else {\n        // A generic type parameter accepts any input.\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (recorded) {\n        return recorded.unwrap();\n      } else if (boundOrDefault) {\n        return boundOrDefault.unwrap();\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      var id = this.id,\n          bound = this.bound,\n          defaultType = this.default;\n\n      if (withBinding) {\n        if (defaultType) {\n          return `${id} = ${defaultType.toString()}`;\n        } else if (bound) {\n          return `${id}: ${bound.toString()}`;\n        }\n      }\n      return id;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        bound: this.bound,\n        recorded: this.recorded\n      };\n    }\n  }]);\n  return TypeParameter;\n}(Type);\n\nfunction flowIntoTypeParameter(typeParameter) {\n  var existing = typeParameter[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  var target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  typeParameter[FlowIntoSymbol] = target;\n  return target;\n}\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\n\nvar FlowIntoType = function (_Type) {\n  inherits(FlowIntoType, _Type);\n\n  function FlowIntoType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FlowIntoType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FlowIntoType.__proto__ || Object.getPrototypeOf(FlowIntoType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FlowIntoType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FlowIntoType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        yield* bound.errors(validation, path, input);\n        return;\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound) {\n          var hasError = false;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = bound.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var error = _step.value;\n\n              yield error;\n              hasError = true;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (hasError) {\n            return;\n          }\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return;\n        } else {\n          var _hasError = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = bound.errors(validation, path, input)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _error = _step2.value;\n\n              yield _error;\n              _hasError = true;\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (_hasError) {\n            return;\n          }\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.accepts(input);\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound && !bound.accepts(input)) {\n          return false;\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return true;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return true;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return true;\n        } else if (!bound.accepts(input)) {\n          return false;\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.compareWith(input);\n      }\n      if (recorded) {\n        if (bound && compareTypes(bound, input) === -1) {\n          return -1;\n        }\n        var result = compareTypes(recorded, input);\n        if (result === 0) {\n          // our existing type already permits this value, there's nothing to do.\n          return 0;\n        }\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, input);\n        return 1;\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return 1;\n        }\n        var _result = compareTypes(bound, input);\n        if (_result === -1) {\n          return -1;\n        }\n      }\n\n      typeParameter.recorded = input;\n      return 0;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.typeParameter.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return this.typeParameter.toString(withBinding);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.typeParameter.toJSON();\n    }\n  }]);\n  return FlowIntoType;\n}(Type);\n\nvar FunctionTypeRestParam = function (_Type) {\n  inherits(FunctionTypeRestParam, _Type);\n\n  function FunctionTypeRestParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeRestParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeRestParam.__proto__ || Object.getPrototypeOf(FunctionTypeRestParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeRestParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeRestParam, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      yield* type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return `...${this.name}: ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeRestParam;\n}(Type);\n\nvar FunctionTypeParam = function (_Type) {\n  inherits(FunctionTypeParam, _Type);\n\n  function FunctionTypeParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeParam.__proto__ || Object.getPrototypeOf(FunctionTypeParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeParam, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return;\n      } else {\n        yield* type.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return true;\n      } else {\n        return type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var optional = this.optional,\n          type = this.type;\n\n      return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        optional: this.optional,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeParam;\n}(Type);\n\nvar FunctionTypeReturn = function (_Type) {\n  inherits(FunctionTypeReturn, _Type);\n\n  function FunctionTypeReturn() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeReturn);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeReturn.__proto__ || Object.getPrototypeOf(FunctionTypeReturn)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeReturn', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeReturn, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeReturn) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeReturn;\n}(Type);\n\nvar ParentSymbol = Symbol('Parent');\nvar NameRegistrySymbol = Symbol('NameRegistry');\nvar ModuleRegistrySymbol = Symbol('ModuleRegistry');\nvar CurrentModuleSymbol = Symbol('CurrentModule');\nvar TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nvar InferrerSymbol = Symbol('Inferrer');\n\n\nvar TypeSymbol = Symbol('Type');\nvar TypeParametersSymbol = Symbol('TypeParameters');\nvar TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\nvar FunctionType = function (_Type) {\n  inherits(FunctionType, _Type);\n\n  function FunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      var annotation = input[TypeSymbol];\n      var returnType = this.returnType,\n          params = this.params;\n\n      if (annotation) {\n        if (!annotation.params) {\n          return;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            yield [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n          } else if (!param.acceptsType(annotationParam)) {\n            yield [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          yield [path, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()), this];\n        }\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i = 0; _i < params.length; _i++) {\n          var _param = params[_i];\n          _param.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var returnType = this.returnType,\n          params = this.params;\n\n      var annotation = input[TypeSymbol];\n      if (annotation) {\n        if (!annotation.params) {\n          return true;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            return false;\n          } else if (!param.acceptsType(annotationParam)) {\n            return false;\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          return false;\n        }\n        return true;\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i2 = 0; _i2 < params.length; _i2++) {\n          var _param2 = params[_i2];\n          _param2.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof FunctionType)) {\n        return -1;\n      }\n      var returnType = this.returnType;\n      var inputReturnType = input.returnType;\n      var isGreater = false;\n      var returnTypeResult = compareTypes(returnType, inputReturnType);\n      if (returnTypeResult === -1) {\n        return -1;\n      } else if (returnTypeResult === 1) {\n        isGreater = true;\n      }\n\n      var params = this.params;\n      var inputParams = input.params;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        var inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n        if (inputParam == null) {\n          return -1;\n        }\n        var result = compareTypes(param, inputParam);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n      }\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.accepts(args[i])) {\n            return false;\n          }\n        } else if (!param.accepts(undefined)) {\n          return false;\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {\n          if (!rest.accepts(args[_i3])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          param.assert(args[i]);\n        } else {\n          param.assert(undefined);\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i4 = paramsLength; _i4 < argsLength; _i4++) {\n          rest.assert(args[_i4]);\n        }\n      }\n\n      return args;\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      this.returnType.assert(input);\n      return input;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var params = this.params,\n          rest = this.rest,\n          context = this.context;\n\n      var paramsLength = params.length;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.acceptsType(args[i])) {\n            return context.empty();\n          }\n        } else if (!param.accepts(undefined)) {\n          return context.empty();\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i5 = paramsLength; _i5 < argsLength; _i5++) {\n          if (!rest.acceptsType(args[_i5])) {\n            return context.empty();\n          }\n        }\n      }\n\n      return this.returnType.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = this.params,\n          rest = this.rest,\n          returnType = this.returnType;\n\n      var args = [];\n      for (var i = 0; i < params.length; i++) {\n        args.push(params[i].toString());\n      }\n      if (rest) {\n        args.push(rest.toString());\n      }\n      return `(${args.join(', ')}) => ${returnType.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        params: this.params,\n        rest: this.rest,\n        returnType: this.returnType\n      };\n    }\n  }]);\n  return FunctionType;\n}(Type);\n\nvar GeneratorType = function (_Type) {\n  inherits(GeneratorType, _Type);\n\n  function GeneratorType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeneratorType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeneratorType.__proto__ || Object.getPrototypeOf(GeneratorType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GeneratorType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeneratorType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var isValid = input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n      if (!isValid) {\n        yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof GeneratorType)) {\n        var _result = compareTypes(this.yieldType, input);\n        if (_result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      var isGreater = false;\n      var result = compareTypes(this.yieldType, input.yieldType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.returnType, input.returnType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.nextType, input.nextType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsYield',\n    value: function acceptsYield(input) {\n      return this.yieldType.accepts(input);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'acceptsNext',\n    value: function acceptsNext(input) {\n      return this.nextType.accepts(input);\n    }\n  }, {\n    key: 'assertYield',\n    value: function assertYield(input) {\n      return this.yieldType.assert(input);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return this.returnType.assert(input);\n    }\n  }, {\n    key: 'assertNext',\n    value: function assertNext(input) {\n      return this.nextType.assert(input);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var yieldType = this.yieldType,\n          returnType = this.returnType,\n          nextType = this.nextType;\n\n      return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        yieldType: this.yieldType,\n        returnType: this.returnType,\n        nextType: this.nextType\n      };\n    }\n  }]);\n  return GeneratorType;\n}(Type);\n\nvar warnedInstances = new WeakSet();\n\nvar TypeConstructor = function (_Type) {\n  inherits(TypeConstructor, _Type);\n\n  function TypeConstructor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeConstructor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeConstructor.__proto__ || Object.getPrototypeOf(TypeConstructor)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeConstructor', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeConstructor, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n        warnedInstances.add(this);\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n        warnedInstances.add(this);\n      }\n      return -1;\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }]);\n  return TypeConstructor;\n}(Type);\n\nvar GenericType = function (_TypeConstructor) {\n  inherits(GenericType, _TypeConstructor);\n\n  function GenericType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GenericType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GenericType.__proto__ || Object.getPrototypeOf(GenericType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = \"GenericType\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GenericType, [{\n    key: \"errors\",\n    value: function* errors(validation, path, input) {\n      var name = this.name,\n          impl = this.impl;\n\n      if (!(input instanceof impl)) {\n        yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n      }\n    }\n  }, {\n    key: \"accepts\",\n    value: function accepts(input) {\n      var impl = this.impl;\n\n      return input instanceof impl;\n    }\n  }, {\n    key: \"compareWith\",\n    value: function compareWith(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var expected = annotation.unwrap.apply(annotation, toConsumableArray(typeInstances));\n        return compareTypes(input, expected);\n      } else if (input instanceof GenericType && (input.impl === impl || impl && impl.isPrototypeOf(input.impl))) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      var context = this.context,\n          impl = this.impl;\n\n      if (typeof impl !== \"function\") {\n        return this;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation != null) {\n        return annotation.unwrap.apply(annotation, arguments);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"inferTypeParameters\",\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }]);\n  return GenericType;\n}(TypeConstructor);\n\nfunction invariant(input, message) {\n  if (!input) {\n    var error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\nvar NullLiteralType = function (_Type) {\n  inherits(NullLiteralType, _Type);\n\n  function NullLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullLiteralType.__proto__ || Object.getPrototypeOf(NullLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== null) {\n        yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === null;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'null';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NullLiteralType;\n}(Type);\n\nvar VoidType = function (_Type) {\n  inherits(VoidType, _Type);\n\n  function VoidType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VoidType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VoidType.__proto__ || Object.getPrototypeOf(VoidType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VoidType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VoidType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== undefined) {\n        yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === undefined;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof VoidType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'void';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return VoidType;\n}(Type);\n\nvar NullableType = function (_Type) {\n  inherits(NullableType, _Type);\n\n  function NullableType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullableType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullableType.__proto__ || Object.getPrototypeOf(NullableType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullableType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullableType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input != null) {\n        yield* this.type.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input == null) {\n        return true;\n      } else {\n        return this.type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType || input instanceof VoidType) {\n        return 1;\n      } else if (input instanceof NullableType) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `? ${this.type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return NullableType;\n}(Type);\n\nvar ObjectTypeProperty = function (_Type) {\n  inherits(ObjectTypeProperty, _Type);\n\n  function ObjectTypeProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeProperty.__proto__ || Object.getPrototypeOf(ObjectTypeProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeProperty', _this['static'] = false, _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeProperty, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n\n    /**\n     * Determine whether the property is nullable.\n     */\n\n  }, {\n    key: 'isNullable',\n    value: function isNullable() {\n      return this.value instanceof NullableType;\n    }\n\n    /**\n     * Determine whether the property exists on the given input or its prototype chain.\n     */\n\n  }, {\n    key: 'existsOn',\n    value: function existsOn(input) {\n      // Ignore\n      var key = this.key,\n          isStatic = this.static;\n\n      return key in (isStatic ? input.constructor : input) === true;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      var targetPath = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        targetPath = path.concat('constructor');\n        if (typeof input.constructor !== 'function') {\n          if (!optional) {\n            yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n          }\n          return;\n        }\n        targetPath.push(key);\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n        targetPath = path.concat(key);\n      }\n      if (optional && target === undefined) {\n        return;\n      }\n      if (this.isNullable() && !this.existsOn(input)) {\n        yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n        return;\n      }\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = value.errors(validation, targetPath, target)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, targetPath, target);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return optional ? true : false;\n        }\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n      }\n\n      if (optional && target === undefined) {\n        return true;\n      }\n\n      if (this.isNullable() && !this.existsOn(input)) {\n        return false;\n      }\n\n      if (!value.accepts(target)) {\n        return false;\n      } else {\n        return constraintsAccept(this, target);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeProperty)) {\n        return -1;\n      } else if (input.key !== this.key) {\n        return -1;\n      } else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var key = this.key;\n      // Issue 252\n      if (typeof key === 'symbol') {\n        key = `[${key.toString()}]`;\n      }\n      if (this.static) {\n        return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n      } else {\n        return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        key: this.key,\n        value: this.value,\n        optional: this.optional\n      };\n    }\n  }]);\n  return ObjectTypeProperty;\n}(Type);\n\nvar ObjectTypeIndexer = function (_Type) {\n  inherits(ObjectTypeIndexer, _Type);\n\n  function ObjectTypeIndexer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeIndexer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeIndexer.__proto__ || Object.getPrototypeOf(ObjectTypeIndexer)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeIndexer', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectTypeIndexer, [{\n    key: 'errors',\n    value: function* errors(validation, path, key, value) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n\n      yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n      yield* this.value.errors(validation, path.concat(key), value);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'acceptsKey',\n    value: function acceptsKey(key) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n      return this.key.accepts(key);\n    }\n  }, {\n    key: 'acceptsValue',\n    value: function acceptsValue(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ObjectTypeProperty) {\n        if (!this.key.accepts(input.key)) {\n          return -1;\n        } else {\n          return compareTypes(this.value, input.value);\n        }\n      } else if (!(input instanceof ObjectTypeIndexer)) {\n        return -1;\n      }\n\n      var keyResult = compareTypes(this.key, input.key);\n      if (keyResult === -1) {\n        return -1;\n      }\n      var valueResult = compareTypes(this.value, input.value);\n      if (valueResult === -1) {\n        return -1;\n      }\n\n      if (keyResult === 0 && valueResult === 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        key: this.key,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeIndexer;\n}(Type);\n\nvar ObjectTypeCallProperty = function (_Type) {\n  inherits(ObjectTypeCallProperty, _Type);\n\n  function ObjectTypeCallProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeCallProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeCallProperty.__proto__ || Object.getPrototypeOf(ObjectTypeCallProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeCallProperty', _this['static'] = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeCallProperty, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n\n      var target = void 0;\n      var targetPath = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        targetPath = path.concat('constructor');\n        if (typeof input.constructor !== 'function') {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n          return;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n        targetPath = path;\n      }\n      yield* value.errors(validation, targetPath, target);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return false;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n      }\n      return value.accepts(target);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeCallProperty)) {\n        return -1;\n      }\n      return compareTypes(this.value, input.value);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.static) {\n        return `static ${this.value.toString()};`;\n      } else {\n        return this.value.toString();\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeCallProperty;\n}(Type);\n\nvar Declaration = function (_Type) {\n  inherits(Declaration, _Type);\n\n  function Declaration() {\n    classCallCheck(this, Declaration);\n    return possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).apply(this, arguments));\n  }\n\n  return Declaration;\n}(Type);\n\nvar VarDeclaration = function (_Declaration) {\n  inherits(VarDeclaration, _Declaration);\n\n  function VarDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VarDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VarDeclaration.__proto__ || Object.getPrototypeOf(VarDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VarDeclaration', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VarDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare var ${this.name}: ${this.type.toString()};`;\n    }\n  }]);\n  return VarDeclaration;\n}(Declaration);\n\nvar TypeDeclaration = function (_Declaration) {\n  inherits(TypeDeclaration, _Declaration);\n\n  function TypeDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeDeclaration.__proto__ || Object.getPrototypeOf(TypeDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      var _typeAlias;\n\n      (_typeAlias = this.typeAlias).addConstraint.apply(_typeAlias, arguments);\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.typeAlias.errors(validation, path, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _typeAlias2;\n\n      return (_typeAlias2 = this.typeAlias).apply.apply(_typeAlias2, arguments);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.typeAlias.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.typeAlias, input);\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var _typeAlias3;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_typeAlias3 = this.typeAlias).hasProperty.apply(_typeAlias3, [name].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var _typeAlias4;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_typeAlias4 = this.typeAlias).getProperty.apply(_typeAlias4, [name].concat(toConsumableArray(typeInstances)));\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _typeAlias5;\n\n      return (_typeAlias5 = this.typeAlias).unwrap.apply(_typeAlias5, arguments);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare ${this.typeAlias.toString(true)};`;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return this.typeAlias.type;\n    }\n  }]);\n  return TypeDeclaration;\n}(Declaration);\n\nvar ModuleDeclaration = function (_Declaration) {\n  inherits(ModuleDeclaration, _Declaration);\n\n  function ModuleDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleDeclaration.__proto__ || Object.getPrototypeOf(ModuleDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleDeclaration, [{\n    key: 'get',\n    value: function get$$1(name) {\n      var moduleExports = this.moduleExports;\n\n      if (moduleExports) {\n        var exporting = moduleExports.unwrap();\n        if (typeof exporting.getProperty === 'function') {\n          var prop = exporting.getProperty(name);\n          if (prop) {\n            return prop.unwrap();\n          }\n        }\n      } else {\n        var declaration = this.declarations[name];\n        if (declaration) {\n          return declaration.unwrap();\n        }\n      }\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Can't validate a module directly.\n      // @todo should this throw?\n    }\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      if (/^\\.\\//.test(moduleName)) {\n        moduleName = `${this.name}${moduleName.slice(1)}`;\n      }\n      return this.innerContext.import(moduleName);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var name = this.name,\n          declarations = this.declarations,\n          modules = this.modules,\n          moduleExports = this.moduleExports;\n\n      var body = [];\n      for (var _name in declarations) {\n        // eslint-disable-line guard-for-in\n        var declaration = declarations[_name];\n        body.push(declaration.toString(true));\n      }\n      if (modules) {\n        for (var _name2 in modules) {\n          // eslint-disable-line guard-for-in\n          var module = modules[_name2];\n          body.push(module.toString());\n        }\n      }\n      if (moduleExports) {\n        body.push(moduleExports.toString());\n      }\n      return `declare module \"${name}\" {\\n${indent$1(body.join('\\n\\n'))}}`;\n    }\n  }, {\n    key: 'moduleType',\n    get: function get$$1() {\n      if (this.moduleExports) {\n        return 'commonjs';\n      } else {\n        return 'es6';\n      }\n    }\n  }, {\n    key: 'isCommonJS',\n    get: function get$$1() {\n      return this.moduleExports ? true : false;\n    }\n  }, {\n    key: 'isES6',\n    get: function get$$1() {\n      return this.moduleExports ? false : true;\n    }\n  }, {\n    key: 'declarations',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[NameRegistrySymbol];\n    }\n  }, {\n    key: 'modules',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[ModuleRegistrySymbol];\n    }\n  }]);\n  return ModuleDeclaration;\n}(Declaration);\n\nfunction indent$1(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\nvar ModuleExports = function (_Declaration) {\n  inherits(ModuleExports, _Declaration);\n\n  function ModuleExports() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleExports);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleExports.__proto__ || Object.getPrototypeOf(ModuleExports)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleExports', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleExports, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare module.exports: ${this.type.toString()};`;\n    }\n  }]);\n  return ModuleExports;\n}(Declaration);\n\nvar ClassDeclaration = function (_Declaration) {\n  inherits(ClassDeclaration, _Declaration);\n\n  function ClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassDeclaration.__proto__ || Object.getPrototypeOf(ClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n        return;\n      }\n      if (superClass) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = superClass.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n\n            var _ref3 = slicedToArray(_ref2, 3);\n\n            var errorPath = _ref3[0];\n            var errorMessage = _ref3[1];\n            var expectedType = _ref3[2];\n\n            var propertyName = errorPath[path.length];\n            if (body.getProperty(propertyName)) {\n              continue;\n            } else {\n              yield [errorPath, errorMessage, expectedType];\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      yield* body.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      } else if (superClass && !superClass.accepts(input)) {\n        return false;\n      } else if (!body.accepts(input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ClassDeclaration) {\n        if (input === this) {\n          return 0;\n        } else if (this.isSuperClassOf(input)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      return compareTypes(this.body, input);\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      var prop = body.getProperty(key);\n      if (prop) {\n        return prop;\n      } else if (superClass && typeof superClass.getProperty === 'function') {\n        return superClass.getProperty(key);\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (body.hasProperty(key)) {\n        return true;\n      } else if (superClass && typeof superClass.hasProperty === 'function') {\n        return superClass.hasProperty(key);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine whether this class declaration represents a super class of\n     * the given type.\n     */\n\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      var body = this.body,\n          shapeID = this.shapeID;\n\n      var current = candidate;\n\n      while (current != null) {\n        if (current === this || current === body || current.shapeID === shapeID) {\n          return true;\n        }\n        if (current instanceof ClassDeclaration) {\n          current = current.superClass;\n        } else {\n          current = current.unwrap();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          superClass = this.superClass,\n          body = this.body;\n\n      if (withDeclaration) {\n        var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n        return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (superClass == null) {\n        return body.properties;\n      }\n      var bodyProps = body.properties;\n      var superProps = superClass.unwrap().properties;\n      if (superProps == null) {\n        return bodyProps;\n      }\n      var seen = {};\n      var seenStatic = {};\n      var props = [];\n      for (var i = 0; i < superProps.length; i++) {\n        var prop = superProps[i];\n        props.push(prop);\n        if (prop.static) {\n          seenStatic[prop.key] = i;\n        } else {\n          seen[prop.key] = i;\n        }\n      }\n      for (var _i = 0; _i < bodyProps.length; _i++) {\n        var _prop = bodyProps[_i];\n        if (seen[_prop.key]) {\n          props[_i] = _prop;\n        } else {\n          props.push(_prop);\n        }\n      }\n      return props;\n    }\n  }]);\n  return ClassDeclaration;\n}(Declaration);\n\nvar PartialType = function (_Type) {\n  inherits(PartialType, _Type);\n\n  function PartialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, PartialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PartialType.__proto__ || Object.getPrototypeOf(PartialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'PartialType', _this.typeParameters = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(PartialType, [{\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this.context);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      this.typeParameters.push(target);\n      return target;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors && constraints) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (constraints && !constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(expand) {\n      var type = this.type;\n\n      return type.toString(expand);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeParameters: this.typeParameters,\n        type: this.type\n      };\n    }\n  }]);\n  return PartialType;\n}(Type);\n\nvar ParameterizedClassDeclaration = function (_Declaration) {\n  inherits(ParameterizedClassDeclaration, _Declaration);\n\n  function ParameterizedClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedClassDeclaration.__proto__ || Object.getPrototypeOf(ParameterizedClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedClassDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return getPartial(this).compareWith(input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).type;\n    }\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      return getPartial(this).type.isSuperClassOf(candidate);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len5 = arguments.length, typeInstances = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeInstances[_key5] = arguments[_key5];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      if (!withDeclaration) {\n        return this.name;\n      }\n      var partial = getPartial(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return partial.toString(true);\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      var superClass = type.superClass,\n          body = type.body;\n\n      var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n      return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getPartial(this).toJSON();\n    }\n  }, {\n    key: 'superClass',\n    get: function get$$1() {\n      return getPartial(this).type.superClass;\n    }\n  }, {\n    key: 'body',\n    get: function get$$1() {\n      return getPartial(this).type.body;\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial(this).type.properties;\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial(this).typeParameters;\n    }\n  }]);\n  return ParameterizedClassDeclaration;\n}(Declaration);\n\nfunction getPartial(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class.apply(context, [parent.name].concat(toConsumableArray(body)));\n  } else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  partial.type.shapeID = parent.shapeID;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len6 = arguments.length, typeInstances = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    typeInstances[_key6 - 1] = arguments[_key6];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ExtendsDeclaration = function (_Declaration) {\n  inherits(ExtendsDeclaration, _Declaration);\n\n  function ExtendsDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExtendsDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExtendsDeclaration.__proto__ || Object.getPrototypeOf(ExtendsDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExtendsDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExtendsDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var type = this.type;\n\n      if (withDeclaration) {\n        return `extends ${type.toString()}`;\n      } else {\n        return type.toString();\n      }\n    }\n  }]);\n  return ExtendsDeclaration;\n}(Declaration);\n\nvar ObjectType = function (_Type) {\n  inherits(ObjectType, _Type);\n\n  function ObjectType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectType, [{\n    key: 'getProperty',\n\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n    value: function getProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return property;\n        }\n      }\n      return this.getIndexer(key);\n    }\n  }, {\n    key: 'setProperty',\n    value: function setProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var context = this.context,\n          properties = this.properties;\n      var length = properties.length;\n\n      var newProp = new ObjectTypeProperty(context);\n      newProp.key = key;\n      newProp.value = value;\n      newProp.optional = optional;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          properties[i] = newProp;\n          return;\n        }\n      }\n      properties.push(newProp);\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return true;\n        }\n      }\n      return this.hasIndexer(key);\n    }\n\n    /**\n     * Get an indexer with which matches the given key type.\n     */\n\n  }, {\n    key: 'getIndexer',\n    value: function getIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return indexer;\n        }\n      }\n    }\n\n    /**\n     * Determine whether an indexer exists which matches the given key type.\n     */\n\n  }, {\n    key: 'hasIndexer',\n    value: function hasIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input === null) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n        }\n      } else if (typeof input !== 'object') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      if (validation.inCycle(this, input)) {\n        return;\n      }\n      validation.startCycle(this, input);\n\n      if (this.indexers.length > 0) {\n        if (input instanceof Object && Array.isArray(input)) {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        yield* collectErrorsWithIndexers(this, validation, path, input);\n      } else {\n        yield* collectErrorsWithoutIndexers(this, validation, path, input);\n      }\n      if (this.exact) {\n        yield* collectErrorsExact(this, validation, path, input);\n      }\n      validation.endCycle(this, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input === null) {\n        return false;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          return false;\n        }\n      } else if (typeof input !== 'object') {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = acceptsWithIndexers(this, input);\n      } else {\n        result = acceptsWithoutIndexers(this, input);\n      }\n      if (result && this.exact) {\n        result = acceptsExact(this, input);\n      }\n      endValidationCycle(this, input);\n      return result;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n        return -1;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      var isGreater = false;\n      if (hasCallProperties) {\n        var _result = compareTypeCallProperties(this, input);\n        if (_result === -1) {\n          return -1;\n        } else if (_result === 1) {\n          isGreater = true;\n        }\n      }\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = compareTypeWithIndexers(this, input);\n      } else {\n        result = compareTypeWithoutIndexers(this, input);\n      }\n\n      if (result === -1) {\n        return -1;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var callProperties = this.callProperties,\n          properties = this.properties,\n          indexers = this.indexers;\n\n      if (inToStringCycle(this)) {\n        return '$Cycle<Object>';\n      }\n      startToStringCycle(this);\n      var body = [];\n      for (var i = 0; i < callProperties.length; i++) {\n        body.push(callProperties[i].toString());\n      }\n      for (var _i = 0; _i < properties.length; _i++) {\n        body.push(properties[_i].toString());\n      }\n      for (var _i2 = 0; _i2 < indexers.length; _i2++) {\n        body.push(indexers[_i2].toString());\n      }\n      endToStringCycle(this);\n      if (this.exact) {\n        return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n      } else {\n        return `{\\n${indent(body.join('\\n'))}\\n}`;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        callProperties: this.callProperties,\n        properties: this.properties,\n        indexers: this.indexers,\n        exact: this.exact\n      };\n    }\n  }]);\n  return ObjectType;\n}(Type);\n\nfunction acceptsCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareTypeCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  var inputCallProperties = input.callProperties;\n  var identicalCount = 0;\n  loop: for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n\n    for (var j = 0; j < inputCallProperties.length; j++) {\n      var inputCallProperty = inputCallProperties[j];\n      var result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      } else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers(type, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i3 = 0; _i3 < indexers.length; _i3++) {\n      var indexer = indexers[_i3];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers(type, input) {\n  var indexers = type.indexers,\n      properties = type.properties;\n\n  var inputIndexers = input.indexers;\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {\n    var indexer = indexers[_i4];\n    for (var _j = 0; _j < inputIndexers.length; _j++) {\n      var inputIndexer = inputIndexers[_j];\n      var _result2 = compareTypes(indexer, inputIndexer);\n      if (_result2 === 1) {\n        isGreater = true;\n        continue loop;\n      } else if (_result2 === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction acceptsWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact(type, input) {\n  var properties = type.properties;\n\n  var _loop = function _loop(key) {\n    // eslint-disable-line guard-for-in\n    if (!properties.some(function (property) {\n      return property.key === key;\n    })) {\n      return {\n        v: false\n      };\n    }\n  };\n\n  for (var key in input) {\n    var _ret2 = _loop(key);\n\n    if (typeof _ret2 === \"object\") return _ret2.v;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction* collectErrorsWithIndexers(type, validation, path, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i5 = 0; _i5 < indexers.length; _i5++) {\n      var indexer = indexers[_i5];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\nfunction* collectErrorsWithoutIndexers(type, validation, path, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\nfunction* collectErrorsExact(type, validation, path, input) {\n  var properties = type.properties;\n\n  var _loop2 = function* _loop2(key) {\n    // eslint-disable-line guard-for-in\n    if (!properties.some(function (property) {\n      return property.key === key;\n    })) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  };\n\n  for (var key in input) {\n    yield* _loop2(key);\n  }\n}\n\nfunction indent(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\nvar IntersectionType = function (_Type) {\n  inherits(IntersectionType, _Type);\n\n  function IntersectionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, IntersectionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IntersectionType.__proto__ || Object.getPrototypeOf(IntersectionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'IntersectionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(IntersectionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        yield* types[i].errors(validation, path, input);\n      }\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = length - 1; i >= 0; i--) {\n        var type = types[i];\n        if (typeof type.getProperty === 'function') {\n          var prop = type.getProperty(key);\n          if (prop) {\n            return prop;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      var identicalCount = 0;\n      if (input instanceof IntersectionType) {\n        var inputTypes = input.types;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n        return identicalCount === types.length ? 0 : 1;\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          var _result = compareTypes(_type, input);\n          if (_result === -1) {\n            return -1;\n          } else if (_result === 0) {\n            identicalCount++;\n          }\n        }\n        return identicalCount === types.length ? 0 : 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _ref2;\n\n      var callProperties = [];\n      var properties = [];\n      var indexers = [];\n      var types = this.types,\n          context = this.context;\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        invariant(type instanceof ObjectType, 'Can only intersect object types');\n        callProperties.push.apply(callProperties, toConsumableArray(type.callProperties));\n        indexers.push.apply(indexers, toConsumableArray(type.indexers));\n        mergeProperties(properties, type.properties);\n      }\n      return (_ref2 = context).object.apply(_ref2, callProperties.concat(properties, indexers));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.types.join(' & ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return IntersectionType;\n}(Type);\n\nfunction getPropertyIndex(name, properties) {\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    var typeProp = source[i];\n    var index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    } else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\nvar MixedType = function (_Type) {\n  inherits(MixedType, _Type);\n\n  function MixedType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, MixedType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MixedType.__proto__ || Object.getPrototypeOf(MixedType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'MixedType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(MixedType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'mixed';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return MixedType;\n}(Type);\n\nvar NumericLiteralType = function (_Type) {\n  inherits(NumericLiteralType, _Type);\n\n  function NumericLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumericLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumericLiteralType.__proto__ || Object.getPrototypeOf(NumericLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumericLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumericLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumericLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `${this.value}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return NumericLiteralType;\n}(Type);\n\nvar NumberType = function (_Type) {\n  inherits(NumberType, _Type);\n\n  function NumberType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumberType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumberType.__proto__ || Object.getPrototypeOf(NumberType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumberType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumberType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'number') {\n        yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'number';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumberType) {\n        return 0;\n      } else if (input instanceof NumericLiteralType) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'number';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NumberType;\n}(Type);\n\nvar ParameterizedTypeAlias = function (_TypeAlias) {\n  inherits(ParameterizedTypeAlias, _TypeAlias);\n\n  function ParameterizedTypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedTypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedTypeAlias.__proto__ || Object.getPrototypeOf(ParameterizedTypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedTypeAlias', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedTypeAlias, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      var partial = getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances)));\n      if (!partial.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(getPartial$1(this), input);\n      }\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        typeInstances[_key5 - 1] = arguments[_key5];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len6 = arguments.length, typeInstances = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeInstances[_key6] = arguments[_key6];\n      }\n\n      return getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var partial = getPartial$1(this);\n      var typeParameters = partial.typeParameters;\n\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n\n      var name = this.name;\n\n      var identifier = typeParameters.length > 0 ? `${name}<${items.join(', ')}>` : name;\n\n      if (withDeclaration) {\n        return `type ${identifier} = ${partial.toString()};`;\n      } else {\n        return identifier;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$1(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial$1(this).type.properties;\n    }\n  }]);\n  return ParameterizedTypeAlias;\n}(TypeAlias);\n\nfunction getPartial$1(parent) {\n  var typeCreator = parent.typeCreator,\n      context = parent.context,\n      name = parent.name;\n\n  var partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len7 = arguments.length, typeInstances = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    typeInstances[_key7 - 1] = arguments[_key7];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ParameterizedFunctionType = function (_Type) {\n  inherits(ParameterizedFunctionType, _Type);\n\n  function ParameterizedFunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedFunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedFunctionType.__proto__ || Object.getPrototypeOf(ParameterizedFunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedFunctionType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedFunctionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getPartial$2(this), input);\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var _getPartial$type;\n\n      return (_getPartial$type = getPartial$2(this).type).acceptsParams.apply(_getPartial$type, arguments);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return getPartial$2(this).type.acceptsReturn(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var _getPartial$type2;\n\n      return (_getPartial$type2 = getPartial$2(this).type).assertParams.apply(_getPartial$type2, arguments);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return getPartial$2(this).type.assertReturn(input);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var partial = getPartial$2(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return type.toString();\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      return `<${items.join(', ')}> ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$2(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial$2(this).typeParameters;\n    }\n  }, {\n    key: 'params',\n    get: function get$$1() {\n      return getPartial$2(this).type.params;\n    }\n  }, {\n    key: 'rest',\n    get: function get$$1() {\n      return getPartial$2(this).type.rest;\n    }\n  }, {\n    key: 'returnType',\n    get: function get$$1() {\n      return getPartial$2(this).type.returnType;\n    }\n  }]);\n  return ParameterizedFunctionType;\n}(Type);\n\nfunction getPartial$2(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  partial.type = context.function.apply(context, toConsumableArray(body));\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    typeInstances[_key5 - 1] = arguments[_key5];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar RefinementType = function (_Type) {\n  inherits(RefinementType, _Type);\n\n  function RefinementType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RefinementType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RefinementType.__proto__ || Object.getPrototypeOf(RefinementType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'RefinementType', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(RefinementType, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return `$Refinment<${type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return RefinementType;\n}(Type);\n\nvar StringLiteralType = function (_Type) {\n  inherits(StringLiteralType, _Type);\n\n  function StringLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringLiteralType.__proto__ || Object.getPrototypeOf(StringLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return StringLiteralType;\n}(Type);\n\nvar StringType = function (_Type) {\n  inherits(StringType, _Type);\n\n  function StringType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringType.__proto__ || Object.getPrototypeOf(StringType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'string') {\n        yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'string';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType) {\n        return 1;\n      } else if (input instanceof StringType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return StringType;\n}(Type);\n\nvar SymbolLiteralType = function (_Type) {\n  inherits(SymbolLiteralType, _Type);\n\n  function SymbolLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolLiteralType.__proto__ || Object.getPrototypeOf(SymbolLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `typeof ${String(this.value)}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return SymbolLiteralType;\n}(Type);\n\nvar SymbolType = function (_Type) {\n  inherits(SymbolType, _Type);\n\n  function SymbolType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolType.__proto__ || Object.getPrototypeOf(SymbolType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Issue 252\n      if (typeof input !== 'symbol') {\n        yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'symbol';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType) {\n        return 1;\n      } else if (input instanceof SymbolType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Symbol';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return SymbolType;\n}(Type);\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\n\nvar ThisType = function (_Type) {\n  inherits(ThisType, _Type);\n\n  function ThisType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ThisType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ThisType.__proto__ || Object.getPrototypeOf(ThisType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ThisType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ThisType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return;\n      } else if (recorded != null) {\n        yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return true;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return true;\n      } else if (recorded != null) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ThisType)) {\n        return -1;\n      } else if (input.recorded && this.recorded) {\n        return input.recorded === this.recorded ? 0 : -1;\n      } else if (this.recorded) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return 'this';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ThisType;\n}(Type);\n\nvar warnedInstances$1 = new WeakSet();\n\nvar TypeBox = function (_Type) {\n  inherits(TypeBox, _Type);\n\n  function TypeBox() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeBox);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeBox.__proto__ || Object.getPrototypeOf(TypeBox)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeBox', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeBox, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this.type;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.type.toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      return this.type.name;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var reveal = this.reveal;\n\n      var type = reveal();\n      if (!type) {\n        if (!warnedInstances$1.has(this)) {\n          this.context.emitWarningMessage('Failed to reveal boxed type.');\n          warnedInstances$1.add(this);\n        }\n        return this.context.mixed();\n      } else if (!(type instanceof Type)) {\n        // we got a boxed reference to something like a class\n        return this.context.ref(type);\n      }\n      return type;\n    }\n  }]);\n  return TypeBox;\n}(Type);\n\nvar warnedMissing = {};\n\nvar TypeReference = function (_Type) {\n  inherits(TypeReference, _Type);\n\n  function TypeReference() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeReference);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeReference.__proto__ || Object.getPrototypeOf(TypeReference)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeReference', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeReference, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var context = this.context,\n          name = this.name;\n\n      var type = context.get(name);\n      if (!type) {\n        if (!warnedMissing[name]) {\n          context.emitWarningMessage(`Cannot resolve type: ${name}`);\n          warnedMissing[name] = true;\n        }\n        return context.any();\n      }\n      return type;\n    }\n  }]);\n  return TypeReference;\n}(Type);\n\nvar warnedInstances$2 = new WeakSet();\n\nvar RevealedName = Symbol('RevealedName');\nvar RevealedValue = Symbol('RevealedValue');\n\nvar TypeTDZ = function (_Type) {\n  inherits(TypeTDZ, _Type);\n\n  function TypeTDZ() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeTDZ);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeTDZ.__proto__ || Object.getPrototypeOf(TypeTDZ)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeTDZ', _this[RevealedName] = undefined, _this[RevealedValue] = undefined, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeTDZ, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* getRevealed(this).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return getRevealed(this).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getRevealed(this), input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = getRevealed(this);\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return getRevealed(this).unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return getRevealed(this).toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getRevealed(this).toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      var name = this[RevealedName];\n      if (!name) {\n        name = getRevealed(this).name;\n      }\n      return name;\n    },\n    set: function set$$1(value) {\n      this[RevealedName] = value;\n    }\n  }]);\n  return TypeTDZ;\n}(Type);\n\nfunction getRevealed(container) {\n  var existing = container[RevealedValue];\n  if (existing) {\n    return existing;\n  } else {\n    var reveal = container.reveal;\n\n    var type = reveal();\n    if (!type) {\n      if (!warnedInstances$2.has(container)) {\n        var name = container[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        } else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances$2.add(container);\n      }\n      return container.context.mixed();\n    } else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\nvar UnionType = function (_Type) {\n  inherits(UnionType, _Type);\n\n  function UnionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, UnionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnionType.__proto__ || Object.getPrototypeOf(UnionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'UnionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(UnionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return;\n        }\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      if (input instanceof UnionType) {\n        var inputTypes = input.types;\n        var identicalCount = 0;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n\n        if (identicalCount === types.length) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          if (compareTypes(_type, input) >= 0) {\n            return 1;\n          }\n        }\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var types = this.types;\n\n      var normalized = new Array(types.length);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n          normalized[i] = `(${type.toString()})`;\n        } else {\n          normalized[i] = type.toString();\n        }\n      }\n      return normalized.join(' | ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return UnionType;\n}(Type);\n\nfunction registerPrimitiveTypes(t) {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\nfunction registerBuiltinTypeConstructors(t) {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors(validation, path, input) {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      } else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts(input) {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors(validation, path, input, futureType) {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts(input) {\n      var context = this.context;\n\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors(validation, path, input, keyType, valueType) {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          if (!keyType.accepts(key)) {\n            yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n          }\n\n          yield* valueType.errors(validation, path.concat(key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    accepts(input, keyType, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref3 = _step2.value;\n\n          var _ref4 = slicedToArray(_ref3, 2);\n\n          var key = _ref4[0];\n          var value = _ref4[1];\n\n          if (!keyType.accepts(key) || !valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      var keyTypes = [];\n      var valueTypes = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        loop: for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref5 = _step3.value;\n\n          var _ref6 = slicedToArray(_ref5, 2);\n\n          var key = _ref6[0];\n          var value = _ref6[1];\n\n          findKey: {\n            for (var i = 0; i < keyTypes.length; i++) {\n              var type = keyTypes[i];\n              if (type.accepts(key)) {\n                break findKey;\n              }\n            }\n            keyTypes.push(t.typeOf(key));\n          }\n\n          for (var _i = 0; _i < valueTypes.length; _i++) {\n            var _type = valueTypes[_i];\n            if (_type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors(validation, path, input, valueType) {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = input[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var value = _step4.value;\n\n          yield* valueType.errors(validation, path, value);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    },\n    accepts(input, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (!valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      var valueTypes = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        loop: for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n\n          for (var i = 0; i < valueTypes.length; i++) {\n            var type = valueTypes[i];\n            if (type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      } else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      } else {\n        return [t.union.apply(t, valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\nfunction registerTypePredicates(context) {\n  context.setPredicate('Array', function (input) {\n    return Array.isArray(input);\n  });\n  context.setPredicate('Map', function (input) {\n    return input instanceof Map;\n  });\n  context.setPredicate('Set', function (input) {\n    return input instanceof Set;\n  });\n  context.setPredicate('Promise', function (input) {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null && (typeof input === 'object' || typeof input === 'function') && typeof input.then === 'function';\n    }\n  });\n}\n\nvar TypeInferer = function () {\n  function TypeInferer(context) {\n    classCallCheck(this, TypeInferer);\n\n    this.context = context;\n  }\n\n  createClass(TypeInferer, [{\n    key: 'infer',\n    value: function infer(input) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      var inferred = new Map();\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferInternal',\n    value: function inferInternal(input, inferred) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferPrimitive',\n    value: function inferPrimitive(input) {\n      var context = this.context;\n\n      if (input === null) {\n        return context.null();\n      } else if (input === undefined) {\n        return context.void();\n      } else if (typeof input === 'number') {\n        return context.number();\n      } else if (typeof input === 'boolean') {\n        return context.boolean();\n      } else if (typeof input === 'string') {\n        return context.string();\n      }\n      // Issue 252\n      else if (typeof input === 'symbol') {\n          return context.symbol(input);\n        } else {\n          return undefined;\n        }\n    }\n  }, {\n    key: 'inferComplex',\n    value: function inferComplex(input, inferred) {\n      var context = this.context;\n\n\n      if (typeof input === 'function') {\n        return this.inferFunction(input, inferred);\n      } else if (input !== null && typeof input === 'object') {\n        return this.inferObject(input, inferred);\n      } else {\n        return context.any();\n      }\n    }\n  }, {\n    key: 'inferFunction',\n    value: function inferFunction(input, inferred) {\n      var context = this.context;\n      var length = input.length;\n\n      var body = new Array(length + 1);\n      for (var i = 0; i < length; i++) {\n        body[i] = context.param(String.fromCharCode(97 + i), context.existential());\n      }\n      body[length] = context.return(context.existential());\n      return context.fn.apply(context, body);\n    }\n  }, {\n    key: 'inferObject',\n    value: function inferObject(input, inferred) {\n      var existing = inferred.get(input);\n      if (existing) {\n        return existing;\n      }\n      var context = this.context;\n\n      var type = void 0;\n\n      // Temporarily create a box for this type to catch cyclical references.\n      // Nested references to this object will receive the boxed type.\n      var box = context.box(function () {\n        return type;\n      });\n      inferred.set(input, box);\n\n      if (context.checkPredicate('Array', input)) {\n        type = this.inferArray(input, inferred);\n      } else if (!(input instanceof Object)) {\n        type = this.inferDict(input, inferred);\n      } else if (input.constructor !== Object) {\n        var handler = context.getTypeConstructor(input.constructor);\n        if (handler) {\n          var typeParameters = handler.inferTypeParameters(input);\n          type = handler.apply.apply(handler, toConsumableArray(typeParameters));\n        } else {\n          type = context.ref(input.constructor);\n        }\n      } else {\n        var body = [];\n        for (var key in input) {\n          // eslint-disable-line\n          var value = input[key];\n          body.push(context.property(key, this.inferInternal(value, inferred)));\n        }\n        type = context.object.apply(context, body);\n      }\n\n      // Overwrite the box with the real value.\n      inferred.set(input, type);\n      return type;\n    }\n  }, {\n    key: 'inferDict',\n    value: function inferDict(input, inferred) {\n      var numericIndexers = [];\n      var stringIndexers = [];\n      loop: for (var key in input) {\n        // eslint-disable-line\n        var value = input[key];\n        var types = isNaN(+key) ? stringIndexers : numericIndexers;\n        for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        types.push(this.inferInternal(value, inferred));\n      }\n\n      var context = this.context;\n\n      var body = [];\n      if (numericIndexers.length === 1) {\n        body.push(context.indexer('index', context.number(), numericIndexers[0]));\n      } else if (numericIndexers.length > 1) {\n        body.push(context.indexer('index', context.number(), context.union.apply(context, numericIndexers)));\n      }\n\n      if (stringIndexers.length === 1) {\n        body.push(context.indexer('key', context.string(), stringIndexers[0]));\n      } else if (stringIndexers.length > 1) {\n        body.push(context.indexer('key', context.string(), context.union.apply(context, stringIndexers)));\n      }\n\n      return context.object.apply(context, body);\n    }\n  }, {\n    key: 'inferArray',\n    value: function inferArray(input, inferred) {\n      var context = this.context;\n\n      var types = [];\n      var values = [];\n      var length = input.length;\n\n      loop: for (var i = 0; i < length; i++) {\n        var item = input[i];\n        var inferredType = this.inferInternal(item, inferred);\n        for (var j = 0; j < types.length; j++) {\n          var type = types[j];\n          if (type.accepts(item) && inferredType.accepts(values[j])) {\n            continue loop;\n          }\n        }\n        types.push(inferredType);\n        values.push(item);\n      }\n      if (types.length === 0) {\n        return context.array(context.any());\n      } else if (types.length === 1) {\n        return context.array(types[0]);\n      } else {\n        return context.array(context.union.apply(context, types));\n      }\n    }\n  }]);\n  return TypeInferer;\n}();\n\nfunction makeReactPropTypes(objectType) {\n  var output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n\n  var _loop = function _loop(property) {\n    output[property.key] = function (props, propName, componentName) {\n      return makeError(property, props);\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = objectType.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return output;\n}\n\nvar delimiter$1 = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeWarningMessage(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return `Warning: ${collected.join(delimiter$1)}`;\n}\n\nfunction makeUnion(context, types) {\n  var length = types.length;\n  var merged = [];\n  for (var i = 0; i < length; i++) {\n    var type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return type;\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    } else {\n      merged.push(type);\n    }\n  }\n  var union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes(aTypes, bTypes) {\n  loop: for (var i = 0; i < bTypes.length; i++) {\n    var bType = bTypes[i];\n    for (var j = 0; j < aTypes.length; j++) {\n      var aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\nfunction makePropertyDescriptor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert);\n  } else {\n    return propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert);\n  }\n}\n\nfunction makePropertyName(name) {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName(input) {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  } else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  } else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType(receiver, typeSource) {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  } else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  var safeName = makePropertyName(propertyName);\n  var className = getClassName(input);\n  var initializer = descriptor.initializer,\n      writable = descriptor.writable,\n      config = objectWithoutProperties(descriptor, ['initializer', 'writable']); // eslint-disable-line no-unused-vars\n\n  var propertyPath = [className, propertyName];\n\n  return _extends({}, config, {\n    type: 'accessor',\n    get() {\n      if (safeName in this) {\n        return this[safeName];\n      } else if (initializer) {\n        var type = resolveType(this, typeSource);\n        var _value = initializer.call(this);\n        var context = type.context;\n        context.check(type, _value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: _value\n        });\n        return _value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set(value) {\n      var type = resolveType(this, typeSource);\n      var context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      } else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  });\n}\n\nfunction augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert) {\n\n  var className = getClassName(input);\n  var propertyPath = [className, propertyName];\n\n  var originalSetter = descriptor.set;\n\n  descriptor.set = function set$$1(value) {\n    var type = resolveType(this, typeSource);\n    var context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    } else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n}\n\n// eslint-disable-line no-redeclare\n\nfunction annotateValue(input, type) {\n  // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  } else {\n    var _type = input;\n    return function (input) {\n      input[TypeSymbol] = _type;\n      return input;\n    };\n  }\n}\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nvar $DiffType = function (_Type) {\n  inherits($DiffType, _Type);\n\n  function $DiffType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $DiffType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $DiffType.__proto__ || Object.getPrototypeOf($DiffType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$DiffType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($DiffType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        yield* property.errors(validation, path.concat(property.key), input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        if (!property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var aType = this.aType,\n          bType = this.bType;\n\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      var args = [];\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        args.push(property);\n      }\n      return (_context = this.context).object.apply(_context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        aType: this.aType,\n        bType: this.bType\n      };\n    }\n  }]);\n  return $DiffType;\n}(Type);\n\n// Any subtype of T\n\nvar $FlowFixMeType = function (_Type) {\n  inherits($FlowFixMeType, _Type);\n\n  function $FlowFixMeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $FlowFixMeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $FlowFixMeType.__proto__ || Object.getPrototypeOf($FlowFixMeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$FlowFixMeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($FlowFixMeType, [{\n    key: 'errors',\n    value: function* errors(validation, input) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$FlowFixMe';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return $FlowFixMeType;\n}(Type);\n\n// The set of keys of T.\n\nvar $KeysType = function (_Type) {\n  inherits($KeysType, _Type);\n\n  function $KeysType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $KeysType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $KeysType.__proto__ || Object.getPrototypeOf($KeysType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$KeysType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($KeysType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return;\n        }\n      }\n      var keys = new Array(length);\n      for (var _i = 0; _i < length; _i++) {\n        keys[_i] = properties[_i].key;\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var keys = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        keys[i] = context.literal(property.key);\n      }\n      return (_context = this.context).union.apply(_context, keys);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Keys<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $KeysType;\n}(Type);\n\n// Map over the keys and values in an object.\n\nvar $ObjMapiType = function (_Type) {\n  inherits($ObjMapiType, _Type);\n\n  function $ObjMapiType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapiType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapiType.__proto__ || Object.getPrototypeOf($ObjMapiType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapiType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapiType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = target.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          yield* returnType.errors(validation, path.concat(prop.key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key), prop.value)));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapiType;\n}(Type);\n\n// Map over the keys in an object.\n\nvar $ObjMapType = function (_Type) {\n  inherits($ObjMapType, _Type);\n\n  function $ObjMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapType.__proto__ || Object.getPrototypeOf($ObjMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = target.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          yield* returnType.errors(validation, path.concat(prop.key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key))));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapType;\n}(Type);\n\n// The type of the named object property\n\nvar $PropertyType = function (_Type) {\n  inherits($PropertyType, _Type);\n\n  function $PropertyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $PropertyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $PropertyType.__proto__ || Object.getPrototypeOf($PropertyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$PropertyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($PropertyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.unwrap().errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.unwrap().accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          property = this.property;\n\n      var unwrapped = object.unwrap();\n      invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n      return unwrapped.getProperty(property).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        property: this.property\n      };\n    }\n  }]);\n  return $PropertyType;\n}(Type);\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nvar $ShapeType = function (_Type) {\n  inherits($ShapeType, _Type);\n\n  function $ShapeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ShapeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ShapeType.__proto__ || Object.getPrototypeOf($ShapeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ShapeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ShapeType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property) {\n          continue;\n        }\n        yield* property.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property || !property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var type = this.type;\n\n      type = type.unwrap();\n      var context = this.context;\n      invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n      var properties = type.properties;\n      var args = new Array(properties.length);\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        args[i] = context.property(property.key, property.value, true);\n      }\n      return (_context = this.context).object.apply(_context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Shape<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ShapeType;\n}(Type);\n\n// Any subtype of T\n\nvar $SubType = function (_Type) {\n  inherits($SubType, _Type);\n\n  function $SubType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SubType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SubType.__proto__ || Object.getPrototypeOf($SubType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SubType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SubType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(input, path);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Subtype<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SubType;\n}(Type);\n\n// Any, but at least T.\n\nvar $SuperType = function (_Type) {\n  inherits($SuperType, _Type);\n\n  function $SuperType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SuperType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SuperType.__proto__ || Object.getPrototypeOf($SuperType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SuperType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SuperType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Supertype<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SuperType;\n}(Type);\n\n// Map over the values in a tuple.\n\nvar $TupleMapType = function (_Type) {\n  inherits($TupleMapType, _Type);\n\n  function $TupleMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $TupleMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $TupleMapType.__proto__ || Object.getPrototypeOf($TupleMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$TupleMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($TupleMapType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        var expected = applied.invoke(type);\n        var value = input[i];\n        yield* expected.errors(validation, path.concat(i), value);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        if (!applied.invoke(type).accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n      var args = [];\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        args.push(applied.invoke(type).unwrap().unwrap());\n      }\n\n      return context.tuple.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        tuple: this.tuple,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $TupleMapType;\n}(Type);\n\n// The set of keys of T.\n\nvar $ValuesType = function (_Type) {\n  inherits($ValuesType, _Type);\n\n  function $ValuesType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ValuesType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ValuesType.__proto__ || Object.getPrototypeOf($ValuesType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ValuesType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ValuesType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.value.accepts(input)) {\n          return;\n        }\n      }\n      var values = new Array(length);\n      for (var _i = 0; _i < length; _i++) {\n        values[_i] = properties[_i].value.toString();\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.value.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var values = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        values[i] = property.value;\n      }\n      return context.union.apply(context, values);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Values<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ValuesType;\n}(Type);\n\nfunction checkGenericType(context, expected, input) {\n  var impl = expected.impl;\n\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  } else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  var annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  } else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType(context, expected, input) {\n  var annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    var result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\nvar ClassType = function (_Type) {\n  inherits(ClassType, _Type);\n\n  function ClassType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassType.__proto__ || Object.getPrototypeOf(ClassType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n        return;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      var isValid = expectedType instanceof GenericType ? checkGenericType(context, expectedType, input) : checkType(context, expectedType, input);\n      if (!isValid) {\n        yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      if (expectedType instanceof GenericType) {\n        return checkGenericType(context, expectedType, input);\n      } else {\n        return checkType(context, expectedType, input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var instanceType = this.instanceType;\n\n      if (input instanceof ClassType) {\n        return compareTypes(instanceType, input.instanceType);\n      }\n      return -1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `Class<${this.instanceType.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        instanceType: this.instanceType\n      };\n    }\n  }]);\n  return ClassType;\n}(Type);\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nvar warnedInvalidReferences = new WeakSet();\n\nvar TypeContext = function () {\n  function TypeContext() {\n    classCallCheck(this, TypeContext);\n    this.mode = 'assert';\n    this[NameRegistrySymbol] = {};\n    this[TypePredicateRegistrySymbol] = {};\n    this[TypeConstructorRegistrySymbol] = new Map();\n    this[InferrerSymbol] = new TypeInferer(this);\n    this[ModuleRegistrySymbol] = {};\n  }\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeContext, [{\n    key: 'makeJSONError',\n    value: function makeJSONError$$1(validation) {\n      return makeJSONError(validation);\n    }\n  }, {\n    key: 'makeTypeError',\n    value: function makeTypeError$$1(validation) {\n      return makeTypeError(validation);\n    }\n  }, {\n    key: 'createContext',\n    value: function createContext() {\n      var context = new TypeContext();\n      // Issue 252\n      context[ParentSymbol] = this;\n      return context;\n    }\n  }, {\n    key: 'typeOf',\n    value: function typeOf(input) {\n\n      var annotation = this.getAnnotation(input);\n      if (annotation) {\n        if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n          return this.Class(annotation);\n        }\n        return annotation;\n      }\n      // Issue 252\n      var inferrer = this[InferrerSymbol];\n      inferrer;\n\n      return inferrer.infer(input);\n    }\n  }, {\n    key: 'compareTypes',\n    value: function compareTypes$$1(a, b) {\n      return compareTypes(a, b);\n    }\n  }, {\n    key: 'get',\n    value: function get$$1(name) {\n      // Issue 252\n      var item = this[NameRegistrySymbol][name];\n\n      for (var _len = arguments.length, propertyNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        propertyNames[_key - 1] = arguments[_key];\n      }\n\n      if (item != null) {\n        var current = typeof item === 'function' ? new item(this) : item;\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n          if (typeof current.getProperty !== 'function') {\n            return;\n          }\n          current = current.getProperty(propertyName);\n          if (!current) {\n            return;\n          }\n          current = current.unwrap();\n        }\n        return current;\n      }\n      // Issue 252\n      var parent = this[ParentSymbol];\n      if (parent) {\n        var fromParent = parent.get.apply(parent, [name].concat(toConsumableArray(propertyNames)));\n        if (fromParent) {\n          return fromParent;\n        }\n      }\n\n      // if we got this far, see if we have a global type with this name.\n      if (typeof global[name] === 'function') {\n        var target = new GenericType(this);\n        target.name = name;\n        target.impl = global[name];\n        // Issue 252\n        this[NameRegistrySymbol][name] = target;\n        return target;\n      }\n    }\n\n    /**\n     * Get the predicate for a given type name.\n     * e.g. `t.getPredicate('Array')`.\n     */\n\n  }, {\n    key: 'getPredicate',\n    value: function getPredicate(name) {\n      var item = this[TypePredicateRegistrySymbol][name];\n      if (item) {\n        return item;\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.getPredicate(name);\n      }\n    }\n\n    /**\n     * Set the predicate for a given type name.\n     * This can be used to customise the behaviour of things like Array\n     * detection or allowing Thenables in place of the global Promise.\n     */\n\n  }, {\n    key: 'setPredicate',\n    value: function setPredicate(name, predicate) {\n      this[TypePredicateRegistrySymbol][name] = predicate;\n    }\n\n    /**\n     * Check the given value against the named predicate.\n     * Returns false if no such predicate exists.\n     * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n     */\n\n  }, {\n    key: 'checkPredicate',\n    value: function checkPredicate(name, input) {\n      var predicate = this.getPredicate(name);\n      if (predicate) {\n        return predicate(input);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Returns a decorator for a function or object with the given type.\n     */\n\n  }, {\n    key: 'decorate',\n    value: function decorate(type, shouldAssert) {\n      var _this2 = this;\n\n      if (shouldAssert == null) {\n        shouldAssert = this.mode === 'assert';\n      }\n      return function (input, propertyName, descriptor) {\n        if (descriptor && typeof propertyName === 'string') {\n          return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n        } else {\n          invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n          return _this2.annotate(input, type);\n        }\n      };\n    }\n\n    /**\n     * Annotates an object or function with the given type.\n     * If a type is specified as the sole argument, returns a\n     * function which can decorate classes or functions with the given type.\n     */\n\n  }, {\n    key: 'annotate',\n    value: function annotate(input, type) {\n      if (type === undefined) {\n        return annotateValue(input);\n      } else {\n        return annotateValue(input, type);\n      }\n    }\n  }, {\n    key: 'getAnnotation',\n    value: function getAnnotation(input) {\n      if (input !== null && typeof input === 'object' || typeof input === 'function') {\n        // Issue 252\n        return input[TypeSymbol];\n      }\n    }\n  }, {\n    key: 'hasAnnotation',\n    value: function hasAnnotation(input) {\n      if (input == null) {\n        return false;\n      } else {\n        return input[TypeSymbol] ? true : false;\n      }\n    }\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(input, type) {\n      input[TypeSymbol] = type;\n      return input;\n    }\n  }, {\n    key: 'type',\n    value: function type(name, _type) {\n      if (typeof _type === 'function') {\n        var target = new ParameterizedTypeAlias(this);\n        target.name = name;\n        target.typeCreator = _type;\n        return target;\n      } else {\n        var _target = new TypeAlias(this);\n        _target.name = name;\n        _target.type = _type;\n        return _target;\n      }\n    }\n  }, {\n    key: 'declare',\n    value: function declare(name, type) {\n\n      if (name instanceof Declaration) {\n        type = name;\n        name = type.name;\n      } else if (name instanceof TypeAlias) {\n        type = name;\n        name = type.name;\n      }\n      if (typeof type === 'function') {\n        type = this.type(name, type);\n      }\n      if (type instanceof ModuleDeclaration) {\n        var moduleRegistry = this[ModuleRegistrySymbol];\n        moduleRegistry[name] = type;\n        return type;\n      } else {\n        invariant(typeof name === 'string', 'Name must be a string');\n        invariant(type instanceof Type, 'Type must be supplied to declaration');\n        var nameRegistry = this[NameRegistrySymbol];\n\n        if (type instanceof Declaration) {\n          nameRegistry[name] = type;\n          return type;\n        } else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n          var target = new TypeDeclaration(this);\n          target.name = name;\n          target.typeAlias = type;\n          nameRegistry[name] = target;\n          return target;\n        } else {\n          var _target2 = this.var(name, type);\n          nameRegistry[name] = _target2;\n          return _target2;\n        }\n      }\n    }\n  }, {\n    key: 'declarations',\n    value: function* declarations() {\n      var nameRegistry = this[NameRegistrySymbol];\n      for (var key in nameRegistry) {\n        // eslint-disable-line guard-for-in\n        yield [key, nameRegistry[key]];\n      }\n    }\n  }, {\n    key: 'modules',\n    value: function* modules() {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      for (var key in moduleRegistry) {\n        // eslint-disable-line guard-for-in\n        yield moduleRegistry[key];\n      }\n    }\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      if (moduleRegistry[moduleName]) {\n        return moduleRegistry[moduleName];\n      }\n\n      var _moduleName$split = moduleName.split('/'),\n          _moduleName$split2 = slicedToArray(_moduleName$split, 1),\n          head = _moduleName$split2[0];\n\n      var module = moduleRegistry[head];\n      if (module) {\n        return module.import(moduleName);\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.import(moduleName);\n      }\n    }\n  }, {\n    key: 'declareTypeConstructor',\n    value: function declareTypeConstructor(_ref) {\n      var name = _ref.name,\n          impl = _ref.impl,\n          typeName = _ref.typeName,\n          errors = _ref.errors,\n          accepts = _ref.accepts,\n          inferTypeParameters = _ref.inferTypeParameters,\n          compareWith = _ref.compareWith;\n\n      var nameRegistry = this[NameRegistrySymbol];\n\n      if (nameRegistry[name]) {\n        this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n      }\n\n      var target = new TypeConstructor(this);\n      target.name = name;\n      target.typeName = typeName;\n      target.impl = impl;\n      target.errors = errors;\n      target.accepts = accepts;\n      target.inferTypeParameters = inferTypeParameters;\n      if (typeof compareWith === 'function') {\n        target.compareWith = compareWith;\n      }\n\n      nameRegistry[name] = target;\n\n      if (typeof impl === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        if (handlerRegistry.has(impl)) {\n          this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n        }\n        handlerRegistry.set(impl, target);\n      }\n      return target;\n    }\n  }, {\n    key: 'getTypeConstructor',\n    value: function getTypeConstructor(impl) {\n      // Issue 252\n      var handlerRegistry = this[TypeConstructorRegistrySymbol];\n      handlerRegistry;\n\n      return handlerRegistry.get(impl);\n    }\n  }, {\n    key: 'literal',\n    value: function literal(input) {\n      if (input === undefined) {\n        return this.void();\n      } else if (input === null) {\n        return this.null();\n      } else if (typeof input === 'boolean') {\n        return this.boolean(input);\n      } else if (typeof input === 'number') {\n        return this.number(input);\n      } else if (typeof input === 'string') {\n        return this.string(input);\n      }\n      // Issue 252\n      else if (typeof input === 'symbol') {\n          return this.symbol(input);\n        } else {\n          return this.typeOf(input);\n        }\n    }\n  }, {\n    key: 'null',\n    value: function _null() {\n      return primitiveTypes.null;\n    }\n  }, {\n    key: 'nullable',\n    value: function nullable(type) {\n      var target = new NullableType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'existential',\n    value: function existential() {\n      return primitiveTypes.existential;\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return primitiveTypes.empty;\n    }\n  }, {\n    key: 'any',\n    value: function any() {\n      return primitiveTypes.any;\n    }\n  }, {\n    key: 'mixed',\n    value: function mixed() {\n      return primitiveTypes.mixed;\n    }\n  }, {\n    key: 'void',\n    value: function _void() {\n      return primitiveTypes.void;\n    }\n  }, {\n    key: 'this',\n    value: function _this(input) {\n      var target = new ThisType(this);\n      if (input !== undefined) {\n        target.recorded = input;\n      }\n      return target;\n    }\n  }, {\n    key: 'number',\n    value: function number(input) {\n      if (input !== undefined) {\n        var target = new NumericLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.number;\n      }\n    }\n  }, {\n    key: 'boolean',\n    value: function boolean(input) {\n      if (input !== undefined) {\n        var target = new BooleanLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.boolean;\n      }\n    }\n  }, {\n    key: 'string',\n    value: function string(input) {\n      if (input !== undefined) {\n        var target = new StringLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.string;\n      }\n    }\n  }, {\n    key: 'symbol',\n    value: function symbol(input) {\n      if (input !== undefined) {\n        var target = new SymbolLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.symbol;\n      }\n    }\n  }, {\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      return target;\n    }\n  }, {\n    key: 'flowInto',\n    value: function flowInto(typeParameter) {\n      return flowIntoTypeParameter(typeParameter);\n    }\n\n    /**\n     * Bind the type parameters for the parent class of the given instance.\n     */\n\n  }, {\n    key: 'bindTypeParameters',\n    value: function bindTypeParameters(subject) {\n      var instancePrototype = Object.getPrototypeOf(subject);\n      // Issue\n      var parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n      // Issue\n      var parentClass = parentPrototype && parentPrototype.constructor;\n\n      if (!parentClass) {\n        this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n        return subject;\n      }\n      // Issue 252\n      var typeParametersPointer = parentClass[TypeParametersSymbol];\n\n      if (typeParametersPointer) {\n        var typeParameters = subject[typeParametersPointer];\n        var keys = Object.keys(typeParameters);\n\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var length = Math.min(keys.length, typeInstances.length);\n        for (var i = 0; i < length; i++) {\n          var typeParam = typeParameters[keys[i]];\n          typeParam.bound = typeInstances[i];\n        }\n      }\n      return subject;\n    }\n  }, {\n    key: 'module',\n    value: function module(name, body) {\n      var target = new ModuleDeclaration(this);\n      target.name = name;\n      var innerContext = this.createContext();\n      // Issue 252\n      innerContext[ParentSymbol] = this;\n      // Issue 252\n      innerContext[CurrentModuleSymbol] = target;\n\n      target.innerContext = innerContext;\n      body(innerContext);\n      return target;\n    }\n  }, {\n    key: 'moduleExports',\n    value: function moduleExports(type) {\n      var currentModule = this[CurrentModuleSymbol];\n      if (!currentModule) {\n        throw new Error('Cannot declare module.exports outside of a module.');\n      }\n      var target = new ModuleExports(this);\n      target.type = type;\n      currentModule.moduleExports = target;\n      return target;\n    }\n  }, {\n    key: 'var',\n    value: function _var(name, type) {\n      var target = new VarDeclaration(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'class',\n    value: function _class(name, head) {\n      if (typeof head === 'function') {\n        var _target3 = new ParameterizedClassDeclaration(this);\n        _target3.name = name;\n        _target3.bodyCreator = head;\n        return _target3;\n      }\n      var target = new ClassDeclaration(this);\n      target.name = name;\n\n      for (var _len3 = arguments.length, tail = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        tail[_key3 - 2] = arguments[_key3];\n      }\n\n      if (head != null) {\n        tail.unshift(head);\n      }\n      var length = tail.length;\n\n      var properties = [];\n      var body = void 0;\n\n      for (var i = 0; i < length; i++) {\n        var item = tail[i];\n        if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n          properties.push(item);\n        } else if (item instanceof ObjectType) {\n          invariant(!body, 'Class body must only be declared once.');\n          body = item;\n        } else if (item instanceof ExtendsDeclaration) {\n          invariant(!target.superClass, 'Classes can only have one super class.');\n          target.superClass = item;\n        } else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n          for (var propertyName in item) {\n            // eslint-disable-line\n            properties.push(this.property(propertyName, item[propertyName]));\n          }\n        } else {\n          throw new Error('ClassDeclaration cannot contain the given type directly.');\n        }\n      }\n      if (!body) {\n        body = new ObjectType(this);\n      }\n      if (properties.length) {\n        var _body$properties;\n\n        (_body$properties = body.properties).push.apply(_body$properties, properties);\n      }\n      target.body = body;\n      return target;\n    }\n  }, {\n    key: 'extends',\n    value: function _extends(subject) {\n      var target = new ExtendsDeclaration(this);\n\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      target.type = this.ref.apply(this, [subject].concat(toConsumableArray(typeInstances)));\n      return target;\n    }\n  }, {\n    key: 'fn',\n    value: function fn(head) {\n      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        tail[_key5 - 1] = arguments[_key5];\n      }\n\n      return this.function.apply(this, [head].concat(tail));\n    }\n  }, {\n    key: 'function',\n    value: function _function(head) {\n      if (typeof head === 'function') {\n        var _target4 = new ParameterizedFunctionType(this);\n        _target4.bodyCreator = head;\n        return _target4;\n      }\n      var target = new FunctionType(this);\n      if (head != null) {\n        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          tail[_key6 - 1] = arguments[_key6];\n        }\n\n        tail.unshift(head);\n        var length = tail.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = tail[i];\n          if (item instanceof FunctionTypeParam) {\n            target.params.push(item);\n          } else if (item instanceof FunctionTypeRestParam) {\n            target.rest = item;\n          } else if (item instanceof FunctionTypeReturn) {\n            target.returnType = item;\n          } else {\n            throw new Error('FunctionType cannot contain the given type directly.');\n          }\n        }\n      }\n      if (!target.returnType) {\n        target.returnType = this.any();\n      }\n      return target;\n    }\n  }, {\n    key: 'param',\n    value: function param(name, type) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new FunctionTypeParam(this);\n      target.name = name;\n      target.type = type;\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'rest',\n    value: function rest(name, type) {\n      var target = new FunctionTypeRestParam(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'return',\n    value: function _return(type) {\n      var target = new FunctionTypeReturn(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'generator',\n    value: function generator(yieldType, returnType, nextType) {\n      var target = new GeneratorType(this);\n      target.yieldType = yieldType;\n      target.returnType = returnType || this.any();\n      target.nextType = nextType || this.any();\n      return target;\n    }\n  }, {\n    key: 'object',\n    value: function object(head) {\n      var target = new ObjectType(this);\n      if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n        for (var propertyName in head) {\n          // eslint-disable-line\n          target.properties.push(this.property(propertyName, head[propertyName]));\n        }\n      } else {\n        var body = void 0;\n\n        for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          tail[_key7 - 1] = arguments[_key7];\n        }\n\n        if (head) {\n          body = [head].concat(toConsumableArray(tail));\n        } else {\n          body = tail;\n        }\n        var _body = body,\n            length = _body.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = body[i];\n          if (item instanceof ObjectTypeProperty) {\n            target.properties.push(item);\n          } else if (item instanceof ObjectTypeIndexer) {\n            target.indexers.push(item);\n          } else if (item instanceof ObjectTypeCallProperty) {\n            target.callProperties.push(item);\n          } else {\n            throw new Error('ObjectType cannot contain the given type directly.');\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'exactObject',\n    value: function exactObject(head) {\n      for (var _len8 = arguments.length, tail = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        tail[_key8 - 1] = arguments[_key8];\n      }\n\n      var object = this.object.apply(this, [head].concat(toConsumableArray(tail)));\n      object.exact = true;\n      return object;\n    }\n  }, {\n    key: 'callProperty',\n    value: function callProperty(value) {\n      var target = new ObjectTypeCallProperty(this);\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'property',\n    value: function property(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new ObjectTypeProperty(this);\n      target.key = key;\n      if (value instanceof Type) {\n        target.value = value;\n      } else {\n        target.value = this.object(value);\n      }\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'indexer',\n    value: function indexer(id, key, value) {\n      var target = new ObjectTypeIndexer(this);\n      target.id = id;\n      target.key = key;\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'method',\n    value: function method(name, head) {\n      var target = new ObjectTypeProperty(this);\n      target.key = name;\n\n      for (var _len9 = arguments.length, tail = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        tail[_key9 - 2] = arguments[_key9];\n      }\n\n      target.value = this.function.apply(this, [head].concat(tail));\n      return target;\n    }\n  }, {\n    key: 'staticCallProperty',\n    value: function staticCallProperty(value) {\n      var prop = this.callProperty(value);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticProperty',\n    value: function staticProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var prop = this.property(key, value, optional);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticMethod',\n    value: function staticMethod(name, head) {\n      for (var _len10 = arguments.length, tail = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        tail[_key10 - 2] = arguments[_key10];\n      }\n\n      var prop = this.method.apply(this, [name, head].concat(tail));\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'spread',\n    value: function spread() {\n      var target = new ObjectType(this);\n\n      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        types[_key11] = arguments[_key11];\n      }\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        if (Array.isArray(type.callProperties)) {\n          var _target$callPropertie;\n\n          (_target$callPropertie = target.callProperties).push.apply(_target$callPropertie, toConsumableArray(type.callProperties));\n        }\n        if (Array.isArray(type.indexers)) {\n          var _target$indexers;\n\n          (_target$indexers = target.indexers).push.apply(_target$indexers, toConsumableArray(type.indexers));\n        }\n        if (Array.isArray(type.properties)) {\n          for (var j = 0; j < type.properties.length; j++) {\n            var prop = type.properties[j];\n            invariant(prop instanceof ObjectTypeProperty);\n            target.setProperty(prop.key, prop.value, prop.optional);\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'tuple',\n    value: function tuple() {\n      var target = new TupleType(this);\n\n      for (var _len12 = arguments.length, types = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        types[_key12] = arguments[_key12];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'array',\n    value: function array(elementType) {\n      var target = new ArrayType(this);\n      target.elementType = elementType || this.any();\n      return target;\n    }\n  }, {\n    key: 'union',\n    value: function union() {\n      for (var _len13 = arguments.length, types = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        types[_key13] = arguments[_key13];\n      }\n\n      return makeUnion(this, types);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect() {\n      var target = new IntersectionType(this);\n\n      for (var _len14 = arguments.length, types = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        types[_key14] = arguments[_key14];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'intersection',\n    value: function intersection() {\n      return this.intersect.apply(this, arguments);\n    }\n  }, {\n    key: 'box',\n    value: function box(reveal) {\n      var box = new TypeBox(this);\n      box.reveal = reveal;\n      return box;\n    }\n  }, {\n    key: 'tdz',\n    value: function tdz(reveal, name) {\n      var tdz = new TypeTDZ(this);\n      tdz.reveal = reveal;\n      tdz.name = name;\n      return tdz;\n    }\n  }, {\n    key: 'ref',\n    value: function ref(subject) {\n      var target = void 0;\n      if (typeof subject === 'string') {\n        // try and eagerly resolve the reference\n        target = this.get(subject);\n        if (!target) {\n          // defer dereferencing for now\n          target = new TypeReference(this);\n          target.name = subject;\n        }\n      } else if (typeof subject === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        // see if we have a dedicated TypeConstructor for this.\n        target = handlerRegistry.get(subject);\n\n        if (!target) {\n          // just use a generic type handler.\n          target = new GenericType(this);\n          target.impl = subject;\n          target.name = subject.name;\n        }\n      } else if (subject instanceof Type) {\n        target = subject;\n      } else {\n        if (subject == null || typeof subject !== 'object') {\n          this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n        } else if (!warnedInvalidReferences.has(subject)) {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n          warnedInvalidReferences.add(subject);\n        }\n        return this.any();\n      }\n\n      for (var _len15 = arguments.length, typeInstances = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n        typeInstances[_key15 - 1] = arguments[_key15];\n      }\n\n      if (typeInstances.length) {\n        var _target5;\n\n        invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n        return (_target5 = target).apply.apply(_target5, toConsumableArray(typeInstances));\n      } else {\n        return target;\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = new Validation(this, input);\n      if (path) {\n        var _validation$path;\n\n        (_validation$path = validation.path).push.apply(_validation$path, toConsumableArray(path));\n      } else if (typeof type.name === 'string') {\n        validation.path.push(type.name);\n      }\n      validation.prefix = prefix;\n      validation.errors = Array.from(type.errors(validation, [], input));\n      return validation;\n    }\n  }, {\n    key: 'check',\n    value: function check(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      if (this.mode === 'assert') {\n        return this.assert(type, input, prefix, path);\n      } else {\n        return this.warn(type, input, prefix, path);\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var error = this.makeTypeError(validation);\n      if (error) {\n        throw error;\n      }\n      return input;\n    }\n  }, {\n    key: 'warn',\n    value: function warn(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var message = makeWarningMessage(validation);\n      if (typeof message === 'string') {\n        this.emitWarningMessage(message);\n      }\n      return input;\n    }\n\n    /**\n     * Emits a warning message, using `console.warn()` by default.\n     */\n\n  }, {\n    key: 'emitWarningMessage',\n    value: function emitWarningMessage(message) {\n      console.warn('flow-runtime:', message);\n    }\n  }, {\n    key: 'propTypes',\n    value: function propTypes(type) {\n      return makeReactPropTypes(type.unwrap());\n    }\n  }, {\n    key: 'match',\n    value: function match() {\n      for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      var clauses = args.pop();\n      if (!Array.isArray(clauses)) {\n        throw new Error('Invalid pattern, last argument must be an array.');\n      }\n      clauses;\n      var pattern = this.pattern.apply(this, toConsumableArray(clauses));\n      return pattern.apply(undefined, args);\n    }\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      for (var _len17 = arguments.length, clauses = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        clauses[_key17] = arguments[_key17];\n      }\n\n      var length = clauses.length;\n\n      var tests = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var clause = clauses[i];\n        var annotation = this.getAnnotation(clause);\n        if (!annotation) {\n          if (i !== length - 1) {\n            throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n          }\n          tests[i] = true;\n        } else {\n          invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n          tests[i] = annotation;\n        }\n      }\n      return function () {\n        for (var _i = 0; _i < tests.length; _i++) {\n          var test = tests[_i];\n          var _clause = clauses[_i];\n          if (test === true) {\n            return _clause.apply(undefined, arguments);\n          } else if (test.acceptsParams.apply(test, arguments)) {\n            return _clause.apply(undefined, arguments);\n          }\n        }\n        var error = new TypeError('Value did not match any of the candidates.');\n        error.name = 'RuntimeTypeError';\n        throw error;\n      };\n    }\n  }, {\n    key: 'wrapIterator',\n    value: function wrapIterator(type) {\n      var t = this;\n      return function* wrappedIterator(input) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            yield t.check(type, item);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: 'refinement',\n    value: function refinement(type) {\n      var target = new RefinementType(this);\n      target.type = type;\n\n      for (var _len18 = arguments.length, constraints = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n        constraints[_key18 - 1] = arguments[_key18];\n      }\n\n      target.addConstraint.apply(target, toConsumableArray(constraints));\n      return target;\n    }\n  }, {\n    key: '$exact',\n    value: function $exact(type) {\n      var target = new ObjectType(this);\n      type = type.unwrap();\n      if (Array.isArray(type.callProperties)) {\n        var _target$callPropertie2;\n\n        (_target$callPropertie2 = target.callProperties).push.apply(_target$callPropertie2, toConsumableArray(type.callProperties));\n      }\n      if (Array.isArray(type.indexers)) {\n        var _target$indexers2;\n\n        (_target$indexers2 = target.indexers).push.apply(_target$indexers2, toConsumableArray(type.indexers));\n      }\n      if (Array.isArray(type.properties)) {\n        var _target$properties;\n\n        (_target$properties = target.properties).push.apply(_target$properties, toConsumableArray(type.properties));\n      }\n      target.exact = true;\n      return target;\n    }\n  }, {\n    key: '$diff',\n    value: function $diff(aType, bType) {\n      var target = new $DiffType(this);\n      target.aType = aType;\n      target.bType = bType;\n      return target;\n    }\n  }, {\n    key: '$flowFixMe',\n    value: function $flowFixMe() {\n      return new $FlowFixMeType(this);\n    }\n  }, {\n    key: '$keys',\n    value: function $keys(type) {\n      var target = new $KeysType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$objMap',\n    value: function $objMap(object, mapper) {\n      var target = new $ObjMapType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$objMapi',\n    value: function $objMapi(object, mapper) {\n      var target = new $ObjMapiType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$propertyType',\n    value: function $propertyType(object, property) {\n      var target = new $PropertyType(this);\n      target.object = object;\n      if (property instanceof Type) {\n        var unwrapped = property.unwrap();\n        target.property = unwrapped.value;\n      } else {\n        target.property = property;\n      }\n      return target;\n    }\n  }, {\n    key: '$shape',\n    value: function $shape(type) {\n      var target = new $ShapeType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$subtype',\n    value: function $subtype(type) {\n      var target = new $SubType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$supertype',\n    value: function $supertype(type) {\n      var target = new $SuperType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$tupleMap',\n    value: function $tupleMap(tuple, mapper) {\n      var target = new $TupleMapType(this);\n      target.tuple = tuple;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$values',\n    value: function $values(type) {\n      var target = new $ValuesType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'Class',\n    value: function Class(instanceType) {\n      var target = new ClassType(this);\n      target.instanceType = instanceType;\n      return target;\n    }\n  }, {\n    key: 'TypeParametersSymbol',\n\n\n    // Issue 252\n    get: function get$$1() {\n      return TypeParametersSymbol;\n    }\n  }]);\n  return TypeContext;\n}();\n\nvar globalContext$1 = void 0;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext$1 = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n} else {\n  globalContext$1 = new TypeContext();\n  registerPrimitiveTypes(globalContext$1);\n  registerBuiltinTypeConstructors(globalContext$1);\n  registerTypePredicates(globalContext$1);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext$1;\n  }\n}\n\nvar globalContext$2 = globalContext$1;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (globalContext$2);\n//# sourceMappingURL=flow-runtime.es2015.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdy1ydW50aW1lL2Rpc3QvZmxvdy1ydW50aW1lLmVzMjAxNS5qcz81MmI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWNEO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCOztBQUU3RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGdFQUFnRTtBQUNySTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGdFQUFnRTtBQUNySTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEZBQTBGLGdFQUFnRTtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0ZBQXNGLGFBQWE7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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGLGVBQWU7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGLGVBQWU7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSztBQUNyRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsZ0VBQWdFO0FBQzdIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELG1FQUFtRTtBQUNsSTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0IsSUFBSSxzQkFBc0I7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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QUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUdBQW1HLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1R0FBdUcsZUFBZTtBQUN0SDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFKzJCO0FBQy8yQiIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGV4cG9ydHMgYSBkaWN0aW9uYXJ5IG9mIGdsb2JhbCBwcmltaXRpdmUgdHlwZXMgdGhhdCBhcmUgc2hhcmVkIGJ5IGFsbCBjb250ZXh0cy5cbiAqIEl0IGlzIHBvcHVsYXRlZCBpbiBbcmVnaXN0ZXJQcmltaXRpdmVUeXBlcygpXSguL3JlZ2lzdGVyUHJpbWl0aXZlVHlwZXMuanMpLlxuICovXG5cbnZhciBwcmltaXRpdmVUeXBlcyA9IHt9O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFrZUpTT05FcnJvcih2YWxpZGF0aW9uKSB7XG4gIGlmICghdmFsaWRhdGlvbi5oYXNFcnJvcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5wdXQgPSB2YWxpZGF0aW9uLmlucHV0LFxuICAgICAgY29udGV4dCA9IHZhbGlkYXRpb24uY29udGV4dDtcblxuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbGlkYXRpb24uZXJyb3JzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCAzKTtcblxuICAgICAgdmFyIHBhdGggPSBfcmVmMlswXTtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjJbMV07XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gX3JlZjJbMl07XG5cbiAgICAgIHZhciBleHBlY3RlZCA9IGV4cGVjdGVkVHlwZSA/IGV4cGVjdGVkVHlwZS50b1N0cmluZygpIDogbnVsbDtcbiAgICAgIHZhciBhY3R1YWwgPSBjb250ZXh0LnR5cGVPZihfcmVzb2x2ZVBhdGgoaW5wdXQsIHBhdGgpKS50b1N0cmluZygpO1xuICAgICAgdmFyIGZpZWxkID0gc3RyaW5naWZ5UGF0aCh2YWxpZGF0aW9uLnBhdGguY29uY2F0KHBhdGgpKTtcblxuICAgICAgdmFyIHBvaW50ZXIgPSBgLyR7cGF0aC5qb2luKCcvJyl9YDtcblxuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBwb2ludGVyLFxuICAgICAgICBmaWVsZCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGFjdHVhbFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbi8vIFRyYWNrcyB3aGV0aGVyIHdlJ3JlIGluIHZhbGlkYXRpb24gb2YgY3ljbGljIG9iamVjdHMuXG52YXIgY3ljbGljVmFsaWRhdGlvbiA9IG5ldyBXZWFrTWFwKCk7XG4vLyBUcmFja3Mgd2hldGhlciB3ZSdyZSB0b1N0cmluZygpIG9mIGN5Y2xpYyBvYmplY3RzLlxuXG5cbnZhciBjeWNsaWNUb1N0cmluZyA9IG5ldyBXZWFrU2V0KCk7XG5cbmZ1bmN0aW9uIGluVmFsaWRhdGlvbkN5Y2xlKHR5cGUsIGlucHV0KSB7XG4gIHRyeSB7XG4gICAgdmFyIHRyYWNrZWQgPSBjeWNsaWNWYWxpZGF0aW9uLmdldCh0eXBlKTtcbiAgICBpZiAoIXRyYWNrZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdlYWtTZXRIYXModHJhY2tlZCwgaW5wdXQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNvbWUgZXhvdGljIHZhbHVlcyBjYW5ub3QgYmUgY2hlY2tlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGlvbkN5Y2xlKHR5cGUsIGlucHV0KSB7XG4gIHZhciB0cmFja2VkID0gY3ljbGljVmFsaWRhdGlvbi5nZXQodHlwZSk7XG4gIGlmICghdHJhY2tlZCkge1xuICAgIHRyYWNrZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgIGN5Y2xpY1ZhbGlkYXRpb24uc2V0KHR5cGUsIHRyYWNrZWQpO1xuICB9XG4gIHdlYWtTZXRBZGQodHJhY2tlZCwgaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBlbmRWYWxpZGF0aW9uQ3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgdmFyIHRyYWNrZWQgPSBjeWNsaWNWYWxpZGF0aW9uLmdldCh0eXBlKTtcbiAgaWYgKHRyYWNrZWQpIHtcbiAgICB3ZWFrU2V0RGVsZXRlKHRyYWNrZWQsIGlucHV0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpblRvU3RyaW5nQ3ljbGUodHlwZSkge1xuICByZXR1cm4gY3ljbGljVG9TdHJpbmcuaGFzKHR5cGUpO1xufVxuXG5mdW5jdGlvbiBzdGFydFRvU3RyaW5nQ3ljbGUodHlwZSkge1xuICBjeWNsaWNUb1N0cmluZy5hZGQodHlwZSk7XG59XG5cbmZ1bmN0aW9uIGVuZFRvU3RyaW5nQ3ljbGUodHlwZSkge1xuICBjeWNsaWNUb1N0cmluZy5kZWxldGUodHlwZSk7XG59XG5cbmZ1bmN0aW9uIHdlYWtTZXRIYXMod2Vha3NldCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2Vha3NldC5oYXModmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Vha1NldEFkZCh3ZWFrc2V0LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHdlYWtzZXQuYWRkKHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuZnVuY3Rpb24gd2Vha1NldERlbGV0ZSh3ZWFrc2V0LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHdlYWtzZXQuZGVsZXRlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxudmFyIHZhbGlkSWRlbnRpZmllck9yQWNjZXNzb3IgPSAvXlskQS1aX11bMC05QS1aXyRbXFxdLl0qJC9pO1xuXG52YXIgVmFsaWRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmFsaWRhdGlvbihjb250ZXh0LCBpbnB1dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZhbGlkYXRpb24pO1xuICAgIHRoaXMucGF0aCA9IFtdO1xuICAgIHRoaXMucHJlZml4ID0gJyc7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLmN5Y2xpYyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuXG4gIC8vIFRyYWNrcyB3aGV0aGVyIHdlJ3JlIGluIHZhbGlkYXRpb24gb2YgY3ljbGljIG9iamVjdHMuXG5cblxuICBjcmVhdGVDbGFzcyhWYWxpZGF0aW9uLCBbe1xuICAgIGtleTogJ2luQ3ljbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkN5Y2xlKHR5cGUsIGlucHV0KSB7XG4gICAgICB2YXIgdHJhY2tlZCA9IHRoaXMuY3ljbGljLmdldCh0eXBlKTtcbiAgICAgIGlmICghdHJhY2tlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2Vha1NldEhhcyh0cmFja2VkLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRDeWNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0Q3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciB0cmFja2VkID0gdGhpcy5jeWNsaWMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKCF0cmFja2VkKSB7XG4gICAgICAgIHRyYWNrZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLmN5Y2xpYy5zZXQodHlwZSwgdHJhY2tlZCk7XG4gICAgICB9XG4gICAgICB3ZWFrU2V0QWRkKHRyYWNrZWQsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmRDeWNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZEN5Y2xlKHR5cGUsIGlucHV0KSB7XG4gICAgICB2YXIgdHJhY2tlZCA9IHRoaXMuY3ljbGljLmdldCh0eXBlKTtcbiAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgIHdlYWtTZXREZWxldGUodHJhY2tlZCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc0Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0Vycm9ycyhwYXRoKSB7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLmVycm9yc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBfcmVmMiA9IHNsaWNlZFRvQXJyYXkoX3JlZiwgMSk7XG5cbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBfcmVmMlswXTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoUGF0aChwYXRoLCBjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVycm9yKHBhdGgsIGV4cGVjdGVkVHlwZSwgbWVzc2FnZSkge1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChbcGF0aCwgbWVzc2FnZSwgZXhwZWN0ZWRUeXBlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhckVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJFcnJvcihwYXRoKSB7XG4gICAgICB2YXIgZGlkQ2xlYXIgPSBmYWxzZTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBfZXJyb3JzID0gW107XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLmVycm9yc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hQYXRoKHBhdGgsIGVycm9yWzBdKSkge1xuICAgICAgICAgICAgICBkaWRDbGVhciA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lcnJvcnMgPSBfZXJyb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlkQ2xlYXIgPSB0aGlzLmVycm9ycy5sZW5ndGggPiAwO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZENsZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc29sdmVQYXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIF9yZXNvbHZlUGF0aCh0aGlzLmlucHV0LCBwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gbWFrZUpTT05FcnJvcih0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZhbGlkYXRpb247XG59KCk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhdGgocGF0aCkge1xuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdWYWx1ZSc7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHZhciBwYXJ0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXRoW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnW1tSZXR1cm4gVHlwZV1dJykge1xuICAgICAgcGFydHNbaV0gPSAnUmV0dXJuIFR5cGUnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnIHx8ICF2YWxpZElkZW50aWZpZXJPckFjY2Vzc29yLnRlc3QocGFydCkpIHtcbiAgICAgIHBhcnRzW2ldID0gYFske1N0cmluZyhwYXJ0KX1dYDtcbiAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICBwYXJ0c1tpXSA9IGAuJHtTdHJpbmcocGFydCl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHNbaV0gPSBTdHJpbmcocGFydCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVQYXRoKGlucHV0LCBwYXRoKSB7XG4gIHZhciBzdWJqZWN0ID0gaW5wdXQ7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHBhcnQgPSBwYXRoW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnW1tSZXR1cm4gVHlwZV1dJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdWJqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5nZXQocGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0W3BhcnRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3ViamVjdDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdGgsIGNhbmRpZGF0ZSkge1xuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA+IGNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChjYW5kaWRhdGVbaV0gIT09IHBhdGhbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSdW50aW1lVHlwZUVycm9yID0gZnVuY3Rpb24gKF9UeXBlRXJyb3IpIHtcbiAgaW5oZXJpdHMoUnVudGltZVR5cGVFcnJvciwgX1R5cGVFcnJvcik7XG5cbiAgZnVuY3Rpb24gUnVudGltZVR5cGVFcnJvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVudGltZVR5cGVFcnJvcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSdW50aW1lVHlwZUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUnVudGltZVR5cGVFcnJvcikpLmNhbGwodGhpcywgbWVzc2FnZSkpO1xuXG4gICAgX3RoaXMubmFtZSA9IFwiUnVudGltZVR5cGVFcnJvclwiO1xuXG4gICAgT2JqZWN0LmFzc2lnbihfdGhpcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFJ1bnRpbWVUeXBlRXJyb3I7XG59KFR5cGVFcnJvcik7XG5cbnZhciBkZWxpbWl0ZXIgPSAnXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbic7XG5cbmZ1bmN0aW9uIG1ha2VUeXBlRXJyb3IodmFsaWRhdGlvbikge1xuICBpZiAoIXZhbGlkYXRpb24uaGFzRXJyb3JzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZWZpeCA9IHZhbGlkYXRpb24ucHJlZml4LFxuICAgICAgaW5wdXQgPSB2YWxpZGF0aW9uLmlucHV0LFxuICAgICAgY29udGV4dCA9IHZhbGlkYXRpb24uY29udGV4dCxcbiAgICAgIGVycm9ycyA9IHZhbGlkYXRpb24uZXJyb3JzO1xuXG4gIHZhciBjb2xsZWN0ZWQgPSBbXTtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZXJyb3JzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCAzKTtcblxuICAgICAgdmFyIHBhdGggPSBfcmVmMlswXTtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjJbMV07XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gX3JlZjJbMl07XG5cbiAgICAgIHZhciBleHBlY3RlZCA9IGV4cGVjdGVkVHlwZSA/IGV4cGVjdGVkVHlwZS50b1N0cmluZygpIDogXCIqXCI7XG4gICAgICB2YXIgYWN0dWFsID0gX3Jlc29sdmVQYXRoKGlucHV0LCBwYXRoKTtcbiAgICAgIHZhciBhY3R1YWxUeXBlID0gY29udGV4dC50eXBlT2YoYWN0dWFsKS50b1N0cmluZygpO1xuXG4gICAgICB2YXIgZmllbGQgPSBzdHJpbmdpZnlQYXRoKHZhbGlkYXRpb24ucGF0aC5jb25jYXQocGF0aCkpO1xuXG4gICAgICB2YXIgYWN0dWFsQXNTdHJpbmcgPSBtYWtlU3RyaW5nKGFjdHVhbCk7XG5cbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsQXNTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbGxlY3RlZC5wdXNoKGAke2ZpZWxkfSAke21lc3NhZ2V9XFxuXFxuRXhwZWN0ZWQ6ICR7ZXhwZWN0ZWR9XFxuXFxuQWN0dWFsIFZhbHVlOiAke2FjdHVhbEFzU3RyaW5nfVxcblxcbkFjdHVhbCBUeXBlOiAke2FjdHVhbFR5cGV9XFxuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsZWN0ZWQucHVzaChgJHtmaWVsZH0gJHttZXNzYWdlfVxcblxcbkV4cGVjdGVkOiAke2V4cGVjdGVkfVxcblxcbkFjdHVhbDogJHthY3R1YWxUeXBlfVxcbmApO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJlZml4KSB7XG4gICAgcmV0dXJuIG5ldyBSdW50aW1lVHlwZUVycm9yKGAke3ByZWZpeC50cmltKCl9ICR7Y29sbGVjdGVkLmpvaW4oZGVsaW1pdGVyKX1gLCB7IGVycm9ycyB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFJ1bnRpbWVUeXBlRXJyb3IoY29sbGVjdGVkLmpvaW4oZGVsaW1pdGVyKSwgeyBlcnJvcnMgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICAvLyBJc3N1ZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUuY29uc3RydWN0b3IgPT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvcihleHBlY3RlZCwgaW5wdXQpIHtcbiAgdmFyIGNvbnRleHQgPSBleHBlY3RlZC5jb250ZXh0O1xuXG4gIHZhciB2YWxpZGF0aW9uID0gY29udGV4dC52YWxpZGF0ZShleHBlY3RlZCwgaW5wdXQpO1xuICByZXR1cm4gbWFrZVR5cGVFcnJvcih2YWxpZGF0aW9uKTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0d28gdHlwZXMsIEEgYW5kIEIsIGNvbXBhcmUgdGhlbSBhbmQgcmV0dXJuIGVpdGhlciAtMSwgMCwgb3IgMTpcbiAqXG4gKiAgIC0xIGlmIEEgY2Fubm90IGFjY2VwdCB0eXBlIEIuXG4gKlxuICogICAgMCBpZiB0aGUgdHlwZXMgYXJlIGVmZmVjdGl2ZWx5IGlkZW50aWNhbC5cbiAqXG4gKiAgICAxIGlmIEEgYWNjZXB0cyBldmVyeSBwb3NzaWJsZSBCLlxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZVR5cGVzKGEsIGIpIHtcbiAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcblxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGIgaW5zdGFuY2VvZiBUeXBlQWxpYXMgfHwgYiBpbnN0YW5jZW9mIFR5cGVQYXJhbWV0ZXIgfHwgYiBpbnN0YW5jZW9mIFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbiB8fCBiIGluc3RhbmNlb2YgVHlwZVREWikge1xuICAgIGIgPSBiLnVud3JhcCgpO1xuICB9XG5cbiAgaWYgKGEgaW5zdGFuY2VvZiBUeXBlQWxpYXMpIHtcbiAgICByZXN1bHQgPSBhLmNvbXBhcmVXaXRoKGIpO1xuICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBGbG93SW50b1R5cGUgfHwgYSBpbnN0YW5jZW9mIFR5cGVQYXJhbWV0ZXIgfHwgYiBpbnN0YW5jZW9mIEZsb3dJbnRvVHlwZSkge1xuICAgIHJlc3VsdCA9IGEuY29tcGFyZVdpdGgoYik7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFueVR5cGUgfHwgYSBpbnN0YW5jZW9mIEV4aXN0ZW50aWFsVHlwZSB8fCBhIGluc3RhbmNlb2YgTWl4ZWRUeXBlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYS5jb21wYXJlV2l0aChiKTtcbiAgfVxuXG4gIGlmIChiIGluc3RhbmNlb2YgQW55VHlwZSkge1xuICAgIC8vIE5vdGU6IFRoaXMgY2hlY2sgY2Fubm90IGJlIG1vdmVkIGhpZ2hlciBpbiB0aGUgc2NvcGUsXG4gICAgLy8gYXMgdGhpcyB3b3VsZCBwcmV2ZW50IHR5cGVzIGZyb20gYmVpbmcgcHJvcGFnYXRlZCB1cHdhcmRzLlxuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiAjIFR5cGVcbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMuXG4gKi9cbnZhciBUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUeXBlKGNvbnRleHQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlKTtcbiAgICB0aGlzLnR5cGVOYW1lID0gJ1R5cGUnO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge31cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IG5ldyBWYWxpZGF0aW9uKHRoaXMuY29udGV4dCwgaW5wdXQpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuZXJyb3JzKHZhbGlkYXRpb24sIFtdLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c1R5cGUoaW5wdXQpIHtcbiAgICAgIGlmIChjb21wYXJlVHlwZXModGhpcywgaW5wdXQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXNzZXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0KGlucHV0KSB7XG4gICAgICB2YXIgZXJyb3IgPSBtYWtlRXJyb3IodGhpcywgaW5wdXQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgdGhpcy5hc3NlcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnJFR5cGUnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZTtcbn0oKTtcblxudmFyIEFueVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoQW55VHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEFueVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQW55VHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBBbnlUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQW55VHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0FueVR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQW55VHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7fVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2FueSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBbnlUeXBlO1xufShUeXBlKTtcblxudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gIEVSUl9DT05TVFJBSU5UX1ZJT0xBVElPTjogJ3Zpb2xhdGVkIGEgY29uc3RyYWludCcsXG4gIEVSUl9FWFBFQ1RfQVJSQVk6ICdtdXN0IGJlIGFuIEFycmF5JyxcbiAgRVJSX0VYUEVDVF9UUlVFOiAnbXVzdCBiZSB0cnVlJyxcbiAgRVJSX0VYUEVDVF9GQUxTRTogJ211c3QgYmUgZmFsc2UnLFxuICBFUlJfRVhQRUNUX0JPT0xFQU46ICdtdXN0IGJlIHRydWUgb3IgZmFsc2UnLFxuICBFUlJfRVhQRUNUX0VNUFRZOiAnbXVzdCBiZSBlbXB0eScsXG4gIEVSUl9FWFBFQ1RfRVhBQ1RfVkFMVUU6ICdtdXN0IGJlIGV4YWN0bHkgJDAnLFxuICBFUlJfRVhQRUNUX0NBTExBQkxFOiAnbXVzdCBiZSBjYWxsYWJsZScsXG4gIEVSUl9FWFBFQ1RfQ0xBU1M6ICdtdXN0IGJlIGEgQ2xhc3Mgb2YgJDAnLFxuICBFUlJfRVhQRUNUX0ZVTkNUSU9OOiAnbXVzdCBiZSBhIGZ1bmN0aW9uJyxcbiAgRVJSX0VYUEVDVF9HRU5FUkFUT1I6ICdtdXN0IGJlIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uJyxcbiAgRVJSX0VYUEVDVF9JVEVSQUJMRTogJ211c3QgYmUgaXRlcmFibGUnLFxuICBFUlJfRVhQRUNUX0FSR1VNRU5UOiAnYXJndW1lbnQgXCIkMFwiIG11c3QgYmU6ICQxJyxcbiAgRVJSX0VYUEVDVF9SRVRVUk46ICdleHBlY3RlZCByZXR1cm4gdHlwZSBvZjogJDAnLFxuICBFUlJfRVhQRUNUX05fQVJHVU1FTlRTOiAncmVxdWlyZXMgJDAgYXJndW1lbnQocyknLFxuICBFUlJfRVhQRUNUX0lOU1RBTkNFT0Y6ICdtdXN0IGJlIGFuIGluc3RhbmNlIG9mICQwJyxcbiAgRVJSX0VYUEVDVF9LRVlfVFlQRTogJ2tleXMgbXVzdCBiZTogJDAnLFxuICBFUlJfRVhQRUNUX05VTEw6ICdtdXN0IGJlIG51bGwnLFxuICBFUlJfRVhQRUNUX05VTUJFUjogJ211c3QgYmUgYSBudW1iZXInLFxuICBFUlJfRVhQRUNUX09CSkVDVDogJ211c3QgYmUgYW4gb2JqZWN0JyxcbiAgRVJSX0VYUEVDVF9QUk9NSVNFOiAnbXVzdCBiZSBhIHByb21pc2Ugb2YgJDAnLFxuICBFUlJfRVhQRUNUX1NUUklORzogJ211c3QgYmUgYSBzdHJpbmcnLFxuICBFUlJfRVhQRUNUX1NZTUJPTDogJ211c3QgYmUgYSBzeW1ib2wnLFxuICBFUlJfRVhQRUNUX1RISVM6ICdtdXN0IGJlIGV4YWN0bHkgdGhpcycsXG4gIEVSUl9FWFBFQ1RfVk9JRDogJ211c3QgYmUgdW5kZWZpbmVkJyxcbiAgRVJSX0lOVkFMSURfREFURTogJ211c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgRVJSX01JU1NJTkdfUFJPUEVSVFk6ICdkb2VzIG5vdCBleGlzdCBvbiBvYmplY3QnLFxuICBFUlJfTk9fSU5ERVhFUjogJ2lzIG5vdCBvbmUgb2YgdGhlIHBlcm1pdHRlZCBpbmRleGVyIHR5cGVzJyxcbiAgRVJSX05PX1VOSU9OOiAnbXVzdCBiZSBvbmUgb2Y6ICQwJyxcbiAgRVJSX1VOS05PV05fS0VZOiAnc2hvdWxkIG5vdCBjb250YWluIHRoZSBrZXk6IFwiJDBcIidcbn07XG5cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShrZXkpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VzW2tleV07XG4gIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBtZXNzYWdlLnJlcGxhY2UoL1xcJChcXGQrKS9nLCBmdW5jdGlvbiAobSwgaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbXNbaV0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59XG5cbnZhciBUdXBsZVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHVwbGVUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVHVwbGVUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR1cGxlVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUdXBsZVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUdXBsZVR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUdXBsZVR5cGUnLCBfdGhpcy50eXBlcyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHVwbGVUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnQXJyYXknLCBpbnB1dCkpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9BUlJBWScpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB5aWVsZCogdHlwZXNbaV0uZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KGkpLCBpbnB1dFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSB8fCBpbnB1dC5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dFtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgVHVwbGVUeXBlKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGlucHV0VHlwZXMgPSBpbnB1dC50eXBlcztcbiAgICAgIGlmIChpbnB1dFR5cGVzLmxlbmd0aCA8IHR5cGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaXNHcmVhdGVyID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXModHlwZXNbaV0sIGlucHV0VHlwZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMubGVuZ3RoIDwgaW5wdXRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKGlzR3JlYXRlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYFske3RoaXMudHlwZXMuam9pbignLCAnKX1dYDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZXM6IHRoaXMudHlwZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUdXBsZVR5cGU7XG59KFR5cGUpO1xuXG52YXIgQXJyYXlUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEFycmF5VHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEFycmF5VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJheVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gQXJyYXlUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXJyYXlUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnQXJyYXlUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEFycmF5VHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0FSUkFZJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGlvbi5pbkN5Y2xlKHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YWxpZGF0aW9uLnN0YXJ0Q3ljbGUodGhpcywgaW5wdXQpO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy5lbGVtZW50VHlwZTtcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB5aWVsZCogZWxlbWVudFR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KGkpLCBpbnB1dFtpXSk7XG4gICAgICB9XG4gICAgICB2YWxpZGF0aW9uLmVuZEN5Y2xlKHRoaXMsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnQXJyYXknLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGluVmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0VmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHRoaXMuZWxlbWVudFR5cGU7XG4gICAgICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZWxlbWVudFR5cGUuYWNjZXB0cyhpbnB1dFtpXSkpIHtcbiAgICAgICAgICBlbmRWYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kVmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHRoaXMuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFR1cGxlVHlwZSkge1xuICAgICAgICB2YXIgdHlwZXMgPSBpbnB1dC50eXBlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyhlbGVtZW50VHlwZSwgdHlwZXNbaV0pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5VHlwZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGVsZW1lbnRUeXBlLCBpbnB1dC5lbGVtZW50VHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHRoaXMuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChpblRvU3RyaW5nQ3ljbGUodGhpcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBgQXJyYXk8JEN5Y2xlPCR7ZWxlbWVudFR5cGUubmFtZX0+PmA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBBcnJheTwkQ3ljbGU8T2JqZWN0Pj5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFydFRvU3RyaW5nQ3ljbGUodGhpcyk7XG4gICAgICB2YXIgb3V0cHV0ID0gYEFycmF5PCR7ZWxlbWVudFR5cGUudG9TdHJpbmcoKX0+YDtcbiAgICAgIGVuZFRvU3RyaW5nQ3ljbGUodGhpcyk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBlbGVtZW50VHlwZTogdGhpcy5lbGVtZW50VHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFycmF5VHlwZTtcbn0oVHlwZSk7XG5cbnZhciBCb29sZWFuTGl0ZXJhbFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkxpdGVyYWxUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWxUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5MaXRlcmFsVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBCb29sZWFuTGl0ZXJhbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuTGl0ZXJhbFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdCb29sZWFuTGl0ZXJhbFR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQm9vbGVhbkxpdGVyYWxUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKHRoaXMudmFsdWUgPyAnRVJSX0VYUEVDVF9UUlVFJyA6ICdFUlJfRVhQRUNUX0ZBTFNFJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgPT09IHRoaXMudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQm9vbGVhbkxpdGVyYWxUeXBlICYmIGlucHV0LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb29sZWFuTGl0ZXJhbFR5cGU7XG59KFR5cGUpO1xuXG52YXIgQm9vbGVhblR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoQm9vbGVhblR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBCb29sZWFuVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBCb29sZWFuVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5UeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnQm9vbGVhblR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQm9vbGVhblR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQk9PTEVBTicpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEJvb2xlYW5MaXRlcmFsVHlwZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCb29sZWFuVHlwZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2xlYW5UeXBlO1xufShUeXBlKTtcblxudmFyIEVtcHR5VHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhFbXB0eVR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBFbXB0eVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1wdHlUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEVtcHR5VHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtcHR5VHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0VtcHR5VHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhFbXB0eVR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9FTVBUWScpLCB0aGlzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlbXB0eSB0eXBlcyBhY2NlcHRzIG5vdGhpbmcuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRW1wdHlUeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2VtcHR5JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVtcHR5VHlwZTtcbn0oVHlwZSk7XG5cbnZhciBFeGlzdGVudGlhbFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRXhpc3RlbnRpYWxUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gRXhpc3RlbnRpYWxUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEV4aXN0ZW50aWFsVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBFeGlzdGVudGlhbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFeGlzdGVudGlhbFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdFeGlzdGVudGlhbFR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRXhpc3RlbnRpYWxUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFeGlzdGVudGlhbFR5cGU7XG59KFR5cGUpO1xuXG4vKipcbiAqICMgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uXG4gKlxuICovXG52YXIgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbiwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uJywgX3RoaXMudHlwZUluc3RhbmNlcyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICB0eXBlSW5zdGFuY2VzID0gdGhpcy50eXBlSW5zdGFuY2VzO1xuXG4gICAgICB5aWVsZCogcGFyZW50LmVycm9ycy5hcHBseShwYXJlbnQsIFt2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dF0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICB0eXBlSW5zdGFuY2VzID0gdGhpcy50eXBlSW5zdGFuY2VzO1xuXG4gICAgICByZXR1cm4gcGFyZW50LmFjY2VwdHMuYXBwbHkocGFyZW50LCBbaW5wdXRdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHZhciBfcGFyZW50O1xuXG4gICAgICByZXR1cm4gKF9wYXJlbnQgPSB0aGlzLnBhcmVudCkuY29tcGFyZVdpdGguYXBwbHkoX3BhcmVudCwgW2lucHV0XS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodGhpcy50eXBlSW5zdGFuY2VzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy5wYXJlbnQ7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmhhc1Byb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICByZXR1cm4gKF9yZWYyID0gaW5uZXIpLmhhc1Byb3BlcnR5LmFwcGx5KF9yZWYyLCBbbmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHRoaXMudHlwZUluc3RhbmNlcykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBpbm5lciA9IHRoaXMucGFyZW50O1xuICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lci5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX3JlZjM7XG5cbiAgICAgICAgcmV0dXJuIChfcmVmMyA9IGlubmVyKS5nZXRQcm9wZXJ0eS5hcHBseShfcmVmMywgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0aGlzLnR5cGVJbnN0YW5jZXMpKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIF9wYXJlbnQyO1xuXG4gICAgICByZXR1cm4gKF9wYXJlbnQyID0gdGhpcy5wYXJlbnQpLnVud3JhcC5hcHBseShfcGFyZW50MiwgdG9Db25zdW1hYmxlQXJyYXkodGhpcy50eXBlSW5zdGFuY2VzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICB0eXBlSW5zdGFuY2VzID0gdGhpcy50eXBlSW5zdGFuY2VzO1xuICAgICAgdmFyIG5hbWUgPSBwYXJlbnQubmFtZTtcblxuICAgICAgaWYgKHR5cGVJbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHlwZUluc3RhbmNlID0gdHlwZUluc3RhbmNlc1tpXTtcbiAgICAgICAgICBpdGVtcy5wdXNoKHR5cGVJbnN0YW5jZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmFtZX08JHtpdGVtcy5qb2luKCcsICcpfT5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGVJbnN0YW5jZXM6IHRoaXMudHlwZUluc3RhbmNlc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbjtcbn0oVHlwZSk7XG5cbi8qKlxuICogQWRkIGNvbnN0cmFpbnRzIHRvIHRoZSBnaXZlbiBzdWJqZWN0IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGFkZENvbnN0cmFpbnRzKHN1YmplY3QpIHtcbiAgdmFyIF9zdWJqZWN0JGNvbnN0cmFpbnRzO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjb25zdHJhaW50cyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBjb25zdHJhaW50c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICAoX3N1YmplY3QkY29uc3RyYWludHMgPSBzdWJqZWN0LmNvbnN0cmFpbnRzKS5wdXNoLmFwcGx5KF9zdWJqZWN0JGNvbnN0cmFpbnRzLCB0b0NvbnN1bWFibGVBcnJheShjb25zdHJhaW50cykpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgYW55IGVycm9ycyBmcm9tIGNvbnN0cmFpbnRzIG9uIHRoZSBnaXZlbiBzdWJqZWN0IHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiogY29sbGVjdENvbnN0cmFpbnRFcnJvcnMoc3ViamVjdCwgdmFsaWRhdGlvbiwgcGF0aCkge1xuICB2YXIgY29uc3RyYWludHMgPSBzdWJqZWN0LmNvbnN0cmFpbnRzO1xuICB2YXIgbGVuZ3RoID0gY29uc3RyYWludHMubGVuZ3RoO1xuXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaW5wdXQgPSBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgaW5wdXRbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcbiAgICB2YXIgdmlvbGF0aW9uID0gY29uc3RyYWludC5hcHBseSh1bmRlZmluZWQsIHRvQ29uc3VtYWJsZUFycmF5KGlucHV0KSk7XG4gICAgaWYgKHR5cGVvZiB2aW9sYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB5aWVsZCBbcGF0aCwgdmlvbGF0aW9uLCB0aGlzXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXQgcGFzc2VzIHRoZSBjb25zdHJhaW50cyBvbiB0aGUgc3ViamVjdCB0eXBlLlxuICovXG5mdW5jdGlvbiBjb25zdHJhaW50c0FjY2VwdChzdWJqZWN0KSB7XG4gIHZhciBjb25zdHJhaW50cyA9IHN1YmplY3QuY29uc3RyYWludHM7XG4gIHZhciBsZW5ndGggPSBjb25zdHJhaW50cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBpbnB1dCA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBpbnB1dFtfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuICAgIGlmICh0eXBlb2YgY29uc3RyYWludC5hcHBseSh1bmRlZmluZWQsIHRvQ29uc3VtYWJsZUFycmF5KGlucHV0KSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgVHlwZUFsaWFzID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVBbGlhcywgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVBbGlhcygpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlQWxpYXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZUFsaWFzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZUFsaWFzKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVHlwZUFsaWFzJywgX3RoaXMuY29uc3RyYWludHMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVBbGlhcywgW3tcbiAgICBrZXk6ICdhZGRDb25zdHJhaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29uc3RyYWludCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgY29uc3RyYWludHMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBjb25zdHJhaW50c1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBhZGRDb25zdHJhaW50cy5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY29uc3RyYWludHMpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgeWllbGQgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0Vycm9ycykge1xuICAgICAgICB5aWVsZCogY29sbGVjdENvbnN0cmFpbnRFcnJvcnModGhpcywgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgaWYgKCF0eXBlLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnN0cmFpbnRzQWNjZXB0KHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIHNob3VsZCBuZXZlciBuZWVkIHRoaXMgYmVjYXVzZSBpdCdzIHRha2VuIGNhcmUgb2YgYnkgY29tcGFyZVR5cGVzLlxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgY29uc3RyYWludHMgdGhlIHR5cGVzIGNhbm5vdCBiZSB0aGUgc2FtZVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcCgpO1xuICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lci5oYXNQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5uZXIuaGFzUHJvcGVydHkobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcCgpO1xuICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lci5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5uZXIuZ2V0UHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmICh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGB0eXBlICR7bmFtZX0gPSAke3R5cGUudG9TdHJpbmcoKX07YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUucHJvcGVydGllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNDb25zdHJhaW50cycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZUFsaWFzO1xufShUeXBlKTtcblxudmFyIEZsb3dJbnRvU3ltYm9sID0gU3ltYm9sKCdGbG93SW50bycpO1xuXG4vKipcbiAqICMgVHlwZVBhcmFtZXRlclxuICpcbiAqIFR5cGUgcGFyYW1ldGVycyBhbGxvdyBwb2x5bW9ycGhpYyB0eXBlIHNhZmV0eS5cbiAqIFRoZSBmaXJzdCB0aW1lIGEgdHlwZSBwYXJhbWV0ZXIgaXMgY2hlY2tlZCwgaXQgcmVjb3JkcyB0aGUgc2hhcGUgb2YgaXRzIGlucHV0LFxuICogdGhpcyByZWNvcmRlZCBzaGFwZSBpcyB1c2VkIHRvIGNoZWNrIGFsbCBmdXR1cmUgaW5wdXRzIGZvciB0aGlzIHBhcnRpY3VsYXIgaW5zdGFuY2UuXG4gKi9cblxudmFyIFR5cGVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHlwZVBhcmFtZXRlciwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVQYXJhbWV0ZXIoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZVBhcmFtZXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlUGFyYW1ldGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZVBhcmFtZXRlcikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R5cGVQYXJhbWV0ZXInLCBfdGhpc1tGbG93SW50b1N5bWJvbF0gPSBudWxsLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICBjcmVhdGVDbGFzcyhUeXBlUGFyYW1ldGVyLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBib3VuZE9yRGVmYXVsdCA9IHRoaXMuYm91bmQgfHwgdGhpcy5kZWZhdWx0O1xuICAgICAgdmFyIHJlY29yZGVkID0gdGhpcy5yZWNvcmRlZCxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cbiAgICAgIGlmIChib3VuZE9yRGVmYXVsdCBpbnN0YW5jZW9mIEZsb3dJbnRvVHlwZSB8fCBib3VuZE9yRGVmYXVsdCBpbnN0YW5jZW9mIFR5cGVBbGlhcykge1xuICAgICAgICAvLyBXZSBkZWZlciB0byB0aGUgb3RoZXIgdHlwZSBwYXJhbWV0ZXIgc28gdGhhdCB2YWx1ZXMgZnJvbSB0aGlzXG4gICAgICAgIC8vIG9uZSBjYW4gZmxvdyBcInVwd2FyZHNcIi5cbiAgICAgICAgeWllbGQqIGJvdW5kT3JEZWZhdWx0LmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkZWQpIHtcbiAgICAgICAgLy8gd2UndmUgYWxyZWFkeSByZWNvcmRlZCBhIHZhbHVlIGZvciB0aGlzIHR5cGUgcGFyYW1ldGVyXG4gICAgICAgIHlpZWxkKiByZWNvcmRlZC5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kT3JEZWZhdWx0KSB7XG4gICAgICAgIGlmIChib3VuZE9yRGVmYXVsdC50eXBlTmFtZSA9PT0gJ0FueVR5cGUnIHx8IGJvdW5kT3JEZWZhdWx0LnR5cGVOYW1lID09PSAnRXhpc3RlbnRpYWxUeXBlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBib3VuZE9yRGVmYXVsdC5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVjb3JkZWQgPSBjb250ZXh0LnR5cGVPZihpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBib3VuZE9yRGVmYXVsdCA9IHRoaXMuYm91bmQgfHwgdGhpcy5kZWZhdWx0O1xuICAgICAgdmFyIHJlY29yZGVkID0gdGhpcy5yZWNvcmRlZCxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAoYm91bmRPckRlZmF1bHQgaW5zdGFuY2VvZiBGbG93SW50b1R5cGUgfHwgYm91bmRPckRlZmF1bHQgaW5zdGFuY2VvZiBUeXBlQWxpYXMpIHtcbiAgICAgICAgLy8gV2UgZGVmZXIgdG8gdGhlIG90aGVyIHR5cGUgcGFyYW1ldGVyIHNvIHRoYXQgdmFsdWVzIGZyb20gdGhpc1xuICAgICAgICAvLyBvbmUgY2FuIGZsb3cgXCJ1cHdhcmRzXCIuXG4gICAgICAgIHJldHVybiBib3VuZE9yRGVmYXVsdC5hY2NlcHRzKGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZGVkLmFjY2VwdHMoaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmIChib3VuZE9yRGVmYXVsdCkge1xuICAgICAgICBpZiAoYm91bmRPckRlZmF1bHQudHlwZU5hbWUgPT09IFwiQW55VHlwZVwiIHx8IGJvdW5kT3JEZWZhdWx0LnR5cGVOYW1lID09PSBcIkV4aXN0ZW50aWFsVHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWJvdW5kT3JEZWZhdWx0LmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVjb3JkZWQgPSBjb250ZXh0LnR5cGVPZihpbnB1dCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgYm91bmRPckRlZmF1bHQgPSB0aGlzLmJvdW5kIHx8IHRoaXMuZGVmYXVsdDtcbiAgICAgIHZhciByZWNvcmRlZCA9IHRoaXMucmVjb3JkZWQ7XG5cbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFR5cGVQYXJhbWV0ZXIpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgYHJlY29yZGVkYCBvciBgYm91bmRgIGZpZWxkc1xuICAgICAgICAvLyBiZWNhdXNlIHRoZSBpbnB1dCBoYXMgYWxyZWFkeSBiZWVuIHVud3JhcHBlZCwgc29cbiAgICAgICAgLy8gaWYgd2UgZ290IGEgdHlwZSBwYXJhbWV0ZXIgaXQgbXVzdCBiZSB0b3RhbGx5IGdlbmVyaWMgYW5kXG4gICAgICAgIC8vIHdlIHRyZWF0IGl0IGxpa2UgQW55LlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyhyZWNvcmRlZCwgaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmIChib3VuZE9yRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGJvdW5kT3JEZWZhdWx0LCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIGdlbmVyaWMgdHlwZSBwYXJhbWV0ZXIgYWNjZXB0cyBhbnkgaW5wdXQuXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIGJvdW5kT3JEZWZhdWx0ID0gdGhpcy5ib3VuZCB8fCB0aGlzLmRlZmF1bHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0aGlzLnJlY29yZGVkO1xuXG4gICAgICBpZiAocmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZGVkLnVud3JhcCgpO1xuICAgICAgfSBlbHNlIGlmIChib3VuZE9yRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gYm91bmRPckRlZmF1bHQudW53cmFwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHdpdGhCaW5kaW5nKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLmlkLFxuICAgICAgICAgIGJvdW5kID0gdGhpcy5ib3VuZCxcbiAgICAgICAgICBkZWZhdWx0VHlwZSA9IHRoaXMuZGVmYXVsdDtcblxuICAgICAgaWYgKHdpdGhCaW5kaW5nKSB7XG4gICAgICAgIGlmIChkZWZhdWx0VHlwZSkge1xuICAgICAgICAgIHJldHVybiBgJHtpZH0gPSAke2RlZmF1bHRUeXBlLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChib3VuZCkge1xuICAgICAgICAgIHJldHVybiBgJHtpZH06ICR7Ym91bmQudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgcmVjb3JkZWQ6IHRoaXMucmVjb3JkZWRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlUGFyYW1ldGVyO1xufShUeXBlKTtcblxuZnVuY3Rpb24gZmxvd0ludG9UeXBlUGFyYW1ldGVyKHR5cGVQYXJhbWV0ZXIpIHtcbiAgdmFyIGV4aXN0aW5nID0gdHlwZVBhcmFtZXRlcltGbG93SW50b1N5bWJvbF07XG4gIGlmIChleGlzdGluZykge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBuZXcgRmxvd0ludG9UeXBlKHR5cGVQYXJhbWV0ZXIuY29udGV4dCk7XG4gIHRhcmdldC50eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcjtcbiAgdHlwZVBhcmFtZXRlcltGbG93SW50b1N5bWJvbF0gPSB0YXJnZXQ7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogIyBGbG93SW50b1R5cGVcbiAqXG4gKiBBIHZpcnR1YWwgdHlwZSB3aGljaCBhbGxvd3MgdHlwZXMgaXQgcmVjZWl2ZXMgdG8gXCJmbG93XCIgdXB3YXJkcyBpbnRvIGEgdHlwZSBwYXJhbWV0ZXIuXG4gKiBUaGUgdHlwZSBwYXJhbWV0ZXIgd2lsbCBiZWNvbWUgb2YgYSB1bmlvbiBvZiBhbnkgdHlwZXMgc2VlbiBieSB0aGlzIGluc3RhbmNlLlxuICovXG5cbnZhciBGbG93SW50b1R5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRmxvd0ludG9UeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gRmxvd0ludG9UeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3dJbnRvVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBGbG93SW50b1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGbG93SW50b1R5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdGbG93SW50b1R5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRmxvd0ludG9UeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdGhpcy50eXBlUGFyYW1ldGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0eXBlUGFyYW1ldGVyLnJlY29yZGVkLFxuICAgICAgICAgIGJvdW5kID0gdHlwZVBhcmFtZXRlci5ib3VuZDtcblxuXG4gICAgICBpZiAoYm91bmQgaW5zdGFuY2VvZiBGbG93SW50b1R5cGUpIHtcbiAgICAgICAgLy8gV2UgZGVmZXIgdG8gdGhlIG90aGVyIHR5cGUgc28gdGhhdCB2YWx1ZXMgZnJvbSB0aGlzXG4gICAgICAgIC8vIG9uZSBjYW4gZmxvdyBcInVwd2FyZHNcIi5cbiAgICAgICAgeWllbGQqIGJvdW5kLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmRlZCkge1xuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIGEgdmFsdWUgZm9yIHRoaXMgdHlwZSBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBib3VuZC5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZC5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIC8vIG91ciBleGlzdGluZyB0eXBlIGFscmVhZHkgcGVybWl0cyB0aGlzIHZhbHVlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBhIHVuaW9uXG4gICAgICAgICAgdHlwZVBhcmFtZXRlci5yZWNvcmRlZCA9IGNvbnRleHQudW5pb24ocmVjb3JkZWQsIGNvbnRleHQudHlwZU9mKGlucHV0KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kKSB7XG4gICAgICAgIGlmIChib3VuZC50eXBlTmFtZSA9PT0gJ0FueVR5cGUnIHx8IGJvdW5kLnR5cGVOYW1lID09PSAnRXhpc3RlbnRpYWxUeXBlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2hhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gYm91bmQuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgX2Vycm9yID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgIHlpZWxkIF9lcnJvcjtcbiAgICAgICAgICAgICAgX2hhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9oYXNFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0eXBlUGFyYW1ldGVyLnJlY29yZGVkID0gY29udGV4dC50eXBlT2YoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHRoaXMudHlwZVBhcmFtZXRlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIHJlY29yZGVkID0gdHlwZVBhcmFtZXRlci5yZWNvcmRlZCxcbiAgICAgICAgICBib3VuZCA9IHR5cGVQYXJhbWV0ZXIuYm91bmQ7XG5cblxuICAgICAgaWYgKGJvdW5kIGluc3RhbmNlb2YgRmxvd0ludG9UeXBlKSB7XG4gICAgICAgIC8vIFdlIGRlZmVyIHRvIHRoZSBvdGhlciB0eXBlIHNvIHRoYXQgdmFsdWVzIGZyb20gdGhpc1xuICAgICAgICAvLyBvbmUgY2FuIGZsb3cgXCJ1cHdhcmRzXCIuXG4gICAgICAgIHJldHVybiBib3VuZC5hY2NlcHRzKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmRlZCkge1xuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIGEgdmFsdWUgZm9yIHRoaXMgdHlwZSBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKGJvdW5kICYmICFib3VuZC5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZC5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIC8vIG91ciBleGlzdGluZyB0eXBlIGFscmVhZHkgcGVybWl0cyB0aGlzIHZhbHVlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGEgdW5pb25cbiAgICAgICAgICB0eXBlUGFyYW1ldGVyLnJlY29yZGVkID0gY29udGV4dC51bmlvbihyZWNvcmRlZCwgY29udGV4dC50eXBlT2YoaW5wdXQpKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChib3VuZCkge1xuICAgICAgICBpZiAoYm91bmQudHlwZU5hbWUgPT09ICdBbnlUeXBlJyB8fCBib3VuZC50eXBlTmFtZSA9PT0gJ0V4aXN0ZW50aWFsVHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghYm91bmQuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHlwZVBhcmFtZXRlci5yZWNvcmRlZCA9IGNvbnRleHQudHlwZU9mKGlucHV0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdGhpcy50eXBlUGFyYW1ldGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0eXBlUGFyYW1ldGVyLnJlY29yZGVkLFxuICAgICAgICAgIGJvdW5kID0gdHlwZVBhcmFtZXRlci5ib3VuZDtcblxuICAgICAgaWYgKGJvdW5kIGluc3RhbmNlb2YgRmxvd0ludG9UeXBlKSB7XG4gICAgICAgIC8vIFdlIGRlZmVyIHRvIHRoZSBvdGhlciB0eXBlIHNvIHRoYXQgdmFsdWVzIGZyb20gdGhpc1xuICAgICAgICAvLyBvbmUgY2FuIGZsb3cgXCJ1cHdhcmRzXCIuXG4gICAgICAgIHJldHVybiBib3VuZC5jb21wYXJlV2l0aChpbnB1dCk7XG4gICAgICB9XG4gICAgICBpZiAocmVjb3JkZWQpIHtcbiAgICAgICAgaWYgKGJvdW5kICYmIGNvbXBhcmVUeXBlcyhib3VuZCwgaW5wdXQpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHJlY29yZGVkLCBpbnB1dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAvLyBvdXIgZXhpc3RpbmcgdHlwZSBhbHJlYWR5IHBlcm1pdHMgdGhpcyB2YWx1ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBhIHVuaW9uXG4gICAgICAgIHR5cGVQYXJhbWV0ZXIucmVjb3JkZWQgPSBjb250ZXh0LnVuaW9uKHJlY29yZGVkLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChib3VuZCkge1xuICAgICAgICBpZiAoYm91bmQudHlwZU5hbWUgPT09ICdBbnlUeXBlJyB8fCBib3VuZC50eXBlTmFtZSA9PT0gJ0V4aXN0ZW50aWFsVHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Jlc3VsdCA9IGNvbXBhcmVUeXBlcyhib3VuZCwgaW5wdXQpO1xuICAgICAgICBpZiAoX3Jlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHlwZVBhcmFtZXRlci5yZWNvcmRlZCA9IGlucHV0O1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlUGFyYW1ldGVyLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcod2l0aEJpbmRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVQYXJhbWV0ZXIudG9TdHJpbmcod2l0aEJpbmRpbmcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVQYXJhbWV0ZXIudG9KU09OKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGbG93SW50b1R5cGU7XG59KFR5cGUpO1xuXG52YXIgRnVuY3Rpb25UeXBlUmVzdFBhcmFtID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvblR5cGVSZXN0UGFyYW0pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gRnVuY3Rpb25UeXBlUmVzdFBhcmFtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25UeXBlUmVzdFBhcmFtKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnRnVuY3Rpb25UeXBlUmVzdFBhcmFtJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgeWllbGQqIHR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiB0eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVBhcmFtIHx8IGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUmVzdFBhcmFtKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dC50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICByZXR1cm4gYC4uLiR7dGhpcy5uYW1lfTogJHt0eXBlLnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvblR5cGVSZXN0UGFyYW07XG59KFR5cGUpO1xuXG52YXIgRnVuY3Rpb25UeXBlUGFyYW0gPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRnVuY3Rpb25UeXBlUGFyYW0sIF9UeXBlKTtcblxuICBmdW5jdGlvbiBGdW5jdGlvblR5cGVQYXJhbSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvblR5cGVQYXJhbSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBGdW5jdGlvblR5cGVQYXJhbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uVHlwZVBhcmFtKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnRnVuY3Rpb25UeXBlUGFyYW0nLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25UeXBlUGFyYW0sIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIG9wdGlvbmFsID0gdGhpcy5vcHRpb25hbCxcbiAgICAgICAgICB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAob3B0aW9uYWwgJiYgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCogdHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmIChvcHRpb25hbCAmJiBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUGFyYW0gfHwgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGVSZXN0UGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0LnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIG9wdGlvbmFsID0gdGhpcy5vcHRpb25hbCxcbiAgICAgICAgICB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSR7b3B0aW9uYWwgPyAnPycgOiAnJ306ICR7dHlwZS50b1N0cmluZygpfWA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uYWw6IHRoaXMub3B0aW9uYWwsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uVHlwZVBhcmFtO1xufShUeXBlKTtcblxudmFyIEZ1bmN0aW9uVHlwZVJldHVybiA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhGdW5jdGlvblR5cGVSZXR1cm4sIF9UeXBlKTtcblxuICBmdW5jdGlvbiBGdW5jdGlvblR5cGVSZXR1cm4oKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25UeXBlUmV0dXJuKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEZ1bmN0aW9uVHlwZVJldHVybi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uVHlwZVJldHVybikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0Z1bmN0aW9uVHlwZVJldHVybicsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhGdW5jdGlvblR5cGVSZXR1cm4sIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHlpZWxkKiB0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLmNvbmNhdCgnW1tSZXR1cm4gVHlwZV1dJyksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiB0eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVJldHVybikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICByZXR1cm4gdHlwZS50b1N0cmluZygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvblR5cGVSZXR1cm47XG59KFR5cGUpO1xuXG52YXIgUGFyZW50U3ltYm9sID0gU3ltYm9sKCdQYXJlbnQnKTtcbnZhciBOYW1lUmVnaXN0cnlTeW1ib2wgPSBTeW1ib2woJ05hbWVSZWdpc3RyeScpO1xudmFyIE1vZHVsZVJlZ2lzdHJ5U3ltYm9sID0gU3ltYm9sKCdNb2R1bGVSZWdpc3RyeScpO1xudmFyIEN1cnJlbnRNb2R1bGVTeW1ib2wgPSBTeW1ib2woJ0N1cnJlbnRNb2R1bGUnKTtcbnZhciBUeXBlQ29uc3RydWN0b3JSZWdpc3RyeVN5bWJvbCA9IFN5bWJvbCgnVHlwZUNvbnN0cnVjdG9yUmVnaXN0cnknKTtcbnZhciBJbmZlcnJlclN5bWJvbCA9IFN5bWJvbCgnSW5mZXJyZXInKTtcblxuXG52YXIgVHlwZVN5bWJvbCA9IFN5bWJvbCgnVHlwZScpO1xudmFyIFR5cGVQYXJhbWV0ZXJzU3ltYm9sID0gU3ltYm9sKCdUeXBlUGFyYW1ldGVycycpO1xudmFyIFR5cGVQcmVkaWNhdGVSZWdpc3RyeVN5bWJvbCA9IFN5bWJvbCgnVHlwZVByZWRpY2F0ZVJlZ2lzdHJ5Jyk7XG5cbnZhciBGdW5jdGlvblR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRnVuY3Rpb25UeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gRnVuY3Rpb25UeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBGdW5jdGlvblR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvblR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdGdW5jdGlvblR5cGUnLCBfdGhpcy5wYXJhbXMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEZ1bmN0aW9uVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfRlVOQ1RJT04nKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhbm5vdGF0aW9uID0gaW5wdXRbVHlwZVN5bWJvbF07XG4gICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMucmV0dXJuVHlwZSxcbiAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcztcblxuICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9uLnBhcmFtcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgICB2YXIgYW5ub3RhdGlvblBhcmFtID0gYW5ub3RhdGlvbi5wYXJhbXNbaV07XG4gICAgICAgICAgaWYgKCFhbm5vdGF0aW9uUGFyYW0gJiYgIXBhcmFtLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0FSR1VNRU5UJywgcGFyYW0ubmFtZSwgcGFyYW0udHlwZS50b1N0cmluZygpKSwgdGhpc107XG4gICAgICAgICAgfSBlbHNlIGlmICghcGFyYW0uYWNjZXB0c1R5cGUoYW5ub3RhdGlvblBhcmFtKSkge1xuICAgICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9BUkdVTUVOVCcsIHBhcmFtLm5hbWUsIHBhcmFtLnR5cGUudG9TdHJpbmcoKSksIHRoaXNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJldHVyblR5cGUuYWNjZXB0c1R5cGUoYW5ub3RhdGlvbi5yZXR1cm5UeXBlKSkge1xuICAgICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfUkVUVVJOJywgcmV0dXJuVHlwZS50b1N0cmluZygpKSwgdGhpc107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAvLyBXZSBjYW5ub3Qgc2FmZWx5IGNoZWNrIGFuIHVuYW5ub3RhdGVkIGZ1bmN0aW9uLlxuICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBwcm9wYWdhdGUgYGFueWAgdHlwZSBmZWVkYmFjayB1cHdhcmRzLlxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwYXJhbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9wYXJhbSA9IHBhcmFtc1tfaV07XG4gICAgICAgICAgX3BhcmFtLmFjY2VwdHNUeXBlKGNvbnRleHQuYW55KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblR5cGUuYWNjZXB0c1R5cGUoY29udGV4dC5hbnkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblR5cGUgPSB0aGlzLnJldHVyblR5cGUsXG4gICAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIHZhciBhbm5vdGF0aW9uID0gaW5wdXRbVHlwZVN5bWJvbF07XG4gICAgICBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoIWFubm90YXRpb24ucGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgdmFyIGFubm90YXRpb25QYXJhbSA9IGFubm90YXRpb24ucGFyYW1zW2ldO1xuICAgICAgICAgIGlmICghYW5ub3RhdGlvblBhcmFtICYmICFwYXJhbS5vcHRpb25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXBhcmFtLmFjY2VwdHNUeXBlKGFubm90YXRpb25QYXJhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXR1cm5UeXBlLmFjY2VwdHNUeXBlKGFubm90YXRpb24ucmV0dXJuVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgLy8gV2UgY2Fubm90IHNhZmVseSBjaGVjayBhbiB1bmFubm90YXRlZCBmdW5jdGlvbi5cbiAgICAgICAgLy8gQnV0IHdlIG5lZWQgdG8gcHJvcGFnYXRlIGBhbnlgIHR5cGUgZmVlZGJhY2sgdXB3YXJkcy5cblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJhbXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfcGFyYW0yID0gcGFyYW1zW19pMl07XG4gICAgICAgICAgX3BhcmFtMi5hY2NlcHRzVHlwZShjb250ZXh0LmFueSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5UeXBlLmFjY2VwdHNUeXBlKGNvbnRleHQuYW55KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblR5cGUgPSB0aGlzLnJldHVyblR5cGU7XG4gICAgICB2YXIgaW5wdXRSZXR1cm5UeXBlID0gaW5wdXQucmV0dXJuVHlwZTtcbiAgICAgIHZhciBpc0dyZWF0ZXIgPSBmYWxzZTtcbiAgICAgIHZhciByZXR1cm5UeXBlUmVzdWx0ID0gY29tcGFyZVR5cGVzKHJldHVyblR5cGUsIGlucHV0UmV0dXJuVHlwZSk7XG4gICAgICBpZiAocmV0dXJuVHlwZVJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5UeXBlUmVzdWx0ID09PSAxKSB7XG4gICAgICAgIGlzR3JlYXRlciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHZhciBpbnB1dFBhcmFtcyA9IGlucHV0LnBhcmFtcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgdmFyIGlucHV0UGFyYW0gPSBpID49IGlucHV0UGFyYW1zLmxlbmd0aCA/IGlucHV0LnJlc3QgOiBpbnB1dFBhcmFtc1tpXTtcbiAgICAgICAgaWYgKGlucHV0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHBhcmFtLCBpbnB1dFBhcmFtKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzR3JlYXRlciA/IDEgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNQYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzUGFyYW1zKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuICAgICAgICAgIHJlc3QgPSB0aGlzLnJlc3Q7XG5cbiAgICAgIHZhciBwYXJhbXNMZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgaWYgKGkgPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwYXJhbS5hY2NlcHRzKGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwYXJhbS5hY2NlcHRzKHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3NMZW5ndGggPiBwYXJhbXNMZW5ndGggJiYgcmVzdCkge1xuICAgICAgICBmb3IgKHZhciBfaTMgPSBwYXJhbXNMZW5ndGg7IF9pMyA8IGFyZ3NMZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgaWYgKCFyZXN0LmFjY2VwdHMoYXJnc1tfaTNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzUmV0dXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c1JldHVybihpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuVHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRQYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnRQYXJhbXMoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICAgICAgcmVzdCA9IHRoaXMucmVzdDtcblxuICAgICAgdmFyIHBhcmFtc0xlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICBpZiAoaSA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICBwYXJhbS5hc3NlcnQoYXJnc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW0uYXNzZXJ0KHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3NMZW5ndGggPiBwYXJhbXNMZW5ndGggJiYgcmVzdCkge1xuICAgICAgICBmb3IgKHZhciBfaTQgPSBwYXJhbXNMZW5ndGg7IF9pNCA8IGFyZ3NMZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgcmVzdC5hc3NlcnQoYXJnc1tfaTRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRSZXR1cm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnRSZXR1cm4oaW5wdXQpIHtcbiAgICAgIHRoaXMucmV0dXJuVHlwZS5hc3NlcnQoaW5wdXQpO1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ludm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludm9rZSgpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcyxcbiAgICAgICAgICByZXN0ID0gdGhpcy5yZXN0LFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciBwYXJhbXNMZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgaWYgKGkgPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwYXJhbS5hY2NlcHRzVHlwZShhcmdzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZW1wdHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmFtLmFjY2VwdHModW5kZWZpbmVkKSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3NMZW5ndGggPiBwYXJhbXNMZW5ndGggJiYgcmVzdCkge1xuICAgICAgICBmb3IgKHZhciBfaTUgPSBwYXJhbXNMZW5ndGg7IF9pNSA8IGFyZ3NMZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgaWYgKCFyZXN0LmFjY2VwdHNUeXBlKGFyZ3NbX2k1XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJldHVyblR5cGUudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuICAgICAgICAgIHJlc3QgPSB0aGlzLnJlc3QsXG4gICAgICAgICAgcmV0dXJuVHlwZSA9IHRoaXMucmV0dXJuVHlwZTtcblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChwYXJhbXNbaV0udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdCkge1xuICAgICAgICBhcmdzLnB1c2gocmVzdC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgKCR7YXJncy5qb2luKCcsICcpfSkgPT4gJHtyZXR1cm5UeXBlLnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgcmVzdDogdGhpcy5yZXN0LFxuICAgICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvblR5cGU7XG59KFR5cGUpO1xuXG52YXIgR2VuZXJhdG9yVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhHZW5lcmF0b3JUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHZW5lcmF0b3JUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEdlbmVyYXRvclR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHZW5lcmF0b3JUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnR2VuZXJhdG9yVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhHZW5lcmF0b3JUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm5leHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnJldHVybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5wdXQudGhyb3cgPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9HRU5FUkFUT1InKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5wdXQucmV0dXJuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnB1dC50aHJvdyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEdlbmVyYXRvclR5cGUpKSB7XG4gICAgICAgIHZhciBfcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMueWllbGRUeXBlLCBpbnB1dCk7XG4gICAgICAgIGlmIChfcmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlzR3JlYXRlciA9IGZhbHNlO1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0aGlzLnlpZWxkVHlwZSwgaW5wdXQueWllbGRUeXBlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgIGlzR3JlYXRlciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0aGlzLnJldHVyblR5cGUsIGlucHV0LnJldHVyblR5cGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMubmV4dFR5cGUsIGlucHV0Lm5leHRUeXBlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgIGlzR3JlYXRlciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0dyZWF0ZXIgPyAxIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzWWllbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzWWllbGQoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnlpZWxkVHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzUmV0dXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c1JldHVybihpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuVHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzTmV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNOZXh0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRZaWVsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFlpZWxkKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy55aWVsZFR5cGUuYXNzZXJ0KGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRSZXR1cm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnRSZXR1cm4oaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblR5cGUuYXNzZXJ0KGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnROZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0TmV4dChpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFR5cGUuYXNzZXJ0KGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHlpZWxkVHlwZSA9IHRoaXMueWllbGRUeXBlLFxuICAgICAgICAgIHJldHVyblR5cGUgPSB0aGlzLnJldHVyblR5cGUsXG4gICAgICAgICAgbmV4dFR5cGUgPSB0aGlzLm5leHRUeXBlO1xuXG4gICAgICByZXR1cm4gYEdlbmVyYXRvcjwke3lpZWxkVHlwZS50b1N0cmluZygpfSwgJHtyZXR1cm5UeXBlLnRvU3RyaW5nKCl9LCAke25leHRUeXBlLnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgeWllbGRUeXBlOiB0aGlzLnlpZWxkVHlwZSxcbiAgICAgICAgcmV0dXJuVHlwZTogdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgICBuZXh0VHlwZTogdGhpcy5uZXh0VHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdlbmVyYXRvclR5cGU7XG59KFR5cGUpO1xuXG52YXIgd2FybmVkSW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcblxudmFyIFR5cGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhUeXBlQ29uc3RydWN0b3IsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUeXBlQ29uc3RydWN0b3IoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZUNvbnN0cnVjdG9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFR5cGVDb25zdHJ1Y3Rvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGVDb25zdHJ1Y3RvcikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R5cGVDb25zdHJ1Y3RvcicsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUeXBlQ29uc3RydWN0b3IsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge31cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICBpZiAoIXdhcm5lZEluc3RhbmNlcy5oYXModGhpcykpIHtcbiAgICAgICAgY29udGV4dC5lbWl0V2FybmluZ01lc3NhZ2UoYFR5cGVDb25zdHJ1Y3RvciAke25hbWV9IGRvZXMgbm90IGltcGxlbWVudCBhY2NlcHRzKCkuYCk7XG4gICAgICAgIHdhcm5lZEluc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgaWYgKCF3YXJuZWRJbnN0YW5jZXMuaGFzKHRoaXMpKSB7XG4gICAgICAgIGNvbnRleHQuZW1pdFdhcm5pbmdNZXNzYWdlKGBUeXBlQ29uc3RydWN0b3IgJHtuYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgY29tcGFyZVdpdGgoKS5gKTtcbiAgICAgICAgd2FybmVkSW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlclR5cGVQYXJhbWV0ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXJUeXBlUGFyYW1ldGVycyhpbnB1dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlQ29uc3RydWN0b3I7XG59KFR5cGUpO1xuXG52YXIgR2VuZXJpY1R5cGUgPSBmdW5jdGlvbiAoX1R5cGVDb25zdHJ1Y3Rvcikge1xuICBpbmhlcml0cyhHZW5lcmljVHlwZSwgX1R5cGVDb25zdHJ1Y3Rvcik7XG5cbiAgZnVuY3Rpb24gR2VuZXJpY1R5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJpY1R5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gR2VuZXJpY1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHZW5lcmljVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gXCJHZW5lcmljVHlwZVwiLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoR2VuZXJpY1R5cGUsIFt7XG4gICAga2V5OiBcImVycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgICBpbXBsID0gdGhpcy5pbXBsO1xuXG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIGltcGwpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoXCJFUlJfRVhQRUNUX0lOU1RBTkNFT0ZcIiwgbmFtZSksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhY2NlcHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBpbXBsID0gdGhpcy5pbXBsO1xuXG4gICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBpbXBsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaW1wbCA9IHRoaXMuaW1wbDtcblxuICAgICAgdmFyIGFubm90YXRpb24gPSBjb250ZXh0LmdldEFubm90YXRpb24oaW1wbCk7XG4gICAgICBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZCA9IGFubm90YXRpb24udW53cmFwLmFwcGx5KGFubm90YXRpb24sIHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyhpbnB1dCwgZXhwZWN0ZWQpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIEdlbmVyaWNUeXBlICYmIChpbnB1dC5pbXBsID09PSBpbXBsIHx8IGltcGwgJiYgaW1wbC5pc1Byb3RvdHlwZU9mKGlucHV0LmltcGwpKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW53cmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGltcGwgPSB0aGlzLmltcGw7XG5cbiAgICAgIGlmICh0eXBlb2YgaW1wbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFubm90YXRpb24gPSBjb250ZXh0LmdldEFubm90YXRpb24oaW1wbCk7XG4gICAgICBpZiAoYW5ub3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uLnVud3JhcC5hcHBseShhbm5vdGF0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZmVyVHlwZVBhcmFtZXRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXJUeXBlUGFyYW1ldGVycyhpbnB1dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gR2VuZXJpY1R5cGU7XG59KFR5cGVDb25zdHJ1Y3Rvcik7XG5cbmZ1bmN0aW9uIGludmFyaWFudChpbnB1dCwgbWVzc2FnZSkge1xuICBpZiAoIWlucHV0KSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50VmlvbGF0aW9uJztcbiAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgaW52YXJpYW50KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxudmFyIE51bGxMaXRlcmFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhOdWxsTGl0ZXJhbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBOdWxsTGl0ZXJhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVsbExpdGVyYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE51bGxMaXRlcmFsVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bGxMaXRlcmFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ051bGxMaXRlcmFsVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhOdWxsTGl0ZXJhbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfTlVMTCcpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ID09PSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bGxMaXRlcmFsVHlwZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bGxMaXRlcmFsVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBWb2lkVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhWb2lkVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFZvaWRUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvaWRUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFZvaWRUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVm9pZFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdWb2lkVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhWb2lkVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX1ZPSUQnKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFZvaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3ZvaWQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVm9pZFR5cGU7XG59KFR5cGUpO1xuXG52YXIgTnVsbGFibGVUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE51bGxhYmxlVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIE51bGxhYmxlVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdWxsYWJsZVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTnVsbGFibGVUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVsbGFibGVUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTnVsbGFibGVUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE51bGxhYmxlVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBOdWxsTGl0ZXJhbFR5cGUgfHwgaW5wdXQgaW5zdGFuY2VvZiBWb2lkVHlwZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBOdWxsYWJsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0LnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYD8gJHt0aGlzLnR5cGUudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdWxsYWJsZVR5cGU7XG59KFR5cGUpO1xuXG52YXIgT2JqZWN0VHlwZVByb3BlcnR5ID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE9iamVjdFR5cGVQcm9wZXJ0eSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIE9iamVjdFR5cGVQcm9wZXJ0eSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RUeXBlUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gT2JqZWN0VHlwZVByb3BlcnR5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0VHlwZVByb3BlcnR5KSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnT2JqZWN0VHlwZVByb3BlcnR5JywgX3RoaXNbJ3N0YXRpYyddID0gZmFsc2UsIF90aGlzLmNvbnN0cmFpbnRzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cbiAgLy8gSWdub3JlXG5cblxuICBjcmVhdGVDbGFzcyhPYmplY3RUeXBlUHJvcGVydHksIFt7XG4gICAga2V5OiAnYWRkQ29uc3RyYWludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbnN0cmFpbnRzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgY29uc3RyYWludHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgYWRkQ29uc3RyYWludHMuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNvbnN0cmFpbnRzKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIG51bGxhYmxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc051bGxhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOdWxsYWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlIGluc3RhbmNlb2YgTnVsbGFibGVUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMgb24gdGhlIGdpdmVuIGlucHV0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2V4aXN0c09uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhpc3RzT24oaW5wdXQpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgICAgdmFyIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIGlzU3RhdGljID0gdGhpcy5zdGF0aWM7XG5cbiAgICAgIHJldHVybiBrZXkgaW4gKGlzU3RhdGljID8gaW5wdXQuY29uc3RydWN0b3IgOiBpbnB1dCkgPT09IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgLy8gSWdub3JlXG4gICAgICB2YXIgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBpc1N0YXRpYyA9IHRoaXMuc3RhdGljO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgdmFyIHRhcmdldFBhdGggPSB2b2lkIDA7XG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFBhdGggPSBwYXRoLmNvbmNhdCgnY29uc3RydWN0b3InKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICghb3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHlpZWxkIFt0YXJnZXRQYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfRlVOQ1RJT04nKSwgdGhpc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuY29uc3RydWN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0W2tleV07XG4gICAgICAgIHRhcmdldFBhdGggPSBwYXRoLmNvbmNhdChrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbmFsICYmIHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTnVsbGFibGUoKSAmJiAhdGhpcy5leGlzdHNPbihpbnB1dCkpIHtcbiAgICAgICAgeWllbGQgW3RhcmdldFBhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX01JU1NJTkdfUFJPUEVSVFknKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB2YWx1ZS5lcnJvcnModmFsaWRhdGlvbiwgdGFyZ2V0UGF0aCwgdGFyZ2V0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgeWllbGQgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0Vycm9ycykge1xuICAgICAgICB5aWVsZCogY29sbGVjdENvbnN0cmFpbnRFcnJvcnModGhpcywgdmFsaWRhdGlvbiwgdGFyZ2V0UGF0aCwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgLy8gSWdub3JlXG4gICAgICB2YXIgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBpc1N0YXRpYyA9IHRoaXMuc3RhdGljO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGlucHV0LmNvbnN0cnVjdG9yW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dFtrZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uYWwgJiYgdGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzTnVsbGFibGUoKSAmJiAhdGhpcy5leGlzdHNPbihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbHVlLmFjY2VwdHModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29uc3RyYWludHNBY2NlcHQodGhpcywgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE9iamVjdFR5cGVQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5rZXkgIT09IHRoaXMua2V5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy52YWx1ZSwgaW5wdXQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICBrZXkgPSBgWyR7a2V5LnRvU3RyaW5nKCl9XWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIGBzdGF0aWMgJHtrZXl9JHt0aGlzLm9wdGlvbmFsID8gJz8nIDogJyd9OiAke3RoaXMudmFsdWUudG9TdHJpbmcoKX07YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHt0aGlzLm9wdGlvbmFsID8gJz8nIDogJyd9OiAke3RoaXMudmFsdWUudG9TdHJpbmcoKX07YDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIG9wdGlvbmFsOiB0aGlzLm9wdGlvbmFsXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JqZWN0VHlwZVByb3BlcnR5O1xufShUeXBlKTtcblxudmFyIE9iamVjdFR5cGVJbmRleGVyID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE9iamVjdFR5cGVJbmRleGVyLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0VHlwZUluZGV4ZXIoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0VHlwZUluZGV4ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gT2JqZWN0VHlwZUluZGV4ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3RUeXBlSW5kZXhlcikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ09iamVjdFR5cGVJbmRleGVyJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9iamVjdFR5cGVJbmRleGVyLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwga2V5LCB2YWx1ZSkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIG51bWJlciB0eXBlc1xuICAgICAgaWYgKHRoaXMua2V5LnR5cGVOYW1lID09PSAnTnVtYmVyVHlwZScgfHwgdGhpcy5rZXkudHlwZU5hbWUgPT09ICdOdW1lcmljTGl0ZXJhbFR5cGUnKSB7XG4gICAgICAgIGtleSA9ICtrZXk7XG4gICAgICB9XG5cbiAgICAgIHlpZWxkKiB0aGlzLmtleS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQoJ1tbS2V5XV0nKSwga2V5KTtcbiAgICAgIHlpZWxkKiB0aGlzLnZhbHVlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLmNvbmNhdChrZXkpLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLmFjY2VwdHModmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzS2V5KGtleSkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIG51bWJlciB0eXBlc1xuICAgICAgaWYgKHRoaXMua2V5LnR5cGVOYW1lID09PSAnTnVtYmVyVHlwZScgfHwgdGhpcy5rZXkudHlwZU5hbWUgPT09ICdOdW1lcmljTGl0ZXJhbFR5cGUnKSB7XG4gICAgICAgIGtleSA9ICtrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5rZXkuYWNjZXB0cyhrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuYWNjZXB0cyh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0VHlwZVByb3BlcnR5KSB7XG4gICAgICAgIGlmICghdGhpcy5rZXkuYWNjZXB0cyhpbnB1dC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy52YWx1ZSwgaW5wdXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlSW5kZXhlcikpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5UmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMua2V5LCBpbnB1dC5rZXkpO1xuICAgICAgaWYgKGtleVJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlUmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMudmFsdWUsIGlucHV0LnZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZVJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5UmVzdWx0ID09PSAwICYmIHZhbHVlUmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgWyR7dGhpcy5pZH06ICR7dGhpcy5rZXkudG9TdHJpbmcoKX1dOiAke3RoaXMudmFsdWUudG9TdHJpbmcoKX07YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JqZWN0VHlwZUluZGV4ZXI7XG59KFR5cGUpO1xuXG52YXIgT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhPYmplY3RUeXBlQ2FsbFByb3BlcnR5LCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RUeXBlQ2FsbFByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE9iamVjdFR5cGVDYWxsUHJvcGVydHkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3RUeXBlQ2FsbFByb3BlcnR5KSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eScsIF90aGlzWydzdGF0aWMnXSA9IGZhbHNlLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG4gIC8vIElnbm9yZVxuXG5cbiAgY3JlYXRlQ2xhc3MoT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgaXNTdGF0aWMgPSB0aGlzLnN0YXRpYztcblxuXG4gICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgdmFyIHRhcmdldFBhdGggPSB2b2lkIDA7XG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFBhdGggPSBwYXRoLmNvbmNhdCgnY29uc3RydWN0b3InKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHlpZWxkIFt0YXJnZXRQYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfRlVOQ1RJT04nKSwgdGhpc107XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGlucHV0LmNvbnN0cnVjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQ7XG4gICAgICAgIHRhcmdldFBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgICAgeWllbGQqIHZhbHVlLmVycm9ycyh2YWxpZGF0aW9uLCB0YXJnZXRQYXRoLCB0YXJnZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgaXNTdGF0aWMgPSB0aGlzLnN0YXRpYztcblxuICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSBpbnB1dC5jb25zdHJ1Y3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlLmFjY2VwdHModGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE9iamVjdFR5cGVDYWxsUHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy52YWx1ZSwgaW5wdXQudmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIGBzdGF0aWMgJHt0aGlzLnZhbHVlLnRvU3RyaW5nKCl9O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG59KFR5cGUpO1xuXG52YXIgRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRGVjbGFyYXRpb24sIF9UeXBlKTtcblxuICBmdW5jdGlvbiBEZWNsYXJhdGlvbigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNsYXJhdGlvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERlY2xhcmF0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGVjbGFyYXRpb24pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBEZWNsYXJhdGlvbjtcbn0oVHlwZSk7XG5cbnZhciBWYXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChfRGVjbGFyYXRpb24pIHtcbiAgaW5oZXJpdHMoVmFyRGVjbGFyYXRpb24sIF9EZWNsYXJhdGlvbik7XG5cbiAgZnVuY3Rpb24gVmFyRGVjbGFyYXRpb24oKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFyRGVjbGFyYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVmFyRGVjbGFyYXRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWYXJEZWNsYXJhdGlvbikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1ZhckRlY2xhcmF0aW9uJywgX3RoaXMuY29uc3RyYWludHMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFZhckRlY2xhcmF0aW9uLCBbe1xuICAgIGtleTogJ2FkZENvbnN0cmFpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdHJhaW50KCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBjb25zdHJhaW50cyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGFkZENvbnN0cmFpbnRzLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25zdHJhaW50cykpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRXJyb3JzKSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0Q29uc3RyYWludEVycm9ycyh0aGlzLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghY29uc3RyYWludHNBY2NlcHQodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGBkZWNsYXJlIHZhciAke3RoaXMubmFtZX06ICR7dGhpcy50eXBlLnRvU3RyaW5nKCl9O2A7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWYXJEZWNsYXJhdGlvbjtcbn0oRGVjbGFyYXRpb24pO1xuXG52YXIgVHlwZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKF9EZWNsYXJhdGlvbikge1xuICBpbmhlcml0cyhUeXBlRGVjbGFyYXRpb24sIF9EZWNsYXJhdGlvbik7XG5cbiAgZnVuY3Rpb24gVHlwZURlY2xhcmF0aW9uKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVEZWNsYXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlRGVjbGFyYXRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlRGVjbGFyYXRpb24pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlRGVjbGFyYXRpb24nLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZURlY2xhcmF0aW9uLCBbe1xuICAgIGtleTogJ2FkZENvbnN0cmFpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdHJhaW50KCkge1xuICAgICAgdmFyIF90eXBlQWxpYXM7XG5cbiAgICAgIChfdHlwZUFsaWFzID0gdGhpcy50eXBlQWxpYXMpLmFkZENvbnN0cmFpbnQuYXBwbHkoX3R5cGVBbGlhcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLnR5cGVBbGlhcy5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgX3R5cGVBbGlhczI7XG5cbiAgICAgIHJldHVybiAoX3R5cGVBbGlhczIgPSB0aGlzLnR5cGVBbGlhcykuYXBwbHkuYXBwbHkoX3R5cGVBbGlhczIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVBbGlhcy5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZUFsaWFzLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgX3R5cGVBbGlhczM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdHlwZUFsaWFzMyA9IHRoaXMudHlwZUFsaWFzKS5oYXNQcm9wZXJ0eS5hcHBseShfdHlwZUFsaWFzMywgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIF90eXBlQWxpYXM0O1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3R5cGVBbGlhczQgPSB0aGlzLnR5cGVBbGlhcykuZ2V0UHJvcGVydHkuYXBwbHkoX3R5cGVBbGlhczQsIFtuYW1lXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBfdHlwZUFsaWFzNTtcblxuICAgICAgcmV0dXJuIChfdHlwZUFsaWFzNSA9IHRoaXMudHlwZUFsaWFzKS51bndyYXAuYXBwbHkoX3R5cGVBbGlhczUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgZGVjbGFyZSAke3RoaXMudHlwZUFsaWFzLnRvU3RyaW5nKHRydWUpfTtgO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZUFsaWFzLnR5cGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlRGVjbGFyYXRpb247XG59KERlY2xhcmF0aW9uKTtcblxudmFyIE1vZHVsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKF9EZWNsYXJhdGlvbikge1xuICBpbmhlcml0cyhNb2R1bGVEZWNsYXJhdGlvbiwgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBNb2R1bGVEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb2R1bGVEZWNsYXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBNb2R1bGVEZWNsYXJhdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1vZHVsZURlY2xhcmF0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTW9kdWxlRGVjbGFyYXRpb24nLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTW9kdWxlRGVjbGFyYXRpb24sIFt7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0JCQxKG5hbWUpIHtcbiAgICAgIHZhciBtb2R1bGVFeHBvcnRzID0gdGhpcy5tb2R1bGVFeHBvcnRzO1xuXG4gICAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgICB2YXIgZXhwb3J0aW5nID0gbW9kdWxlRXhwb3J0cy51bndyYXAoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRpbmcuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGV4cG9ydGluZy5nZXRQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AudW53cmFwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLmRlY2xhcmF0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uLnVud3JhcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgLy8gQ2FuJ3QgdmFsaWRhdGUgYSBtb2R1bGUgZGlyZWN0bHkuXG4gICAgICAvLyBAdG9kbyBzaG91bGQgdGhpcyB0aHJvdz9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbXBvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW1wb3J0KG1vZHVsZU5hbWUpIHtcbiAgICAgIGlmICgvXlxcLlxcLy8udGVzdChtb2R1bGVOYW1lKSkge1xuICAgICAgICBtb2R1bGVOYW1lID0gYCR7dGhpcy5uYW1lfSR7bW9kdWxlTmFtZS5zbGljZSgxKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaW5uZXJDb250ZXh0LmltcG9ydChtb2R1bGVOYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgZGVjbGFyYXRpb25zID0gdGhpcy5kZWNsYXJhdGlvbnMsXG4gICAgICAgICAgbW9kdWxlcyA9IHRoaXMubW9kdWxlcyxcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gdGhpcy5tb2R1bGVFeHBvcnRzO1xuXG4gICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgZm9yICh2YXIgX25hbWUgaW4gZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tfbmFtZV07XG4gICAgICAgIGJvZHkucHVzaChkZWNsYXJhdGlvbi50b1N0cmluZyh0cnVlKSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlcykge1xuICAgICAgICBmb3IgKHZhciBfbmFtZTIgaW4gbW9kdWxlcykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgICAgdmFyIG1vZHVsZSA9IG1vZHVsZXNbX25hbWUyXTtcbiAgICAgICAgICBib2R5LnB1c2gobW9kdWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBib2R5LnB1c2gobW9kdWxlRXhwb3J0cy50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgZGVjbGFyZSBtb2R1bGUgXCIke25hbWV9XCIge1xcbiR7aW5kZW50JDEoYm9keS5qb2luKCdcXG5cXG4nKSl9fWA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW9kdWxlVHlwZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5tb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiAnY29tbW9uanMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdlczYnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzQ29tbW9uSlMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlRXhwb3J0cyA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0VTNicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVFeHBvcnRzID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY2xhcmF0aW9ucycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICB2YXIgaW5uZXJDb250ZXh0ID0gdGhpcy5pbm5lckNvbnRleHQ7XG5cbiAgICAgIHJldHVybiBpbm5lckNvbnRleHRbTmFtZVJlZ2lzdHJ5U3ltYm9sXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb2R1bGVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciBpbm5lckNvbnRleHQgPSB0aGlzLmlubmVyQ29udGV4dDtcblxuICAgICAgcmV0dXJuIGlubmVyQ29udGV4dFtNb2R1bGVSZWdpc3RyeVN5bWJvbF07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNb2R1bGVEZWNsYXJhdGlvbjtcbn0oRGVjbGFyYXRpb24pO1xuXG5mdW5jdGlvbiBpbmRlbnQkMShpbnB1dCkge1xuICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG4gIHZhciBsZW5ndGggPSBsaW5lcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpbmVzW2ldID0gYCAgJHtsaW5lc1tpXX1gO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cblxudmFyIE1vZHVsZUV4cG9ydHMgPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKE1vZHVsZUV4cG9ydHMsIF9EZWNsYXJhdGlvbik7XG5cbiAgZnVuY3Rpb24gTW9kdWxlRXhwb3J0cygpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb2R1bGVFeHBvcnRzKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE1vZHVsZUV4cG9ydHMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2R1bGVFeHBvcnRzKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTW9kdWxlRXhwb3J0cycsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNb2R1bGVFeHBvcnRzLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLnR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHM6ICR7dGhpcy50eXBlLnRvU3RyaW5nKCl9O2A7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNb2R1bGVFeHBvcnRzO1xufShEZWNsYXJhdGlvbik7XG5cbnZhciBDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKF9EZWNsYXJhdGlvbikge1xuICBpbmhlcml0cyhDbGFzc0RlY2xhcmF0aW9uLCBfRGVjbGFyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24oKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xhc3NEZWNsYXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBDbGFzc0RlY2xhcmF0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xhc3NEZWNsYXJhdGlvbikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0NsYXNzRGVjbGFyYXRpb24nLCBfdGhpcy5zaGFwZUlEID0gU3ltYm9sKCksIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhDbGFzc0RlY2xhcmF0aW9uLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xuXG4gICAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXMuc3VwZXJDbGFzcyAmJiB0aGlzLnN1cGVyQ2xhc3MudW53cmFwKCk7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9JTlNUQU5DRU9GJywgdGhpcy5uYW1lKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHN1cGVyQ2xhc3MuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgX3JlZjMgPSBzbGljZWRUb0FycmF5KF9yZWYyLCAzKTtcblxuICAgICAgICAgICAgdmFyIGVycm9yUGF0aCA9IF9yZWYzWzBdO1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IF9yZWYzWzFdO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IF9yZWYzWzJdO1xuXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gZXJyb3JQYXRoW3BhdGgubGVuZ3RoXTtcbiAgICAgICAgICAgIGlmIChib2R5LmdldFByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB5aWVsZCBbZXJyb3JQYXRoLCBlcnJvck1lc3NhZ2UsIGV4cGVjdGVkVHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQqIGJvZHkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHk7XG5cbiAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcy5zdXBlckNsYXNzICYmIHRoaXMuc3VwZXJDbGFzcy51bndyYXAoKTtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHN1cGVyQ2xhc3MgJiYgIXN1cGVyQ2xhc3MuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghYm9keS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDbGFzc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdGhpcykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdXBlckNsYXNzT2YoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMuYm9keSwgaW5wdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLnN1cGVyQ2xhc3M7XG5cbiAgICAgIHZhciBwcm9wID0gYm9keS5nZXRQcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9IGVsc2UgaWYgKHN1cGVyQ2xhc3MgJiYgdHlwZW9mIHN1cGVyQ2xhc3MuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyQ2xhc3MuZ2V0UHJvcGVydHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KGtleSkge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHksXG4gICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuc3VwZXJDbGFzcztcblxuICAgICAgaWYgKGJvZHkuaGFzUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwZXJDbGFzcyAmJiB0eXBlb2Ygc3VwZXJDbGFzcy5oYXNQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc3VwZXJDbGFzcy5oYXNQcm9wZXJ0eShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoaXMgY2xhc3MgZGVjbGFyYXRpb24gcmVwcmVzZW50cyBhIHN1cGVyIGNsYXNzIG9mXG4gICAgICogdGhlIGdpdmVuIHR5cGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzU3VwZXJDbGFzc09mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBlckNsYXNzT2YoY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuYm9keSxcbiAgICAgICAgICBzaGFwZUlEID0gdGhpcy5zaGFwZUlEO1xuXG4gICAgICB2YXIgY3VycmVudCA9IGNhbmRpZGF0ZTtcblxuICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcyB8fCBjdXJyZW50ID09PSBib2R5IHx8IGN1cnJlbnQuc2hhcGVJRCA9PT0gc2hhcGVJRCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnN1cGVyQ2xhc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudW53cmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24odGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC50eXBlSW5zdGFuY2VzID0gdHlwZUluc3RhbmNlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLnN1cGVyQ2xhc3MsXG4gICAgICAgICAgYm9keSA9IHRoaXMuYm9keTtcblxuICAgICAgaWYgKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgICB2YXIgc3VwZXJDbGFzc05hbWUgPSBzdXBlckNsYXNzICYmICh0eXBlb2Ygc3VwZXJDbGFzcy5uYW1lID09PSAnc3RyaW5nJyAmJiBzdXBlckNsYXNzLm5hbWUgfHwgc3VwZXJDbGFzcy50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGBkZWNsYXJlIGNsYXNzICR7bmFtZX0ke3N1cGVyQ2xhc3NOYW1lID8gYCBleHRlbmRzICR7c3VwZXJDbGFzc05hbWV9YCA6ICcnfSAke2JvZHkudG9TdHJpbmcoKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvcGVydGllcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuYm9keSxcbiAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5zdXBlckNsYXNzO1xuXG4gICAgICBpZiAoc3VwZXJDbGFzcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBib2R5LnByb3BlcnRpZXM7XG4gICAgICB9XG4gICAgICB2YXIgYm9keVByb3BzID0gYm9keS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIHN1cGVyUHJvcHMgPSBzdXBlckNsYXNzLnVud3JhcCgpLnByb3BlcnRpZXM7XG4gICAgICBpZiAoc3VwZXJQcm9wcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBib2R5UHJvcHM7XG4gICAgICB9XG4gICAgICB2YXIgc2VlbiA9IHt9O1xuICAgICAgdmFyIHNlZW5TdGF0aWMgPSB7fTtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBlclByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc3VwZXJQcm9wc1tpXTtcbiAgICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgaWYgKHByb3Auc3RhdGljKSB7XG4gICAgICAgICAgc2VlblN0YXRpY1twcm9wLmtleV0gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5bcHJvcC5rZXldID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJvZHlQcm9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9wcm9wID0gYm9keVByb3BzW19pXTtcbiAgICAgICAgaWYgKHNlZW5bX3Byb3Aua2V5XSkge1xuICAgICAgICAgIHByb3BzW19pXSA9IF9wcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzLnB1c2goX3Byb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbGFzc0RlY2xhcmF0aW9uO1xufShEZWNsYXJhdGlvbik7XG5cbnZhciBQYXJ0aWFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhQYXJ0aWFsVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFBhcnRpYWxUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnRpYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFBhcnRpYWxUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFydGlhbFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdQYXJ0aWFsVHlwZScsIF90aGlzLnR5cGVQYXJhbWV0ZXJzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhQYXJ0aWFsVHlwZSwgW3tcbiAgICBrZXk6ICd0eXBlUGFyYW1ldGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZVBhcmFtZXRlcihpZCwgYm91bmQsIGRlZmF1bHRUeXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXIodGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5pZCA9IGlkO1xuICAgICAgdGFyZ2V0LmJvdW5kID0gYm91bmQ7XG4gICAgICB0YXJnZXQuZGVmYXVsdCA9IGRlZmF1bHRUeXBlO1xuICAgICAgdGhpcy50eXBlUGFyYW1ldGVycy5wdXNoKHRhcmdldCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNFcnJvcnMgJiYgY29uc3RyYWludHMpIHtcbiAgICAgICAgeWllbGQqIGNvbGxlY3RDb25zdHJhaW50RXJyb3JzKHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgICB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChjb25zdHJhaW50cyAmJiAhY29uc3RyYWludHNBY2NlcHQodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhleHBhbmQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICByZXR1cm4gdHlwZS50b1N0cmluZyhleHBhbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHRoaXMudHlwZVBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhcnRpYWxUeXBlO1xufShUeXBlKTtcblxudmFyIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKF9EZWNsYXJhdGlvbikge1xuICBpbmhlcml0cyhQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbiwgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24nLCBfdGhpcy5zaGFwZUlEID0gU3ltYm9sKCksIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbiwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHlpZWxkKiBnZXRQYXJ0aWFsLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFBhcnRpYWwuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwodGhpcykuY29tcGFyZVdpdGgoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFBhcnRpYWwuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc1N1cGVyQ2xhc3NPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwZXJDbGFzc09mKGNhbmRpZGF0ZSkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwodGhpcykudHlwZS5pc1N1cGVyQ2xhc3NPZihjYW5kaWRhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgaWYgKCF3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0aWFsID0gZ2V0UGFydGlhbCh0aGlzKTtcbiAgICAgIHZhciB0eXBlID0gcGFydGlhbC50eXBlLFxuICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFydGlhbC50eXBlUGFyYW1ldGVycztcblxuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFydGlhbC50b1N0cmluZyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpdGVtcy5wdXNoKHR5cGVQYXJhbWV0ZXIudG9TdHJpbmcodHJ1ZSkpO1xuICAgICAgfVxuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0eXBlLnN1cGVyQ2xhc3MsXG4gICAgICAgICAgYm9keSA9IHR5cGUuYm9keTtcblxuICAgICAgdmFyIHN1cGVyQ2xhc3NOYW1lID0gc3VwZXJDbGFzcyAmJiAodHlwZW9mIHN1cGVyQ2xhc3MubmFtZSA9PT0gJ3N0cmluZycgJiYgc3VwZXJDbGFzcy5uYW1lIHx8IHN1cGVyQ2xhc3MudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gYGRlY2xhcmUgY2xhc3MgJHt0aGlzLm5hbWV9PCR7aXRlbXMuam9pbignLCAnKX0+JHtzdXBlckNsYXNzTmFtZSA/IGAgZXh0ZW5kcyAke3N1cGVyQ2xhc3NOYW1lfWAgOiAnJ30gJHtib2R5LnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCh0aGlzKS50b0pTT04oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdXBlckNsYXNzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsKHRoaXMpLnR5cGUuc3VwZXJDbGFzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdib2R5JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsKHRoaXMpLnR5cGUuYm9keTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsKHRoaXMpLnR5cGUucHJvcGVydGllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlUGFyYW1ldGVycycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCh0aGlzKS50eXBlUGFyYW1ldGVycztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uO1xufShEZWNsYXJhdGlvbik7XG5cbmZ1bmN0aW9uIGdldFBhcnRpYWwocGFyZW50KSB7XG4gIHZhciBjb250ZXh0ID0gcGFyZW50LmNvbnRleHQsXG4gICAgICBib2R5Q3JlYXRvciA9IHBhcmVudC5ib2R5Q3JlYXRvcjtcblxuICB2YXIgcGFydGlhbCA9IG5ldyBQYXJ0aWFsVHlwZShjb250ZXh0KTtcbiAgdmFyIGJvZHkgPSBib2R5Q3JlYXRvcihwYXJ0aWFsKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICBwYXJ0aWFsLnR5cGUgPSBjb250ZXh0LmNsYXNzLmFwcGx5KGNvbnRleHQsIFtwYXJlbnQubmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGJvZHkpKSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydGlhbC50eXBlID0gY29udGV4dC5jbGFzcyhwYXJlbnQubmFtZSwgYm9keSk7XG4gIH1cblxuICBwYXJ0aWFsLnR5cGUuc2hhcGVJRCA9IHBhcmVudC5zaGFwZUlEO1xuXG4gIHZhciB0eXBlUGFyYW1ldGVycyA9IHBhcnRpYWwudHlwZVBhcmFtZXRlcnM7XG5cbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIHR5cGVJbnN0YW5jZXNbX2tleTYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICB2YXIgbGltaXQgPSBNYXRoLm1pbih0eXBlSW5zdGFuY2VzLmxlbmd0aCwgdHlwZVBhcmFtZXRlcnMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgdmFyIHR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyc1tpXTtcbiAgICB2YXIgdHlwZUluc3RhbmNlID0gdHlwZUluc3RhbmNlc1tpXTtcbiAgICBpZiAodHlwZVBhcmFtZXRlci5ib3VuZCAmJiB0eXBlUGFyYW1ldGVyLmJvdW5kICE9PSB0eXBlSW5zdGFuY2UpIHtcbiAgICAgIC8vIGlmIHRoZSB0eXBlIHBhcmFtZXRlciBpcyBhbHJlYWR5IGJvdW5kIHdlIG5lZWQgdG9cbiAgICAgIC8vIGNyZWF0ZSBhbiBpbnRlcnNlY3Rpb24gdHlwZSB3aXRoIHRoaXMgb25lLlxuICAgICAgdHlwZVBhcmFtZXRlci5ib3VuZCA9IGNvbnRleHQuaW50ZXJzZWN0KHR5cGVQYXJhbWV0ZXIuYm91bmQsIHR5cGVJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXIuYm91bmQgPSB0eXBlSW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbnZhciBFeHRlbmRzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKEV4dGVuZHNEZWNsYXJhdGlvbiwgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBFeHRlbmRzRGVjbGFyYXRpb24oKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXh0ZW5kc0RlY2xhcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEV4dGVuZHNEZWNsYXJhdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEV4dGVuZHNEZWNsYXJhdGlvbikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0V4dGVuZHNEZWNsYXJhdGlvbicsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhFeHRlbmRzRGVjbGFyYXRpb24sIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAod2l0aERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBgZXh0ZW5kcyAke3R5cGUudG9TdHJpbmcoKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEV4dGVuZHNEZWNsYXJhdGlvbjtcbn0oRGVjbGFyYXRpb24pO1xuXG52YXIgT2JqZWN0VHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhPYmplY3RUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE9iamVjdFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3RUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnT2JqZWN0VHlwZScsIF90aGlzLnByb3BlcnRpZXMgPSBbXSwgX3RoaXMuaW5kZXhlcnMgPSBbXSwgX3RoaXMuY2FsbFByb3BlcnRpZXMgPSBbXSwgX3RoaXMuZXhhY3QgPSBmYWxzZSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9iamVjdFR5cGUsIFt7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmRleGVyKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgdmFyIG5ld1Byb3AgPSBuZXcgT2JqZWN0VHlwZVByb3BlcnR5KGNvbnRleHQpO1xuICAgICAgbmV3UHJvcC5rZXkgPSBrZXk7XG4gICAgICBuZXdQcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBuZXdQcm9wLm9wdGlvbmFsID0gb3B0aW9uYWw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgcHJvcGVydGllc1tpXSA9IG5ld1Byb3A7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzLnB1c2gobmV3UHJvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChwcm9wZXJ0eS5rZXkgPT09IGtleSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYXNJbmRleGVyKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGluZGV4ZXIgd2l0aCB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBrZXkgdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5kZXhlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZGV4ZXIoa2V5KSB7XG4gICAgICB2YXIgaW5kZXhlcnMgPSB0aGlzLmluZGV4ZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXJzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXhlciA9IGluZGV4ZXJzW2ldO1xuICAgICAgICBpZiAoaW5kZXhlci5hY2NlcHRzS2V5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGFuIGluZGV4ZXIgZXhpc3RzIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGtleSB0eXBlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNJbmRleGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW5kZXhlcihrZXkpIHtcbiAgICAgIHZhciBpbmRleGVycyA9IHRoaXMuaW5kZXhlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gaW5kZXhlcnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleGVyID0gaW5kZXhlcnNbaV07XG4gICAgICAgIGlmIChpbmRleGVyLmFjY2VwdHNLZXkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfT0JKRUNUJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNDYWxsUHJvcGVydGllcyA9IHRoaXMuY2FsbFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKGhhc0NhbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghYWNjZXB0c0NhbGxQcm9wZXJ0aWVzKHRoaXMsIGlucHV0KSkge1xuICAgICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQ0FMTEFCTEUnKSwgdGhpc107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWRhdGlvbi5pbkN5Y2xlKHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YWxpZGF0aW9uLnN0YXJ0Q3ljbGUodGhpcywgaW5wdXQpO1xuXG4gICAgICBpZiAodGhpcy5pbmRleGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE9iamVjdCAmJiBBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfT0JKRUNUJyksIHRoaXNdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogY29sbGVjdEVycm9yc1dpdGhJbmRleGVycyh0aGlzLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCogY29sbGVjdEVycm9yc1dpdGhvdXRJbmRleGVycyh0aGlzLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5leGFjdCkge1xuICAgICAgICB5aWVsZCogY29sbGVjdEVycm9yc0V4YWN0KHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRpb24uZW5kQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGhhc0NhbGxQcm9wZXJ0aWVzID0gdGhpcy5jYWxsUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoaGFzQ2FsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCFhY2NlcHRzQ2FsbFByb3BlcnRpZXModGhpcywgaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGluVmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0VmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmluZGV4ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gYWNjZXB0c1dpdGhJbmRleGVycyh0aGlzLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhY2NlcHRzV2l0aG91dEluZGV4ZXJzKHRoaXMsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5leGFjdCkge1xuICAgICAgICByZXN1bHQgPSBhY2NlcHRzRXhhY3QodGhpcywgaW5wdXQpO1xuICAgICAgfVxuICAgICAgZW5kVmFsaWRhdGlvbkN5Y2xlKHRoaXMsIGlucHV0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlIHx8IGlucHV0IGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiB8fCBpbnB1dCBpbnN0YW5jZW9mIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQ2FsbFByb3BlcnRpZXMgPSB0aGlzLmNhbGxQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIHZhciBpc0dyZWF0ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChoYXNDYWxsUHJvcGVydGllcykge1xuICAgICAgICB2YXIgX3Jlc3VsdCA9IGNvbXBhcmVUeXBlQ2FsbFByb3BlcnRpZXModGhpcywgaW5wdXQpO1xuICAgICAgICBpZiAoX3Jlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoX3Jlc3VsdCA9PT0gMSkge1xuICAgICAgICAgIGlzR3JlYXRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmluZGV4ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGFyZVR5cGVXaXRoSW5kZXhlcnModGhpcywgaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGFyZVR5cGVXaXRob3V0SW5kZXhlcnModGhpcywgaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGlzR3JlYXRlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjYWxsUHJvcGVydGllcyA9IHRoaXMuY2FsbFByb3BlcnRpZXMsXG4gICAgICAgICAgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICBpbmRleGVycyA9IHRoaXMuaW5kZXhlcnM7XG5cbiAgICAgIGlmIChpblRvU3RyaW5nQ3ljbGUodGhpcykpIHtcbiAgICAgICAgcmV0dXJuICckQ3ljbGU8T2JqZWN0Pic7XG4gICAgICB9XG4gICAgICBzdGFydFRvU3RyaW5nQ3ljbGUodGhpcyk7XG4gICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBib2R5LnB1c2goY2FsbFByb3BlcnRpZXNbaV0udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcGVydGllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYm9keS5wdXNoKHByb3BlcnRpZXNbX2ldLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5kZXhlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBib2R5LnB1c2goaW5kZXhlcnNbX2kyXS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGVuZFRvU3RyaW5nQ3ljbGUodGhpcyk7XG4gICAgICBpZiAodGhpcy5leGFjdCkge1xuICAgICAgICByZXR1cm4gYHt8XFxuJHtpbmRlbnQoYm9keS5qb2luKCdcXG4nKSl9XFxufH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGB7XFxuJHtpbmRlbnQoYm9keS5qb2luKCdcXG4nKSl9XFxufWA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIGNhbGxQcm9wZXJ0aWVzOiB0aGlzLmNhbGxQcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIGluZGV4ZXJzOiB0aGlzLmluZGV4ZXJzLFxuICAgICAgICBleGFjdDogdGhpcy5leGFjdFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9iamVjdFR5cGU7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiBhY2NlcHRzQ2FsbFByb3BlcnRpZXModHlwZSwgaW5wdXQpIHtcbiAgdmFyIGNhbGxQcm9wZXJ0aWVzID0gdHlwZS5jYWxsUHJvcGVydGllcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhbGxQcm9wZXJ0eSA9IGNhbGxQcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChjYWxsUHJvcGVydHkuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUeXBlQ2FsbFByb3BlcnRpZXModHlwZSwgaW5wdXQpIHtcbiAgdmFyIGNhbGxQcm9wZXJ0aWVzID0gdHlwZS5jYWxsUHJvcGVydGllcztcblxuICB2YXIgaW5wdXRDYWxsUHJvcGVydGllcyA9IGlucHV0LmNhbGxQcm9wZXJ0aWVzO1xuICB2YXIgaWRlbnRpY2FsQ291bnQgPSAwO1xuICBsb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhbGxQcm9wZXJ0eSA9IGNhbGxQcm9wZXJ0aWVzW2ldO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dENhbGxQcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5wdXRDYWxsUHJvcGVydHkgPSBpbnB1dENhbGxQcm9wZXJ0aWVzW2pdO1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyhjYWxsUHJvcGVydHksIGlucHV0Q2FsbFByb3BlcnR5KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgaWRlbnRpY2FsQ291bnQrKztcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciwgbm90aGluZyBhY2NlcHRlZC5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGlkZW50aWNhbENvdW50ID09PSBjYWxsUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2NlcHRzV2l0aEluZGV4ZXJzKHR5cGUsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzLFxuICAgICAgaW5kZXhlcnMgPSB0eXBlLmluZGV4ZXJzO1xuXG4gIHZhciBzZWVuID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKCFwcm9wZXJ0eS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWVuLnB1c2gocHJvcGVydHkua2V5KTtcbiAgfVxuICBsb29wOiBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICBpZiAoc2Vlbi5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gaW5wdXRba2V5XTtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpbmRleGVycy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgaW5kZXhlciA9IGluZGV4ZXJzW19pM107XG4gICAgICBpZiAoaW5kZXhlci5hY2NlcHRzS2V5KGtleSkgJiYgaW5kZXhlci5hY2NlcHRzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZ290IHRoaXMgZmFyIHRoZSBrZXkgLyB2YWx1ZSBkaWQgbm90IGFjY2VwdHMgYW55IGluZGV4ZXJzLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVR5cGVXaXRoSW5kZXhlcnModHlwZSwgaW5wdXQpIHtcbiAgdmFyIGluZGV4ZXJzID0gdHlwZS5pbmRleGVycyxcbiAgICAgIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG5cbiAgdmFyIGlucHV0SW5kZXhlcnMgPSBpbnB1dC5pbmRleGVycztcbiAgdmFyIGlucHV0UHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gIHZhciBpc0dyZWF0ZXIgPSBmYWxzZTtcbiAgbG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0UHJvcGVydGllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGlucHV0UHJvcGVydHkgPSBpbnB1dFByb3BlcnRpZXNbal07XG4gICAgICBpZiAoaW5wdXRQcm9wZXJ0eS5rZXkgPT09IHByb3BlcnR5LmtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHByb3BlcnR5LCBpbnB1dFByb3BlcnR5KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb29wOiBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpbmRleGVycy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGluZGV4ZXIgPSBpbmRleGVyc1tfaTRdO1xuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBpbnB1dEluZGV4ZXJzLmxlbmd0aDsgX2orKykge1xuICAgICAgdmFyIGlucHV0SW5kZXhlciA9IGlucHV0SW5kZXhlcnNbX2pdO1xuICAgICAgdmFyIF9yZXN1bHQyID0gY29tcGFyZVR5cGVzKGluZGV4ZXIsIGlucHV0SW5kZXhlcik7XG4gICAgICBpZiAoX3Jlc3VsdDIgPT09IDEpIHtcbiAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH0gZWxzZSBpZiAoX3Jlc3VsdDIgPT09IDApIHtcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IHRoaXMgZmFyLCBub3RoaW5nIGFjY2VwdGVkXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBpc0dyZWF0ZXIgPyAxIDogMDtcbn1cblxuZnVuY3Rpb24gYWNjZXB0c1dpdGhvdXRJbmRleGVycyh0eXBlLCBpbnB1dCkge1xuICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGlmICghcHJvcGVydHkuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFjY2VwdHNFeGFjdCh0eXBlLCBpbnB1dCkge1xuICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrZXkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgIGlmICghcHJvcGVydGllcy5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5LmtleSA9PT0ga2V5O1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgdmFyIF9yZXQyID0gX2xvb3Aoa2V5KTtcblxuICAgIGlmICh0eXBlb2YgX3JldDIgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlVHlwZVdpdGhvdXRJbmRleGVycyh0eXBlLCBpbnB1dCkge1xuICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcblxuICB2YXIgaW5wdXRQcm9wZXJ0aWVzID0gaW5wdXQucHJvcGVydGllcztcbiAgdmFyIGlzR3JlYXRlciA9IGZhbHNlO1xuICBsb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRQcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5wdXRQcm9wZXJ0eSA9IGlucHV0UHJvcGVydGllc1tqXTtcbiAgICAgIGlmIChpbnB1dFByb3BlcnR5LmtleSA9PT0gcHJvcGVydHkua2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXMocHJvcGVydHkudmFsdWUsIGlucHV0UHJvcGVydHkudmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gaXNHcmVhdGVyID8gMSA6IDA7XG59XG5cbmZ1bmN0aW9uKiBjb2xsZWN0RXJyb3JzV2l0aEluZGV4ZXJzKHR5cGUsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzLFxuICAgICAgaW5kZXhlcnMgPSB0eXBlLmluZGV4ZXJzO1xuXG4gIHZhciBzZWVuID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgeWllbGQqIHByb3BlcnR5LmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgc2Vlbi5wdXNoKHByb3BlcnR5LmtleSk7XG4gIH1cbiAgbG9vcDogZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgaWYgKHNlZW4uaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgaW5kZXhlcnMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIGluZGV4ZXIgPSBpbmRleGVyc1tfaTVdO1xuICAgICAgaWYgKGluZGV4ZXIuYWNjZXB0c0tleShrZXkpICYmIGluZGV4ZXIuYWNjZXB0c1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGdvdCB0aGlzIGZhciB0aGUga2V5IC8gdmFsdWUgd2FzIG5vdCBhY2NlcHRlZCBieSBhbnkgaW5kZXhlcnMuXG4gICAgeWllbGQgW3BhdGguY29uY2F0KGtleSksIGdldEVycm9yTWVzc2FnZSgnRVJSX05PX0lOREVYRVInKSwgdHlwZV07XG4gIH1cbn1cblxuZnVuY3Rpb24qIGNvbGxlY3RFcnJvcnNXaXRob3V0SW5kZXhlcnModHlwZSwgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICB5aWVsZCogcHJvcGVydHkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiogY29sbGVjdEVycm9yc0V4YWN0KHR5cGUsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuXG4gIHZhciBfbG9vcDIgPSBmdW5jdGlvbiogX2xvb3AyKGtleSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgaWYgKCFwcm9wZXJ0aWVzLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkua2V5ID09PSBrZXk7XG4gICAgfSkpIHtcbiAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9VTktOT1dOX0tFWScsIGtleSksIHR5cGVdO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICB5aWVsZCogX2xvb3AyKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZW50KGlucHV0KSB7XG4gIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcbiAgdmFyIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGluZXNbaV0gPSBgICAke2xpbmVzW2ldfWA7XG4gIH1cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG52YXIgSW50ZXJzZWN0aW9uVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhJbnRlcnNlY3Rpb25UeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gSW50ZXJzZWN0aW9uVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcnNlY3Rpb25UeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEludGVyc2VjdGlvblR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbnRlcnNlY3Rpb25UeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnSW50ZXJzZWN0aW9uVHlwZScsIF90aGlzLnR5cGVzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhJbnRlcnNlY3Rpb25UeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkKiB0eXBlc1tpXS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSB0eXBlLmdldFByb3BlcnR5KGtleSk7XG4gICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkoa2V5KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUuaGFzUHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZS5oYXNQcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKCF0eXBlLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGlkZW50aWNhbENvdW50ID0gMDtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEludGVyc2VjdGlvblR5cGUpIHtcbiAgICAgICAgdmFyIGlucHV0VHlwZXMgPSBpbnB1dC50eXBlcztcbiAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHR5cGUsIGlucHV0VHlwZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgICAgICBpZGVudGljYWxDb3VudCsrO1xuICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gbm90aGluZyBhY2NlcHRlZCB0aGlzIHR5cGUuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGljYWxDb3VudCA9PT0gdHlwZXMubGVuZ3RoID8gMCA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF90eXBlID0gdHlwZXNbX2ldO1xuICAgICAgICAgIHZhciBfcmVzdWx0ID0gY29tcGFyZVR5cGVzKF90eXBlLCBpbnB1dCk7XG4gICAgICAgICAgaWYgKF9yZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChfcmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICBpZGVudGljYWxDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRlbnRpY2FsQ291bnQgPT09IHR5cGVzLmxlbmd0aCA/IDAgOiAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgdmFyIGNhbGxQcm9wZXJ0aWVzID0gW107XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ZXJzID0gW107XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXS51bndyYXAoKTtcbiAgICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgaW50ZXJzZWN0IG9iamVjdCB0eXBlcycpO1xuICAgICAgICBjYWxsUHJvcGVydGllcy5wdXNoLmFwcGx5KGNhbGxQcm9wZXJ0aWVzLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlLmNhbGxQcm9wZXJ0aWVzKSk7XG4gICAgICAgIGluZGV4ZXJzLnB1c2guYXBwbHkoaW5kZXhlcnMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUuaW5kZXhlcnMpKTtcbiAgICAgICAgbWVyZ2VQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHR5cGUucHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9yZWYyID0gY29udGV4dCkub2JqZWN0LmFwcGx5KF9yZWYyLCBjYWxsUHJvcGVydGllcy5jb25jYXQocHJvcGVydGllcywgaW5kZXhlcnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZXMuam9pbignICYgJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGVzOiB0aGlzLnR5cGVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW50ZXJzZWN0aW9uVHlwZTtcbn0oVHlwZSk7XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5kZXgobmFtZSwgcHJvcGVydGllcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJvcGVydGllc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZVByb3AgPSBzb3VyY2VbaV07XG4gICAgdmFyIGluZGV4ID0gZ2V0UHJvcGVydHlJbmRleCh0eXBlUHJvcC5rZXksIHRhcmdldCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGFyZ2V0LnB1c2godHlwZVByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRbaW5kZXhdID0gdHlwZVByb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBNaXhlZFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoTWl4ZWRUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gTWl4ZWRUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1peGVkVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBNaXhlZFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNaXhlZFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdNaXhlZFR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTWl4ZWRUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnbWl4ZWQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWl4ZWRUeXBlO1xufShUeXBlKTtcblxudmFyIE51bWVyaWNMaXRlcmFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhOdW1lcmljTGl0ZXJhbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBOdW1lcmljTGl0ZXJhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtZXJpY0xpdGVyYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE51bWVyaWNMaXRlcmFsVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWVyaWNMaXRlcmFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ051bWVyaWNMaXRlcmFsVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhOdW1lcmljTGl0ZXJhbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgaWYgKGlucHV0ICE9PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0VYQUNUX1ZBTFVFJywgdmFsdWUpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ID09PSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bWVyaWNMaXRlcmFsVHlwZSAmJiBpbnB1dC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMudmFsdWV9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1lcmljTGl0ZXJhbFR5cGU7XG59KFR5cGUpO1xuXG52YXIgTnVtYmVyVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhOdW1iZXJUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gTnVtYmVyVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE51bWJlclR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTnVtYmVyVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhOdW1iZXJUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfTlVNQkVSJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBOdW1iZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bWVyaWNMaXRlcmFsVHlwZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzID0gZnVuY3Rpb24gKF9UeXBlQWxpYXMpIHtcbiAgaW5oZXJpdHMoUGFyYW1ldGVyaXplZFR5cGVBbGlhcywgX1R5cGVBbGlhcyk7XG5cbiAgZnVuY3Rpb24gUGFyYW1ldGVyaXplZFR5cGVBbGlhcygpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXJhbWV0ZXJpemVkVHlwZUFsaWFzKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnUGFyYW1ldGVyaXplZFR5cGVBbGlhcycsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhQYXJhbWV0ZXJpemVkVHlwZUFsaWFzLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgeWllbGQqIGdldFBhcnRpYWwkMS5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0aWFsID0gZ2V0UGFydGlhbCQxLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgICAgaWYgKCFwYXJ0aWFsLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnN0cmFpbnRzQWNjZXB0KHRoaXMsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIHNob3VsZCBuZXZlciBuZWVkIHRoaXMgYmVjYXVzZSBpdCdzIHRha2VuIGNhcmUgb2YgYnkgY29tcGFyZVR5cGVzLlxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgY29uc3RyYWludHMgdGhlIHR5cGVzIGNhbm5vdCBiZSB0aGUgc2FtZVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGdldFBhcnRpYWwkMSh0aGlzKSwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcC5hcHBseSh0aGlzLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmhhc1Byb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5oYXNQcm9wZXJ0eS5hcHBseShpbm5lciwgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcC5hcHBseSh0aGlzLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5nZXRQcm9wZXJ0eS5hcHBseShpbm5lciwgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQxLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcod2l0aERlY2xhcmF0aW9uKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IGdldFBhcnRpYWwkMSh0aGlzKTtcbiAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHBhcnRpYWwudHlwZVBhcmFtZXRlcnM7XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpdGVtcy5wdXNoKHR5cGVQYXJhbWV0ZXIudG9TdHJpbmcodHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgdmFyIGlkZW50aWZpZXIgPSB0eXBlUGFyYW1ldGVycy5sZW5ndGggPiAwID8gYCR7bmFtZX08JHtpdGVtcy5qb2luKCcsICcpfT5gIDogbmFtZTtcblxuICAgICAgaWYgKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYHR5cGUgJHtpZGVudGlmaWVyfSA9ICR7cGFydGlhbC50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIHBhcnRpYWwgPSBnZXRQYXJ0aWFsJDEodGhpcyk7XG4gICAgICByZXR1cm4gcGFydGlhbC50b0pTT04oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDEodGhpcykudHlwZS5wcm9wZXJ0aWVzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFyYW1ldGVyaXplZFR5cGVBbGlhcztcbn0oVHlwZUFsaWFzKTtcblxuZnVuY3Rpb24gZ2V0UGFydGlhbCQxKHBhcmVudCkge1xuICB2YXIgdHlwZUNyZWF0b3IgPSBwYXJlbnQudHlwZUNyZWF0b3IsXG4gICAgICBjb250ZXh0ID0gcGFyZW50LmNvbnRleHQsXG4gICAgICBuYW1lID0gcGFyZW50Lm5hbWU7XG5cbiAgdmFyIHBhcnRpYWwgPSBuZXcgUGFydGlhbFR5cGUoY29udGV4dCk7XG4gIHBhcnRpYWwubmFtZSA9IG5hbWU7XG4gIHBhcnRpYWwudHlwZSA9IHR5cGVDcmVhdG9yKHBhcnRpYWwpO1xuICBwYXJ0aWFsLmNvbnN0cmFpbnRzID0gcGFyZW50LmNvbnN0cmFpbnRzO1xuXG4gIHZhciB0eXBlUGFyYW1ldGVycyA9IHBhcnRpYWwudHlwZVBhcmFtZXRlcnM7XG5cbiAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjcgPiAxID8gX2xlbjcgLSAxIDogMCksIF9rZXk3ID0gMTsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgIHR5cGVJbnN0YW5jZXNbX2tleTcgLSAxXSA9IGFyZ3VtZW50c1tfa2V5N107XG4gIH1cblxuICB2YXIgbGltaXQgPSBNYXRoLm1pbih0eXBlSW5zdGFuY2VzLmxlbmd0aCwgdHlwZVBhcmFtZXRlcnMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgdmFyIHR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyc1tpXTtcbiAgICB2YXIgdHlwZUluc3RhbmNlID0gdHlwZUluc3RhbmNlc1tpXTtcbiAgICBpZiAodHlwZVBhcmFtZXRlci5ib3VuZCAmJiB0eXBlUGFyYW1ldGVyLmJvdW5kICE9PSB0eXBlSW5zdGFuY2UpIHtcbiAgICAgIC8vIGlmIHRoZSB0eXBlIHBhcmFtZXRlciBpcyBhbHJlYWR5IGJvdW5kIHdlIG5lZWQgdG9cbiAgICAgIC8vIGNyZWF0ZSBhbiBpbnRlcnNlY3Rpb24gdHlwZSB3aXRoIHRoaXMgb25lLlxuICAgICAgdHlwZVBhcmFtZXRlci5ib3VuZCA9IGNvbnRleHQuaW50ZXJzZWN0KHR5cGVQYXJhbWV0ZXIuYm91bmQsIHR5cGVJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXIuYm91bmQgPSB0eXBlSW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbnZhciBQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCogZ2V0UGFydGlhbCQyLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMi5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGdldFBhcnRpYWwkMih0aGlzKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNQYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzUGFyYW1zKCkge1xuICAgICAgdmFyIF9nZXRQYXJ0aWFsJHR5cGU7XG5cbiAgICAgIHJldHVybiAoX2dldFBhcnRpYWwkdHlwZSA9IGdldFBhcnRpYWwkMih0aGlzKS50eXBlKS5hY2NlcHRzUGFyYW1zLmFwcGx5KF9nZXRQYXJ0aWFsJHR5cGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c1JldHVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNSZXR1cm4oaW5wdXQpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDIodGhpcykudHlwZS5hY2NlcHRzUmV0dXJuKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRQYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnRQYXJhbXMoKSB7XG4gICAgICB2YXIgX2dldFBhcnRpYWwkdHlwZTI7XG5cbiAgICAgIHJldHVybiAoX2dldFBhcnRpYWwkdHlwZTIgPSBnZXRQYXJ0aWFsJDIodGhpcykudHlwZSkuYXNzZXJ0UGFyYW1zLmFwcGx5KF9nZXRQYXJ0aWFsJHR5cGUyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFJldHVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFJldHVybihpbnB1dCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMih0aGlzKS50eXBlLmFzc2VydFJldHVybihpbnB1dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDIuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gZ2V0UGFydGlhbCQyKHRoaXMpO1xuICAgICAgdmFyIHR5cGUgPSBwYXJ0aWFsLnR5cGUsXG4gICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJ0aWFsLnR5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0eXBlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZVBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgaXRlbXMucHVzaCh0eXBlUGFyYW1ldGVyLnRvU3RyaW5nKHRydWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgPCR7aXRlbXMuam9pbignLCAnKX0+ICR7dHlwZS50b1N0cmluZygpfWA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIHBhcnRpYWwgPSBnZXRQYXJ0aWFsJDIodGhpcyk7XG4gICAgICByZXR1cm4gcGFydGlhbC50b0pTT04oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlUGFyYW1ldGVycycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhcmFtcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGUucGFyYW1zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3QnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMih0aGlzKS50eXBlLnJlc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmV0dXJuVHlwZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGUucmV0dXJuVHlwZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGU7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiBnZXRQYXJ0aWFsJDIocGFyZW50KSB7XG4gIHZhciBjb250ZXh0ID0gcGFyZW50LmNvbnRleHQsXG4gICAgICBib2R5Q3JlYXRvciA9IHBhcmVudC5ib2R5Q3JlYXRvcjtcblxuICB2YXIgcGFydGlhbCA9IG5ldyBQYXJ0aWFsVHlwZShjb250ZXh0KTtcbiAgdmFyIGJvZHkgPSBib2R5Q3JlYXRvcihwYXJ0aWFsKTtcbiAgcGFydGlhbC50eXBlID0gY29udGV4dC5mdW5jdGlvbi5hcHBseShjb250ZXh0LCB0b0NvbnN1bWFibGVBcnJheShib2R5KSk7XG5cbiAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gcGFydGlhbC50eXBlUGFyYW1ldGVycztcblxuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgdHlwZUluc3RhbmNlc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHZhciBsaW1pdCA9IE1hdGgubWluKHR5cGVJbnN0YW5jZXMubGVuZ3RoLCB0eXBlUGFyYW1ldGVycy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgIHZhciB0eXBlSW5zdGFuY2UgPSB0eXBlSW5zdGFuY2VzW2ldO1xuICAgIGlmICh0eXBlUGFyYW1ldGVyLmJvdW5kICYmIHR5cGVQYXJhbWV0ZXIuYm91bmQgIT09IHR5cGVJbnN0YW5jZSkge1xuICAgICAgLy8gaWYgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIGFscmVhZHkgYm91bmQgd2UgbmVlZCB0b1xuICAgICAgLy8gY3JlYXRlIGFuIGludGVyc2VjdGlvbiB0eXBlIHdpdGggdGhpcyBvbmUuXG4gICAgICB0eXBlUGFyYW1ldGVyLmJvdW5kID0gY29udGV4dC5pbnRlcnNlY3QodHlwZVBhcmFtZXRlci5ib3VuZCwgdHlwZUluc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVBhcmFtZXRlci5ib3VuZCA9IHR5cGVJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydGlhbDtcbn1cblxudmFyIFJlZmluZW1lbnRUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFJlZmluZW1lbnRUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVmaW5lbWVudFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVmaW5lbWVudFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gUmVmaW5lbWVudFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWZpbmVtZW50VHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1JlZmluZW1lbnRUeXBlJywgX3RoaXMuY29uc3RyYWludHMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJlZmluZW1lbnRUeXBlLCBbe1xuICAgIGtleTogJ2FkZENvbnN0cmFpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdHJhaW50KCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBjb25zdHJhaW50cyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGFkZENvbnN0cmFpbnRzLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25zdHJhaW50cykpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRXJyb3JzKSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0Q29uc3RyYWludEVycm9ycyh0aGlzLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghY29uc3RyYWludHNBY2NlcHQodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24odGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC50eXBlSW5zdGFuY2VzID0gdHlwZUluc3RhbmNlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy51bndyYXAoKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuaGFzUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmhhc1Byb3BlcnR5KG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy51bndyYXAoKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmdldFByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgcmV0dXJuIGAkUmVmaW5tZW50PCR7dHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZWZpbmVtZW50VHlwZTtcbn0oVHlwZSk7XG5cbnZhciBTdHJpbmdMaXRlcmFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhTdHJpbmdMaXRlcmFsVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0xpdGVyYWxUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0xpdGVyYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFN0cmluZ0xpdGVyYWxUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nTGl0ZXJhbFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdTdHJpbmdMaXRlcmFsVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTdHJpbmdMaXRlcmFsVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5wdXQgIT09IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfRVhBQ1RfVkFMVUUnLCB0aGlzLnRvU3RyaW5nKCkpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ID09PSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN0cmluZ0xpdGVyYWxUeXBlICYmIGlucHV0LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RyaW5nTGl0ZXJhbFR5cGU7XG59KFR5cGUpO1xuXG52YXIgU3RyaW5nVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhTdHJpbmdUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gU3RyaW5nVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFN0cmluZ1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnU3RyaW5nVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTdHJpbmdUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfU1RSSU5HJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmdMaXRlcmFsVHlwZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmdUeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJpbmdUeXBlO1xufShUeXBlKTtcblxudmFyIFN5bWJvbExpdGVyYWxUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFN5bWJvbExpdGVyYWxUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gU3ltYm9sTGl0ZXJhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ltYm9sTGl0ZXJhbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gU3ltYm9sTGl0ZXJhbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW1ib2xMaXRlcmFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1N5bWJvbExpdGVyYWxUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN5bWJvbExpdGVyYWxUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgICAgIGlmIChpbnB1dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9FWEFDVF9WQUxVRScsIHRoaXMudG9TdHJpbmcoKSksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgPT09IHRoaXMudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU3ltYm9sTGl0ZXJhbFR5cGUgJiYgaW5wdXQudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgdHlwZW9mICR7U3RyaW5nKHRoaXMudmFsdWUpfWA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3ltYm9sTGl0ZXJhbFR5cGU7XG59KFR5cGUpO1xuXG52YXIgU3ltYm9sVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhTeW1ib2xUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gU3ltYm9sVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTeW1ib2xUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFN5bWJvbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW1ib2xUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnU3ltYm9sVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTeW1ib2xUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9TWU1CT0wnKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzeW1ib2wnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN5bWJvbExpdGVyYWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN5bWJvbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN5bWJvbFR5cGU7XG59KFR5cGUpO1xuXG4vKipcbiAqICMgVGhpc1R5cGVcbiAqIENhcHR1cmVzIGEgcmVmZXJlbmNlIHRvIGEgcGFydGljdWxhciBpbnN0YW5jZSBvZiBhIGNsYXNzIG9yIGEgdmFsdWUsXG4gKiBhbmQgdXNlcyB0aGF0IHZhbHVlIHRvIHBlcmZvcm0gYW4gaWRlbnRpdHkgY2hlY2suXG4gKiBJbiB0aGUgY2FzZSB0aGF0IGB0aGlzYCBpcyB1bmRlZmluZWQsIGFueSB2YWx1ZSB3aWxsIGJlIHBlcm1pdHRlZC5cbiAqL1xuXG52YXIgVGhpc1R5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVGhpc1R5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUaGlzVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaGlzVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUaGlzVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRoaXNUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVGhpc1R5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVGhpc1R5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHJlY29yZGVkID0gdGhpcy5yZWNvcmRlZDtcblxuICAgICAgaWYgKGlucHV0ID09PSByZWNvcmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWNvcmRlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIHJlY29yZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkZWQgIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX1RISVMnKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciByZWNvcmRlZCA9IHRoaXMucmVjb3JkZWQ7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gcmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWNvcmRlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIHJlY29yZGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgVGhpc1R5cGUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQucmVjb3JkZWQgJiYgdGhpcy5yZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVjb3JkZWQgPT09IHRoaXMucmVjb3JkZWQgPyAwIDogLTE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcod2l0aEJpbmRpbmcpIHtcbiAgICAgIHJldHVybiAndGhpcyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUaGlzVHlwZTtcbn0oVHlwZSk7XG5cbnZhciB3YXJuZWRJbnN0YW5jZXMkMSA9IG5ldyBXZWFrU2V0KCk7XG5cbnZhciBUeXBlQm94ID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVCb3gsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUeXBlQm94KCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVCb3gpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZUJveC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGVCb3gpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlQm94JywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVCb3gsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcy50eXBlO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC50eXBlSW5zdGFuY2VzID0gdHlwZUluc3RhbmNlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS50b0pTT04oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUubmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciByZXZlYWwgPSB0aGlzLnJldmVhbDtcblxuICAgICAgdmFyIHR5cGUgPSByZXZlYWwoKTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICBpZiAoIXdhcm5lZEluc3RhbmNlcyQxLmhhcyh0aGlzKSkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5lbWl0V2FybmluZ01lc3NhZ2UoJ0ZhaWxlZCB0byByZXZlYWwgYm94ZWQgdHlwZS4nKTtcbiAgICAgICAgICB3YXJuZWRJbnN0YW5jZXMkMS5hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5taXhlZCgpO1xuICAgICAgfSBlbHNlIGlmICghKHR5cGUgaW5zdGFuY2VvZiBUeXBlKSkge1xuICAgICAgICAvLyB3ZSBnb3QgYSBib3hlZCByZWZlcmVuY2UgdG8gc29tZXRoaW5nIGxpa2UgYSBjbGFzc1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlZih0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZUJveDtcbn0oVHlwZSk7XG5cbnZhciB3YXJuZWRNaXNzaW5nID0ge307XG5cbnZhciBUeXBlUmVmZXJlbmNlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVSZWZlcmVuY2UsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUeXBlUmVmZXJlbmNlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVSZWZlcmVuY2UpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZVJlZmVyZW5jZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGVSZWZlcmVuY2UpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlUmVmZXJlbmNlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVSZWZlcmVuY2UsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LmdldChuYW1lKTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICBpZiAoIXdhcm5lZE1pc3NpbmdbbmFtZV0pIHtcbiAgICAgICAgICBjb250ZXh0LmVtaXRXYXJuaW5nTWVzc2FnZShgQ2Fubm90IHJlc29sdmUgdHlwZTogJHtuYW1lfWApO1xuICAgICAgICAgIHdhcm5lZE1pc3NpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LmFueSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlUmVmZXJlbmNlO1xufShUeXBlKTtcblxudmFyIHdhcm5lZEluc3RhbmNlcyQyID0gbmV3IFdlYWtTZXQoKTtcblxudmFyIFJldmVhbGVkTmFtZSA9IFN5bWJvbCgnUmV2ZWFsZWROYW1lJyk7XG52YXIgUmV2ZWFsZWRWYWx1ZSA9IFN5bWJvbCgnUmV2ZWFsZWRWYWx1ZScpO1xuXG52YXIgVHlwZVREWiA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhUeXBlVERaLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVHlwZVREWigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlVERaKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFR5cGVURFouX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlVERaKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVHlwZVREWicsIF90aGlzW1JldmVhbGVkTmFtZV0gPSB1bmRlZmluZWQsIF90aGlzW1JldmVhbGVkVmFsdWVdID0gdW5kZWZpbmVkLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVURFosIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIGdldFJldmVhbGVkKHRoaXMpLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBnZXRSZXZlYWxlZCh0aGlzKS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGdldFJldmVhbGVkKHRoaXMpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gZ2V0UmV2ZWFsZWQodGhpcyk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiBnZXRSZXZlYWxlZCh0aGlzKS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmhhc1Byb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5oYXNQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5nZXRQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGdldFJldmVhbGVkKHRoaXMpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIGdldFJldmVhbGVkKHRoaXMpLnRvSlNPTigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzW1JldmVhbGVkTmFtZV07XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgbmFtZSA9IGdldFJldmVhbGVkKHRoaXMpLm5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICB0aGlzW1JldmVhbGVkTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVURFo7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiBnZXRSZXZlYWxlZChjb250YWluZXIpIHtcbiAgdmFyIGV4aXN0aW5nID0gY29udGFpbmVyW1JldmVhbGVkVmFsdWVdO1xuICBpZiAoZXhpc3RpbmcpIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJldmVhbCA9IGNvbnRhaW5lci5yZXZlYWw7XG5cbiAgICB2YXIgdHlwZSA9IHJldmVhbCgpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgaWYgKCF3YXJuZWRJbnN0YW5jZXMkMi5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICB2YXIgbmFtZSA9IGNvbnRhaW5lcltSZXZlYWxlZE5hbWVdO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIGNvbnRhaW5lci5jb250ZXh0LmVtaXRXYXJuaW5nTWVzc2FnZShgRmFpbGVkIHRvIHJldmVhbCB0eXBlIGNhbGxlZCBcIiR7bmFtZX1cIiBpbiBUZW1wb3JhbCBEZWFkIFpvbmUuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyLmNvbnRleHQuZW1pdFdhcm5pbmdNZXNzYWdlKCdGYWlsZWQgdG8gcmV2ZWFsIHVua25vd24gdHlwZSBpbiBUZW1wb3JhbCBEZWFkIFpvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmVkSW5zdGFuY2VzJDIuYWRkKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNvbnRleHQubWl4ZWQoKTtcbiAgICB9IGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICAvLyB3ZSBnb3QgYSBib3hlZCByZWZlcmVuY2UgdG8gc29tZXRoaW5nIGxpa2UgYSBjbGFzc1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250ZXh0LnJlZih0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn1cblxudmFyIFVuaW9uVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhVbmlvblR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBVbmlvblR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5pb25UeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFVuaW9uVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuaW9uVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1VuaW9uVHlwZScsIF90aGlzLnR5cGVzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhVbmlvblR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9OT19VTklPTicsIHRoaXMudG9TdHJpbmcoKSksIHRoaXNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVuaW9uVHlwZSkge1xuICAgICAgICB2YXIgaW5wdXRUeXBlcyA9IGlucHV0LnR5cGVzO1xuICAgICAgICB2YXIgaWRlbnRpY2FsQ291bnQgPSAwO1xuICAgICAgICBsb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0VHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXModHlwZSwgaW5wdXRUeXBlc1tpXSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlkZW50aWNhbENvdW50Kys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiBub3RoaW5nIGFjY2VwdGVkIHRoaXMgdHlwZS5cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRlbnRpY2FsQ291bnQgPT09IHR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF90eXBlID0gdHlwZXNbX2ldO1xuICAgICAgICAgIGlmIChjb21wYXJlVHlwZXMoX3R5cGUsIGlucHV0KSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuXG4gICAgICB2YXIgbm9ybWFsaXplZCA9IG5ldyBBcnJheSh0eXBlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZS50eXBlTmFtZSA9PT0gJ0Z1bmN0aW9uVHlwZScgfHwgdHlwZS50eXBlTmFtZSA9PT0gJ1BhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUnKSB7XG4gICAgICAgICAgbm9ybWFsaXplZFtpXSA9IGAoJHt0eXBlLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9ybWFsaXplZFtpXSA9IHR5cGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQuam9pbignIHwgJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGVzOiB0aGlzLnR5cGVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVW5pb25UeXBlO1xufShUeXBlKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJQcmltaXRpdmVUeXBlcyh0KSB7XG4gIHByaW1pdGl2ZVR5cGVzLm51bGwgPSBPYmplY3QuZnJlZXplKG5ldyBOdWxsTGl0ZXJhbFR5cGUodCkpO1xuICBwcmltaXRpdmVUeXBlcy5lbXB0eSA9IE9iamVjdC5mcmVlemUobmV3IEVtcHR5VHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLm51bWJlciA9IE9iamVjdC5mcmVlemUobmV3IE51bWJlclR5cGUodCkpO1xuICBwcmltaXRpdmVUeXBlcy5ib29sZWFuID0gT2JqZWN0LmZyZWV6ZShuZXcgQm9vbGVhblR5cGUodCkpO1xuICBwcmltaXRpdmVUeXBlcy5zdHJpbmcgPSBPYmplY3QuZnJlZXplKG5ldyBTdHJpbmdUeXBlKHQpKTtcbiAgcHJpbWl0aXZlVHlwZXMuc3ltYm9sID0gT2JqZWN0LmZyZWV6ZShuZXcgU3ltYm9sVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLmFueSA9IE9iamVjdC5mcmVlemUobmV3IEFueVR5cGUodCkpO1xuICBwcmltaXRpdmVUeXBlcy5taXhlZCA9IE9iamVjdC5mcmVlemUobmV3IE1peGVkVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLnZvaWQgPSBPYmplY3QuZnJlZXplKG5ldyBWb2lkVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLmV4aXN0ZW50aWFsID0gT2JqZWN0LmZyZWV6ZShuZXcgRXhpc3RlbnRpYWxUeXBlKHQpKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQnVpbHRpblR5cGVDb25zdHJ1Y3RvcnModCkge1xuXG4gIHQuZGVjbGFyZVR5cGVDb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogJ0RhdGUnLFxuICAgIGltcGw6IERhdGUsXG4gICAgdHlwZU5hbWU6ICdEYXRlVHlwZScsXG4gICAgKmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0lOU1RBTkNFT0YnLCAnRGF0ZScpLCB0aGlzXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4oaW5wdXQuZ2V0VGltZSgpKSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfSU5WQUxJRF9EQVRFJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oaW5wdXQuZ2V0VGltZSgpKTtcbiAgICB9LFxuICAgIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQudHlwZU5hbWUgPT09ICdEYXRlVHlwZScpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBpbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcblxuICB0LmRlY2xhcmVUeXBlQ29uc3RydWN0b3Ioe1xuICAgIG5hbWU6ICdQcm9taXNlJyxcbiAgICBpbXBsOiBQcm9taXNlLFxuICAgIHR5cGVOYW1lOiAnUHJvbWlzZVR5cGUnLFxuICAgICplcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQsIGZ1dHVyZVR5cGUpIHtcbiAgICAgIGludmFyaWFudChmdXR1cmVUeXBlLCAnTXVzdCBzcGVjaWZ5IHR5cGUgcGFyYW1ldGVyIGZvciBQcm9taXNlLicpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnUHJvbWlzZScsIGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX1BST01JU0UnLCBmdXR1cmVUeXBlKSwgdGhpc107XG4gICAgICB9XG4gICAgfSxcbiAgICBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgcmV0dXJuIGNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ1Byb21pc2UnLCBpbnB1dCk7XG4gICAgfSxcbiAgICBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LnR5cGVOYW1lID09PSAnUHJvbWlzZVR5cGUnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgaW5mZXJUeXBlUGFyYW1ldGVycyhpbnB1dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG5cbiAgdC5kZWNsYXJlVHlwZUNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiAnTWFwJyxcbiAgICBpbXBsOiBNYXAsXG4gICAgdHlwZU5hbWU6ICdNYXBUeXBlJyxcbiAgICAqZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0LCBrZXlUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICAgIGludmFyaWFudChrZXlUeXBlLCAnTXVzdCBzcGVjaWZ5IHR3byB0eXBlIHBhcmFtZXRlcnMgZm9yIE1hcC4nKTtcbiAgICAgIGludmFyaWFudCh2YWx1ZVR5cGUsICdNdXN0IHNwZWNpZnkgdHdvIHR5cGUgcGFyYW1ldGVycyBmb3IgTWFwLicpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnTWFwJywgaW5wdXQpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfSU5TVEFOQ0VPRicsICdNYXAnKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICAgICAgICAgIHZhciBrZXkgPSBfcmVmMlswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgICAgIGlmICgha2V5VHlwZS5hY2NlcHRzKGtleSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfS0VZX1RZUEUnLCBrZXlUeXBlKSwgdGhpc107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeWllbGQqIHZhbHVlVHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQoa2V5KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFjY2VwdHMoaW5wdXQsIGtleVR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnTWFwJywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JlZjMgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3JlZjQgPSBzbGljZWRUb0FycmF5KF9yZWYzLCAyKTtcblxuICAgICAgICAgIHZhciBrZXkgPSBfcmVmNFswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNFsxXTtcblxuICAgICAgICAgIGlmICgha2V5VHlwZS5hY2NlcHRzKGtleSkgfHwgIXZhbHVlVHlwZS5hY2NlcHRzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQudHlwZU5hbWUgPT09ICdNYXBUeXBlJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGluZmVyVHlwZVBhcmFtZXRlcnMoaW5wdXQpIHtcbiAgICAgIHZhciBrZXlUeXBlcyA9IFtdO1xuICAgICAgdmFyIHZhbHVlVHlwZXMgPSBbXTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsb29wOiBmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JlZjUgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3JlZjYgPSBzbGljZWRUb0FycmF5KF9yZWY1LCAyKTtcblxuICAgICAgICAgIHZhciBrZXkgPSBfcmVmNlswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNlsxXTtcblxuICAgICAgICAgIGZpbmRLZXk6IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBrZXlUeXBlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUuYWNjZXB0cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgZmluZEtleTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5VHlwZXMucHVzaCh0LnR5cGVPZihrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdmFsdWVUeXBlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfdHlwZSA9IHZhbHVlVHlwZXNbX2ldO1xuICAgICAgICAgICAgaWYgKF90eXBlLmFjY2VwdHModmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlVHlwZXMucHVzaCh0LnR5cGVPZih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlSW5zdGFuY2VzID0gW107XG5cbiAgICAgIGlmIChrZXlUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdHlwZUluc3RhbmNlcy5wdXNoKHQuZXhpc3RlbnRpYWwoKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0eXBlSW5zdGFuY2VzLnB1c2goa2V5VHlwZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZUluc3RhbmNlcy5wdXNoKHQudW5pb24uYXBwbHkodCwga2V5VHlwZXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXMucHVzaCh0LmV4aXN0ZW50aWFsKCkpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0eXBlSW5zdGFuY2VzLnB1c2godmFsdWVUeXBlc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlSW5zdGFuY2VzLnB1c2godC51bmlvbi5hcHBseSh0LCB2YWx1ZVR5cGVzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlSW5zdGFuY2VzO1xuICAgIH1cbiAgfSk7XG5cbiAgdC5kZWNsYXJlVHlwZUNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiAnU2V0JyxcbiAgICBpbXBsOiBTZXQsXG4gICAgdHlwZU5hbWU6ICdTZXRUeXBlJyxcbiAgICAqZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0LCB2YWx1ZVR5cGUpIHtcbiAgICAgIGludmFyaWFudCh2YWx1ZVR5cGUsICdNdXN0IHNwZWNpZnkgdHlwZSBwYXJhbWV0ZXIgZm9yIFNldC4nKTtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ1NldCcsIGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0lOU1RBTkNFT0YnLCAnU2V0JyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgeWllbGQqIHZhbHVlVHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhY2NlcHRzKGlucHV0LCB2YWx1ZVR5cGUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ1NldCcsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCF2YWx1ZVR5cGUuYWNjZXB0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LnR5cGVOYW1lID09PSAnU2V0VHlwZScpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBpbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KSB7XG4gICAgICB2YXIgdmFsdWVUeXBlcyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvb3A6IGZvciAodmFyIF9pdGVyYXRvcjYgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB2YWx1ZVR5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGUuYWNjZXB0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVUeXBlcy5wdXNoKHQudHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbdC5leGlzdGVudGlhbCgpXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZVR5cGVzWzBdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbdC51bmlvbi5hcHBseSh0LCB2YWx1ZVR5cGVzKV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlUHJlZGljYXRlcyhjb250ZXh0KSB7XG4gIGNvbnRleHQuc2V0UHJlZGljYXRlKCdBcnJheScsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KTtcbiAgfSk7XG4gIGNvbnRleHQuc2V0UHJlZGljYXRlKCdNYXAnLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBNYXA7XG4gIH0pO1xuICBjb250ZXh0LnNldFByZWRpY2F0ZSgnU2V0JywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgU2V0O1xuICB9KTtcbiAgY29udGV4dC5zZXRQcmVkaWNhdGUoJ1Byb21pc2UnLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlucHV0ICE9PSBudWxsICYmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIFR5cGVJbmZlcmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUeXBlSW5mZXJlcihjb250ZXh0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZUluZmVyZXIpO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVJbmZlcmVyLCBbe1xuICAgIGtleTogJ2luZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXIoaW5wdXQpIHtcbiAgICAgIHZhciBwcmltaXRpdmUgPSB0aGlzLmluZmVyUHJpbWl0aXZlKGlucHV0KTtcbiAgICAgIGlmIChwcmltaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmZlcnJlZCA9IG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiB0aGlzLmluZmVyQ29tcGxleChpbnB1dCwgaW5mZXJyZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZmVySW50ZXJuYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlckludGVybmFsKGlucHV0LCBpbmZlcnJlZCkge1xuICAgICAgdmFyIHByaW1pdGl2ZSA9IHRoaXMuaW5mZXJQcmltaXRpdmUoaW5wdXQpO1xuICAgICAgaWYgKHByaW1pdGl2ZSkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaW5mZXJDb21wbGV4KGlucHV0LCBpbmZlcnJlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mZXJQcmltaXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlclByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5udWxsKCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudm9pZCgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lm51bWJlcigpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5ib29sZWFuKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc3RyaW5nKCk7XG4gICAgICB9XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5zeW1ib2woaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlckNvbXBsZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlckNvbXBsZXgoaW5wdXQsIGluZmVycmVkKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZmVyRnVuY3Rpb24oaW5wdXQsIGluZmVycmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZlck9iamVjdChpbnB1dCwgaW5mZXJyZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYW55KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mZXJGdW5jdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZmVyRnVuY3Rpb24oaW5wdXQsIGluZmVycmVkKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHZhciBib2R5ID0gbmV3IEFycmF5KGxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBib2R5W2ldID0gY29udGV4dC5wYXJhbShTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgaSksIGNvbnRleHQuZXhpc3RlbnRpYWwoKSk7XG4gICAgICB9XG4gICAgICBib2R5W2xlbmd0aF0gPSBjb250ZXh0LnJldHVybihjb250ZXh0LmV4aXN0ZW50aWFsKCkpO1xuICAgICAgcmV0dXJuIGNvbnRleHQuZm4uYXBwbHkoY29udGV4dCwgYm9keSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mZXJPYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlck9iamVjdChpbnB1dCwgaW5mZXJyZWQpIHtcbiAgICAgIHZhciBleGlzdGluZyA9IGluZmVycmVkLmdldChpbnB1dCk7XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0eXBlID0gdm9pZCAwO1xuXG4gICAgICAvLyBUZW1wb3JhcmlseSBjcmVhdGUgYSBib3ggZm9yIHRoaXMgdHlwZSB0byBjYXRjaCBjeWNsaWNhbCByZWZlcmVuY2VzLlxuICAgICAgLy8gTmVzdGVkIHJlZmVyZW5jZXMgdG8gdGhpcyBvYmplY3Qgd2lsbCByZWNlaXZlIHRoZSBib3hlZCB0eXBlLlxuICAgICAgdmFyIGJveCA9IGNvbnRleHQuYm94KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9KTtcbiAgICAgIGluZmVycmVkLnNldChpbnB1dCwgYm94KTtcblxuICAgICAgaWYgKGNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ0FycmF5JywgaW5wdXQpKSB7XG4gICAgICAgIHR5cGUgPSB0aGlzLmluZmVyQXJyYXkoaW5wdXQsIGluZmVycmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuaW5mZXJEaWN0KGlucHV0LCBpbmZlcnJlZCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjb250ZXh0LmdldFR5cGVDb25zdHJ1Y3RvcihpbnB1dC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gaGFuZGxlci5pbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KTtcbiAgICAgICAgICB0eXBlID0gaGFuZGxlci5hcHBseS5hcHBseShoYW5kbGVyLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlUGFyYW1ldGVycykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBjb250ZXh0LnJlZihpbnB1dC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGJvZHkucHVzaChjb250ZXh0LnByb3BlcnR5KGtleSwgdGhpcy5pbmZlckludGVybmFsKHZhbHVlLCBpbmZlcnJlZCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gY29udGV4dC5vYmplY3QuYXBwbHkoY29udGV4dCwgYm9keSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgYm94IHdpdGggdGhlIHJlYWwgdmFsdWUuXG4gICAgICBpbmZlcnJlZC5zZXQoaW5wdXQsIHR5cGUpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mZXJEaWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXJEaWN0KGlucHV0LCBpbmZlcnJlZCkge1xuICAgICAgdmFyIG51bWVyaWNJbmRleGVycyA9IFtdO1xuICAgICAgdmFyIHN0cmluZ0luZGV4ZXJzID0gW107XG4gICAgICBsb29wOiBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgICAgICB2YXIgdHlwZXMgPSBpc05hTigra2V5KSA/IHN0cmluZ0luZGV4ZXJzIDogbnVtZXJpY0luZGV4ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICBpZiAodHlwZS5hY2NlcHRzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLmluZmVySW50ZXJuYWwodmFsdWUsIGluZmVycmVkKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgaWYgKG51bWVyaWNJbmRleGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYm9keS5wdXNoKGNvbnRleHQuaW5kZXhlcignaW5kZXgnLCBjb250ZXh0Lm51bWJlcigpLCBudW1lcmljSW5kZXhlcnNbMF0pKTtcbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpY0luZGV4ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYm9keS5wdXNoKGNvbnRleHQuaW5kZXhlcignaW5kZXgnLCBjb250ZXh0Lm51bWJlcigpLCBjb250ZXh0LnVuaW9uLmFwcGx5KGNvbnRleHQsIG51bWVyaWNJbmRleGVycykpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmluZ0luZGV4ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBib2R5LnB1c2goY29udGV4dC5pbmRleGVyKCdrZXknLCBjb250ZXh0LnN0cmluZygpLCBzdHJpbmdJbmRleGVyc1swXSkpO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdJbmRleGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGJvZHkucHVzaChjb250ZXh0LmluZGV4ZXIoJ2tleScsIGNvbnRleHQuc3RyaW5nKCksIGNvbnRleHQudW5pb24uYXBwbHkoY29udGV4dCwgc3RyaW5nSW5kZXhlcnMpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0Lm9iamVjdC5hcHBseShjb250ZXh0LCBib2R5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlckFycmF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXJBcnJheShpbnB1dCwgaW5mZXJyZWQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIGxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpXTtcbiAgICAgICAgdmFyIGluZmVycmVkVHlwZSA9IHRoaXMuaW5mZXJJbnRlcm5hbChpdGVtLCBpbmZlcnJlZCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2pdO1xuICAgICAgICAgIGlmICh0eXBlLmFjY2VwdHMoaXRlbSkgJiYgaW5mZXJyZWRUeXBlLmFjY2VwdHModmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMucHVzaChpbmZlcnJlZFR5cGUpO1xuICAgICAgICB2YWx1ZXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYXJyYXkoY29udGV4dC5hbnkoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5hcnJheSh0eXBlc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5hcnJheShjb250ZXh0LnVuaW9uLmFwcGx5KGNvbnRleHQsIHR5cGVzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlSW5mZXJlcjtcbn0oKTtcblxuZnVuY3Rpb24gbWFrZVJlYWN0UHJvcFR5cGVzKG9iamVjdFR5cGUpIHtcbiAgdmFyIG91dHB1dCA9IHt9O1xuICBpZiAoIW9iamVjdFR5cGUucHJvcGVydGllcykge1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wZXJ0eSkge1xuICAgIG91dHB1dFtwcm9wZXJ0eS5rZXldID0gZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgcmV0dXJuIG1ha2VFcnJvcihwcm9wZXJ0eSwgcHJvcHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb2JqZWN0VHlwZS5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIF9sb29wKHByb3BlcnR5KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxudmFyIGRlbGltaXRlciQxID0gJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4nO1xuXG5mdW5jdGlvbiBtYWtlV2FybmluZ01lc3NhZ2UodmFsaWRhdGlvbikge1xuICBpZiAoIXZhbGlkYXRpb24uaGFzRXJyb3JzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlucHV0ID0gdmFsaWRhdGlvbi5pbnB1dCxcbiAgICAgIGNvbnRleHQgPSB2YWxpZGF0aW9uLmNvbnRleHQ7XG5cbiAgdmFyIGNvbGxlY3RlZCA9IFtdO1xuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB2YWxpZGF0aW9uLmVycm9yc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBfcmVmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBfcmVmMiA9IHNsaWNlZFRvQXJyYXkoX3JlZiwgMyk7XG5cbiAgICAgIHZhciBwYXRoID0gX3JlZjJbMF07XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWYyWzFdO1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IF9yZWYyWzJdO1xuXG4gICAgICB2YXIgZXhwZWN0ZWQgPSBleHBlY3RlZFR5cGUgPyBleHBlY3RlZFR5cGUudG9TdHJpbmcoKSA6IFwiKlwiO1xuICAgICAgdmFyIGFjdHVhbCA9IGNvbnRleHQudHlwZU9mKF9yZXNvbHZlUGF0aChpbnB1dCwgcGF0aCkpLnRvU3RyaW5nKCk7XG5cbiAgICAgIHZhciBmaWVsZCA9IHN0cmluZ2lmeVBhdGgodmFsaWRhdGlvbi5wYXRoLmNvbmNhdChwYXRoKSk7XG5cbiAgICAgIGNvbGxlY3RlZC5wdXNoKGAke2ZpZWxkfSAke21lc3NhZ2V9XFxuXFxuRXhwZWN0ZWQ6ICR7ZXhwZWN0ZWR9XFxuXFxuQWN0dWFsOiAke2FjdHVhbH1cXG5gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBXYXJuaW5nOiAke2NvbGxlY3RlZC5qb2luKGRlbGltaXRlciQxKX1gO1xufVxuXG5mdW5jdGlvbiBtYWtlVW5pb24oY29udGV4dCwgdHlwZXMpIHtcbiAgdmFyIGxlbmd0aCA9IHR5cGVzLmxlbmd0aDtcbiAgdmFyIG1lcmdlZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEFueVR5cGUgfHwgdHlwZSBpbnN0YW5jZW9mIE1peGVkVHlwZSB8fCB0eXBlIGluc3RhbmNlb2YgRXhpc3RlbnRpYWxUeXBlKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBVbmlvblR5cGUpIHtcbiAgICAgIG1lcmdlVW5pb25UeXBlcyhtZXJnZWQsIHR5cGUudHlwZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWQucHVzaCh0eXBlKTtcbiAgICB9XG4gIH1cbiAgdmFyIHVuaW9uID0gbmV3IFVuaW9uVHlwZShjb250ZXh0KTtcbiAgdW5pb24udHlwZXMgPSBtZXJnZWQ7XG4gIHJldHVybiB1bmlvbjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VVbmlvblR5cGVzKGFUeXBlcywgYlR5cGVzKSB7XG4gIGxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgYlR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJUeXBlID0gYlR5cGVzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYVR5cGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgYVR5cGUgPSBhVHlwZXNbal07XG4gICAgICBpZiAoY29tcGFyZVR5cGVzKGFUeXBlLCBiVHlwZSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuICAgIGFUeXBlcy5wdXNoKGJUeXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUHJvcGVydHlEZXNjcmlwdG9yKHR5cGVTb3VyY2UsIGlucHV0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IsIHNob3VsZEFzc2VydCkge1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZXNjcmlwdG9yLnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdWdtZW50RXhpc3RpbmdBY2Nlc3NvcnModHlwZVNvdXJjZSwgaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgc2hvdWxkQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb0FjY2Vzc29yKHR5cGVTb3VyY2UsIGlucHV0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IsIHNob3VsZEFzc2VydCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVByb3BlcnR5TmFtZShuYW1lKSB7XG4gIHJldHVybiBgX2Zsb3dSdW50aW1lJCR7bmFtZX1gO1xufVxuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpbnB1dC5uYW1lIHx8ICdbQ2xhc3MgYW5vbnltb3VzXSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdldENsYXNzTmFtZShpbnB1dC5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdbQ2xhc3MgYW5vbnltb3VzXSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVR5cGUocmVjZWl2ZXIsIHR5cGVTb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiB0eXBlU291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGVTb3VyY2UuY2FsbChyZWNlaXZlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVTb3VyY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlUb0FjY2Vzc29yKHR5cGVTb3VyY2UsIGlucHV0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IsIHNob3VsZEFzc2VydCkge1xuICB2YXIgc2FmZU5hbWUgPSBtYWtlUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSk7XG4gIHZhciBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoaW5wdXQpO1xuICB2YXIgaW5pdGlhbGl6ZXIgPSBkZXNjcmlwdG9yLmluaXRpYWxpemVyLFxuICAgICAgd3JpdGFibGUgPSBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgY29uZmlnID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVzY3JpcHRvciwgWydpbml0aWFsaXplcicsICd3cml0YWJsZSddKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIHZhciBwcm9wZXJ0eVBhdGggPSBbY2xhc3NOYW1lLCBwcm9wZXJ0eU5hbWVdO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgY29uZmlnLCB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoc2FmZU5hbWUgaW4gdGhpcykge1xuICAgICAgICByZXR1cm4gdGhpc1tzYWZlTmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxpemVyKSB7XG4gICAgICAgIHZhciB0eXBlID0gcmVzb2x2ZVR5cGUodGhpcywgdHlwZVNvdXJjZSk7XG4gICAgICAgIHZhciBfdmFsdWUgPSBpbml0aWFsaXplci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGUuY29udGV4dDtcbiAgICAgICAgY29udGV4dC5jaGVjayh0eXBlLCBfdmFsdWUsICdEZWZhdWx0IHZhbHVlIGZvciBwcm9wZXJ0eScsIHByb3BlcnR5UGF0aCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzYWZlTmFtZSwge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc2FmZU5hbWUsIHtcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHJlc29sdmVUeXBlKHRoaXMsIHR5cGVTb3VyY2UpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0eXBlLmNvbnRleHQ7XG4gICAgICBpZiAoc2hvdWxkQXNzZXJ0KSB7XG4gICAgICAgIGNvbnRleHQuYXNzZXJ0KHR5cGUsIHZhbHVlLCAnUHJvcGVydHknLCBwcm9wZXJ0eVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC53YXJuKHR5cGUsIHZhbHVlLCAnUHJvcGVydHknLCBwcm9wZXJ0eVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHNhZmVOYW1lIGluIHRoaXMpIHtcbiAgICAgICAgdGhpc1tzYWZlTmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzYWZlTmFtZSwge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50RXhpc3RpbmdBY2Nlc3NvcnModHlwZVNvdXJjZSwgaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgc2hvdWxkQXNzZXJ0KSB7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShpbnB1dCk7XG4gIHZhciBwcm9wZXJ0eVBhdGggPSBbY2xhc3NOYW1lLCBwcm9wZXJ0eU5hbWVdO1xuXG4gIHZhciBvcmlnaW5hbFNldHRlciA9IGRlc2NyaXB0b3Iuc2V0O1xuXG4gIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSByZXNvbHZlVHlwZSh0aGlzLCB0eXBlU291cmNlKTtcbiAgICB2YXIgY29udGV4dCA9IHR5cGUuY29udGV4dDtcbiAgICBpZiAoc2hvdWxkQXNzZXJ0KSB7XG4gICAgICBjb250ZXh0LmFzc2VydCh0eXBlLCB2YWx1ZSwgJ1Byb3BlcnR5JywgcHJvcGVydHlQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC53YXJuKHR5cGUsIHZhbHVlLCAnUHJvcGVydHknLCBwcm9wZXJ0eVBhdGgpO1xuICAgIH1cbiAgICBvcmlnaW5hbFNldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gYW5ub3RhdGVWYWx1ZShpbnB1dCwgdHlwZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuICBpZiAodHlwZSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICBpbnB1dFtUeXBlU3ltYm9sXSA9IHR5cGU7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IGlucHV0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlucHV0W1R5cGVTeW1ib2xdID0gX3R5cGU7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBJZiBBIGFuZCBCIGFyZSBvYmplY3QgdHlwZXMsICREaWZmPEEsQj4gaXMgdGhlIHR5cGUgb2Ygb2JqZWN0cyB0aGF0IGhhdmVcbi8vIHByb3BlcnRpZXMgZGVmaW5lZCBpbiBBLCBidXQgbm90IGluIEIuXG4vLyBQcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gYm90aCBBIGFuZCBCIGFyZSBhbGxvd2VkIHRvby5cblxudmFyICREaWZmVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkRGlmZlR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkRGlmZlR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJERpZmZUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICREaWZmVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCREaWZmVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyREaWZmVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkRGlmZlR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIGFUeXBlID0gdGhpcy5hVHlwZSxcbiAgICAgICAgICBiVHlwZSA9IHRoaXMuYlR5cGU7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYVR5cGUgPSBhVHlwZS51bndyYXAoKTtcbiAgICAgIGJUeXBlID0gYlR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQoYVR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlICYmIGJUeXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICREaWZmIG9iamVjdCB0eXBlcy4nKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gYVR5cGUucHJvcGVydGllcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAoYlR5cGUuaGFzUHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiBwcm9wZXJ0eS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQocHJvcGVydHkua2V5KSwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgYVR5cGUgPSB0aGlzLmFUeXBlLFxuICAgICAgICAgIGJUeXBlID0gdGhpcy5iVHlwZTtcblxuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFUeXBlID0gYVR5cGUudW53cmFwKCk7XG4gICAgICBiVHlwZSA9IGJUeXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KGFUeXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSAmJiBiVHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkRGlmZiBvYmplY3QgdHlwZXMuJyk7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IGFUeXBlLnByb3BlcnRpZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGJUeXBlLmhhc1Byb3BlcnR5KHByb3BlcnR5LmtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3BlcnR5LmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciBhVHlwZSA9IHRoaXMuYVR5cGUsXG4gICAgICAgICAgYlR5cGUgPSB0aGlzLmJUeXBlO1xuXG4gICAgICBhVHlwZSA9IGFUeXBlLnVud3JhcCgpO1xuICAgICAgYlR5cGUgPSBiVHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudChhVHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUgJiYgYlR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJERpZmYgb2JqZWN0IHR5cGVzLicpO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBhVHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAoYlR5cGUuaGFzUHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9jb250ZXh0ID0gdGhpcy5jb250ZXh0KS5vYmplY3QuYXBwbHkoX2NvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCREaWZmPCR7dGhpcy5hVHlwZS50b1N0cmluZygpfSwgJHt0aGlzLmJUeXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIGFUeXBlOiB0aGlzLmFUeXBlLFxuICAgICAgICBiVHlwZTogdGhpcy5iVHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICREaWZmVHlwZTtcbn0oVHlwZSk7XG5cbi8vIEFueSBzdWJ0eXBlIG9mIFRcblxudmFyICRGbG93Rml4TWVUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRGbG93Rml4TWVUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJEZsb3dGaXhNZVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJEZsb3dGaXhNZVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJEZsb3dGaXhNZVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkRmxvd0ZpeE1lVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRGbG93Rml4TWVUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRGbG93Rml4TWVUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgaW5wdXQpIHtcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnJEZsb3dGaXhNZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkRmxvd0ZpeE1lVHlwZTtcbn0oVHlwZSk7XG5cbi8vIFRoZSBzZXQgb2Yga2V5cyBvZiBULlxuXG52YXIgJEtleXNUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRLZXlzVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRLZXlzVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkS2V5c1R5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJEtleXNUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJEtleXNUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJEtleXNUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRLZXlzVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICRLZXlzPFQ+IG9iamVjdCB0eXBlcy4nKTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChpbnB1dCA9PT0gcHJvcGVydHkua2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgICAgICBrZXlzW19pXSA9IHByb3BlcnRpZXNbX2ldLmtleTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9OT19VTklPTicsIGtleXMuam9pbignIHwgJykpLCB0aGlzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkS2V5czxUPiBvYmplY3QgdHlwZXMuJyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHByb3BlcnR5LmtleSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJEtleXM8VD4gb2JqZWN0IHR5cGVzLicpO1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGtleXNbaV0gPSBjb250ZXh0LmxpdGVyYWwocHJvcGVydHkua2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX2NvbnRleHQgPSB0aGlzLmNvbnRleHQpLnVuaW9uLmFwcGx5KF9jb250ZXh0LCBrZXlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkS2V5czwke3RoaXMudHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkS2V5c1R5cGU7XG59KFR5cGUpO1xuXG4vLyBNYXAgb3ZlciB0aGUga2V5cyBhbmQgdmFsdWVzIGluIGFuIG9iamVjdC5cblxudmFyICRPYmpNYXBpVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkT2JqTWFwaVR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkT2JqTWFwaVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJE9iak1hcGlUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRPYmpNYXBpVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRPYmpNYXBpVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRPYmpNYXBpVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkT2JqTWFwaVR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSwgcHJvcC52YWx1ZSk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtwcm9wLmtleV07XG4gICAgICAgICAgeWllbGQqIHJldHVyblR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KHByb3Aua2V5KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSwgcHJvcC52YWx1ZSk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtwcm9wLmtleV07XG4gICAgICAgICAgaWYgKCFyZXR1cm5UeXBlLmFjY2VwdHModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy51bndyYXAoKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdCxcbiAgICAgICAgICBtYXBwZXIgPSB0aGlzLm1hcHBlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gb2JqZWN0LnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3QgdHlwZS4nKTtcblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0YXJnZXQucHJvcGVydGllc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwcm9wID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGFwcGxpZWQgPSBtYXBwZXIudW53cmFwKCk7XG4gICAgICAgICAgaW52YXJpYW50KGFwcGxpZWQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUsICdNYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHR5cGUuJyk7XG5cbiAgICAgICAgICBhcmdzLnB1c2goY29udGV4dC5wcm9wZXJ0eShwcm9wLmtleSwgYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSwgcHJvcC52YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dC5vYmplY3QuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJE9iak1hcGk8JHt0aGlzLm9iamVjdC50b1N0cmluZygpfSwgJHt0aGlzLm1hcHBlci50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBvYmplY3Q6IHRoaXMub2JqZWN0LFxuICAgICAgICBtYXBwZXI6IHRoaXMubWFwcGVyXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gJE9iak1hcGlUeXBlO1xufShUeXBlKTtcblxuLy8gTWFwIG92ZXIgdGhlIGtleXMgaW4gYW4gb2JqZWN0LlxuXG52YXIgJE9iak1hcFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJE9iak1hcFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkT2JqTWFwVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkT2JqTWFwVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkT2JqTWFwVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRPYmpNYXBUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJE9iak1hcFR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJE9iak1hcFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtwcm9wLmtleV07XG4gICAgICAgICAgeWllbGQqIHJldHVyblR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KHByb3Aua2V5KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtwcm9wLmtleV07XG4gICAgICAgICAgaWYgKCFyZXR1cm5UeXBlLmFjY2VwdHModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy51bndyYXAoKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdCxcbiAgICAgICAgICBtYXBwZXIgPSB0aGlzLm1hcHBlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gb2JqZWN0LnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3QgdHlwZS4nKTtcblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0YXJnZXQucHJvcGVydGllc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwcm9wID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGFwcGxpZWQgPSBtYXBwZXIudW53cmFwKCk7XG4gICAgICAgICAgaW52YXJpYW50KGFwcGxpZWQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUsICdNYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHR5cGUuJyk7XG5cbiAgICAgICAgICBhcmdzLnB1c2goY29udGV4dC5wcm9wZXJ0eShwcm9wLmtleSwgYXBwbGllZC5pbnZva2UoY29udGV4dC5saXRlcmFsKHByb3Aua2V5KSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dC5vYmplY3QuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJE9iak1hcDwke3RoaXMub2JqZWN0LnRvU3RyaW5nKCl9LCAke3RoaXMubWFwcGVyLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG9iamVjdDogdGhpcy5vYmplY3QsXG4gICAgICAgIG1hcHBlcjogdGhpcy5tYXBwZXJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkT2JqTWFwVHlwZTtcbn0oVHlwZSk7XG5cbi8vIFRoZSB0eXBlIG9mIHRoZSBuYW1lZCBvYmplY3QgcHJvcGVydHlcblxudmFyICRQcm9wZXJ0eVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJFByb3BlcnR5VHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRQcm9wZXJ0eVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJFByb3BlcnR5VHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkUHJvcGVydHlUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJFByb3BlcnR5VHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRQcm9wZXJ0eVR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJFByb3BlcnR5VHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy51bndyYXAoKS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy51bndyYXAoKS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QsXG4gICAgICAgICAgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5O1xuXG4gICAgICB2YXIgdW53cmFwcGVkID0gb2JqZWN0LnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGVvZiB1bndyYXBwZWQuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicsICdDYW4gb25seSB1c2UgJFByb3BlcnR5VHlwZSBvbiBPYmplY3RzLicpO1xuICAgICAgcmV0dXJuIHVud3JhcHBlZC5nZXRQcm9wZXJ0eShwcm9wZXJ0eSkudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJFByb3BlcnR5VHlwZTwke3RoaXMub2JqZWN0LnRvU3RyaW5nKCl9LCAke1N0cmluZyh0aGlzLnByb3BlcnR5KX0+YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLm9iamVjdCxcbiAgICAgICAgcHJvcGVydHk6IHRoaXMucHJvcGVydHlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkUHJvcGVydHlUeXBlO1xufShUeXBlKTtcblxuLy8gQW4gb2JqZWN0IG9mIHR5cGUgJFNoYXBlPFQ+IGRvZXMgbm90IGhhdmUgdG8gaGF2ZSBhbGwgb2YgdGhlIHByb3BlcnRpZXNcbi8vIHRoYXQgdHlwZSBUIGRlZmluZXMuIEJ1dCB0aGUgdHlwZXMgb2YgdGhlIHByb3BlcnRpZXMgdGhhdCBpdCBkb2VzIGhhdmVcbi8vIG11c3QgYWNjZXB0cyB0aGUgdHlwZXMgb2YgdGhlIHNhbWUgcHJvcGVydGllcyBpbiBULlxuXG52YXIgJFNoYXBlVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkU2hhcGVUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJFNoYXBlVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkU2hhcGVUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRTaGFwZVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkU2hhcGVUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJFNoYXBlVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkU2hhcGVUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZS5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJywgJ0NhbiBvbmx5ICRTaGFwZTxUPiBvYmplY3QgdHlwZXMuJyk7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0eXBlLmdldFByb3BlcnR5KGtleSk7XG4gICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogcHJvcGVydHkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0eXBlID0gdHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZS5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJywgJ0NhbiBvbmx5ICRTaGFwZTxUPiBvYmplY3QgdHlwZXMuJyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdHlwZS5nZXRQcm9wZXJ0eShrZXkpO1xuICAgICAgICBpZiAoIXByb3BlcnR5IHx8ICFwcm9wZXJ0eS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgdHlwZSA9IHR5cGUudW53cmFwKCk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGludmFyaWFudCh0eXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICRTaGFwZTxUPiBvYmplY3QgdHlwZXMuJyk7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KHByb3BlcnRpZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBhcmdzW2ldID0gY29udGV4dC5wcm9wZXJ0eShwcm9wZXJ0eS5rZXksIHByb3BlcnR5LnZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX2NvbnRleHQgPSB0aGlzLmNvbnRleHQpLm9iamVjdC5hcHBseShfY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJFNoYXBlPCR7dGhpcy50eXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRTaGFwZVR5cGU7XG59KFR5cGUpO1xuXG4vLyBBbnkgc3VidHlwZSBvZiBUXG5cbnZhciAkU3ViVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkU3ViVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRTdWJUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRTdWJUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRTdWJUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJFN1YlR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckU3ViVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkU3ViVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyhpbnB1dCwgcGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkU3VidHlwZTwke3RoaXMudHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkU3ViVHlwZTtcbn0oVHlwZSk7XG5cbi8vIEFueSwgYnV0IGF0IGxlYXN0IFQuXG5cbnZhciAkU3VwZXJUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRTdXBlclR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkU3VwZXJUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRTdXBlclR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJFN1cGVyVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRTdXBlclR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckU3VwZXJUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRTdXBlclR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy51bndyYXAoKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJFN1cGVydHlwZTwke3RoaXMudHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkU3VwZXJUeXBlO1xufShUeXBlKTtcblxuLy8gTWFwIG92ZXIgdGhlIHZhbHVlcyBpbiBhIHR1cGxlLlxuXG52YXIgJFR1cGxlTWFwVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkVHVwbGVNYXBUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJFR1cGxlTWFwVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkVHVwbGVNYXBUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRUdXBsZU1hcFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkVHVwbGVNYXBUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJFR1cGxlTWFwVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkVHVwbGVNYXBUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0dXBsZSA9IHRoaXMudHVwbGUsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IHR1cGxlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHRhcmdldCBpbnN0YW5jZW9mIFR1cGxlVHlwZSwgJ1RhcmdldCBtdXN0IGJlIGEgdHVwbGUgdHlwZS4nKTtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0FSUkFZJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0LnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGVzW2ldO1xuICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgaW52YXJpYW50KGFwcGxpZWQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUsICdNYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHR5cGUuJyk7XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkID0gYXBwbGllZC5pbnZva2UodHlwZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgICB5aWVsZCogZXhwZWN0ZWQuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KGkpLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0dXBsZSA9IHRoaXMudHVwbGUsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IHR1cGxlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHRhcmdldCBpbnN0YW5jZW9mIFR1cGxlVHlwZSwgJ1RhcmdldCBtdXN0IGJlIGEgdHVwbGUgdHlwZS4nKTtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0LnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGVzW2ldO1xuICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgaW52YXJpYW50KGFwcGxpZWQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUsICdNYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHR5cGUuJyk7XG5cbiAgICAgICAgaWYgKCFhcHBsaWVkLmludm9rZSh0eXBlKS5hY2NlcHRzKGlucHV0W2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIHR1cGxlID0gdGhpcy50dXBsZSxcbiAgICAgICAgICBtYXBwZXIgPSB0aGlzLm1hcHBlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdHVwbGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgVHVwbGVUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYW4gdHVwbGUgdHlwZS4nKTtcblxuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0LnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGVzW2ldO1xuICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgaW52YXJpYW50KGFwcGxpZWQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUsICdNYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIHR5cGUuJyk7XG5cbiAgICAgICAgYXJncy5wdXNoKGFwcGxpZWQuaW52b2tlKHR5cGUpLnVud3JhcCgpLnVud3JhcCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQudHVwbGUuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJFR1cGxlTWFwPCR7dGhpcy50dXBsZS50b1N0cmluZygpfSwgJHt0aGlzLm1hcHBlci50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0dXBsZTogdGhpcy50dXBsZSxcbiAgICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRUdXBsZU1hcFR5cGU7XG59KFR5cGUpO1xuXG4vLyBUaGUgc2V0IG9mIGtleXMgb2YgVC5cblxudmFyICRWYWx1ZXNUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRWYWx1ZXNUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJFZhbHVlc1R5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJFZhbHVlc1R5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJFZhbHVlc1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkVmFsdWVzVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRWYWx1ZXNUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRWYWx1ZXNUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJFZhbHVlczxUPiBvYmplY3QgdHlwZXMuJyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAocHJvcGVydHkudmFsdWUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFsdWVzW19pXSA9IHByb3BlcnRpZXNbX2ldLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfTk9fVU5JT04nLCB2YWx1ZXMuam9pbignIHwgJykpLCB0aGlzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkVmFsdWVzPFQ+IG9iamVjdCB0eXBlcy4nKTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICRWYWx1ZXM8VD4gb2JqZWN0IHR5cGVzLicpO1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFsdWVzW2ldID0gcHJvcGVydHkudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dC51bmlvbi5hcHBseShjb250ZXh0LCB2YWx1ZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCRWYWx1ZXM8JHt0aGlzLnR5cGUudG9TdHJpbmcoKX0+YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gJFZhbHVlc1R5cGU7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiBjaGVja0dlbmVyaWNUeXBlKGNvbnRleHQsIGV4cGVjdGVkLCBpbnB1dCkge1xuICB2YXIgaW1wbCA9IGV4cGVjdGVkLmltcGw7XG5cbiAgaWYgKHR5cGVvZiBpbXBsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVGhlcmUgaXMgbGl0dGxlIGVsc2Ugd2UgY2FuIGRvIGhlcmUsIHNvIGFjY2VwdCBhbnl0aGluZy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpbXBsID09PSBpbnB1dCB8fCBpbXBsLmlzUHJvdG90eXBlT2YoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgYW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0QW5ub3RhdGlvbihpbXBsKTtcbiAgaWYgKGFubm90YXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2hlY2tUeXBlKGNvbnRleHQsIGFubm90YXRpb24sIGlucHV0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGUoY29udGV4dCwgZXhwZWN0ZWQsIGlucHV0KSB7XG4gIHZhciBhbm5vdGF0aW9uID0gY29udGV4dC5nZXRBbm5vdGF0aW9uKGlucHV0KTtcbiAgaWYgKGFubm90YXRpb24gIT0gbnVsbCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXMoZXhwZWN0ZWQsIGFubm90YXRpb24pO1xuICAgIHJldHVybiByZXN1bHQgIT09IC0xO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgQ2xhc3NUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKENsYXNzVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIENsYXNzVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbGFzc1R5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gQ2xhc3NUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xhc3NUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnQ2xhc3NUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKENsYXNzVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgaW5zdGFuY2VUeXBlID0gdGhpcy5pbnN0YW5jZVR5cGUsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0NMQVNTJywgaW5zdGFuY2VUeXBlLnRvU3RyaW5nKCkpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IGluc3RhbmNlVHlwZS50eXBlTmFtZSA9PT0gJ0NsYXNzRGVjbGFyYXRpb24nID8gaW5zdGFuY2VUeXBlIDogaW5zdGFuY2VUeXBlLnVud3JhcCgpO1xuICAgICAgdmFyIGlzVmFsaWQgPSBleHBlY3RlZFR5cGUgaW5zdGFuY2VvZiBHZW5lcmljVHlwZSA/IGNoZWNrR2VuZXJpY1R5cGUoY29udGV4dCwgZXhwZWN0ZWRUeXBlLCBpbnB1dCkgOiBjaGVja1R5cGUoY29udGV4dCwgZXhwZWN0ZWRUeXBlLCBpbnB1dCk7XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9DTEFTUycsIGluc3RhbmNlVHlwZS50b1N0cmluZygpKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBpbnN0YW5jZVR5cGUgPSB0aGlzLmluc3RhbmNlVHlwZSxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBpbnN0YW5jZVR5cGUudHlwZU5hbWUgPT09ICdDbGFzc0RlY2xhcmF0aW9uJyA/IGluc3RhbmNlVHlwZSA6IGluc3RhbmNlVHlwZS51bndyYXAoKTtcbiAgICAgIGlmIChleHBlY3RlZFR5cGUgaW5zdGFuY2VvZiBHZW5lcmljVHlwZSkge1xuICAgICAgICByZXR1cm4gY2hlY2tHZW5lcmljVHlwZShjb250ZXh0LCBleHBlY3RlZFR5cGUsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja1R5cGUoY29udGV4dCwgZXhwZWN0ZWRUeXBlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIGluc3RhbmNlVHlwZSA9IHRoaXMuaW5zdGFuY2VUeXBlO1xuXG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDbGFzc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyhpbnN0YW5jZVR5cGUsIGlucHV0Lmluc3RhbmNlVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgQ2xhc3M8JHt0aGlzLmluc3RhbmNlVHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBpbnN0YW5jZVR5cGU6IHRoaXMuaW5zdGFuY2VUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2xhc3NUeXBlO1xufShUeXBlKTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBpbnZhbGlkIHJlZmVyZW5jZXMgaW4gb3JkZXIgdG8gcHJldmVudFxuICogbXVsdGlwbGUgd2FybmluZ3MuXG4gKi9cbnZhciB3YXJuZWRJbnZhbGlkUmVmZXJlbmNlcyA9IG5ldyBXZWFrU2V0KCk7XG5cbnZhciBUeXBlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHlwZUNvbnRleHQoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZUNvbnRleHQpO1xuICAgIHRoaXMubW9kZSA9ICdhc3NlcnQnO1xuICAgIHRoaXNbTmFtZVJlZ2lzdHJ5U3ltYm9sXSA9IHt9O1xuICAgIHRoaXNbVHlwZVByZWRpY2F0ZVJlZ2lzdHJ5U3ltYm9sXSA9IHt9O1xuICAgIHRoaXNbVHlwZUNvbnN0cnVjdG9yUmVnaXN0cnlTeW1ib2xdID0gbmV3IE1hcCgpO1xuICAgIHRoaXNbSW5mZXJyZXJTeW1ib2xdID0gbmV3IFR5cGVJbmZlcmVyKHRoaXMpO1xuICAgIHRoaXNbTW9kdWxlUmVnaXN0cnlTeW1ib2xdID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdG8gYHQuY2hlY2soLi4uKWAgd2lsbCBjYWxsIGVpdGhlclxuICAgKiBgdC5hc3NlcnQoLi4uKWAgb3IgYHQud2FybiguLi4pYCBkZXBlbmRpbmcgb24gdGhpcyBzZXR0aW5nLlxuICAgKi9cblxuXG4gIC8vIElzc3VlIDI1MlxuXG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIC8vIElzc3VlIDI1MlxuXG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVDb250ZXh0LCBbe1xuICAgIGtleTogJ21ha2VKU09ORXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlSlNPTkVycm9yJCQxKHZhbGlkYXRpb24pIHtcbiAgICAgIHJldHVybiBtYWtlSlNPTkVycm9yKHZhbGlkYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21ha2VUeXBlRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlVHlwZUVycm9yJCQxKHZhbGlkYXRpb24pIHtcbiAgICAgIHJldHVybiBtYWtlVHlwZUVycm9yKHZhbGlkYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUNvbnRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgVHlwZUNvbnRleHQoKTtcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgY29udGV4dFtQYXJlbnRTeW1ib2xdID0gdGhpcztcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGVPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGVPZihpbnB1dCkge1xuXG4gICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvbihpbnB1dCk7XG4gICAgICBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nICYmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiB8fCBhbm5vdGF0aW9uIGluc3RhbmNlb2YgUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuQ2xhc3MoYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICB9XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIHZhciBpbmZlcnJlciA9IHRoaXNbSW5mZXJyZXJTeW1ib2xdO1xuICAgICAgaW5mZXJyZXI7XG5cbiAgICAgIHJldHVybiBpbmZlcnJlci5pbmZlcihpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVR5cGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVR5cGVzJCQxKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoYSwgYik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0JCQxKG5hbWUpIHtcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgdmFyIGl0ZW0gPSB0aGlzW05hbWVSZWdpc3RyeVN5bWJvbF1bbmFtZV07XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0eU5hbWVzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBwcm9wZXJ0eU5hbWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nID8gbmV3IGl0ZW0odGhpcykgOiBpdGVtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQuZ2V0UHJvcGVydHkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0UHJvcGVydHkocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudW53cmFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzW1BhcmVudFN5bWJvbF07XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBmcm9tUGFyZW50ID0gcGFyZW50LmdldC5hcHBseShwYXJlbnQsIFtuYW1lXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkocHJvcGVydHlOYW1lcykpKTtcbiAgICAgICAgaWYgKGZyb21QYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbVBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIsIHNlZSBpZiB3ZSBoYXZlIGEgZ2xvYmFsIHR5cGUgd2l0aCB0aGlzIG5hbWUuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IEdlbmVyaWNUeXBlKHRoaXMpO1xuICAgICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICAgIHRhcmdldC5pbXBsID0gZ2xvYmFsW25hbWVdO1xuICAgICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgICAgdGhpc1tOYW1lUmVnaXN0cnlTeW1ib2xdW25hbWVdID0gdGFyZ2V0O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJlZGljYXRlIGZvciBhIGdpdmVuIHR5cGUgbmFtZS5cbiAgICAgKiBlLmcuIGB0LmdldFByZWRpY2F0ZSgnQXJyYXknKWAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFByZWRpY2F0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZWRpY2F0ZShuYW1lKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXNbVHlwZVByZWRpY2F0ZVJlZ2lzdHJ5U3ltYm9sXVtuYW1lXTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbUGFyZW50U3ltYm9sXTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRQcmVkaWNhdGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwcmVkaWNhdGUgZm9yIGEgZ2l2ZW4gdHlwZSBuYW1lLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXNlIHRoZSBiZWhhdmlvdXIgb2YgdGhpbmdzIGxpa2UgQXJyYXlcbiAgICAgKiBkZXRlY3Rpb24gb3IgYWxsb3dpbmcgVGhlbmFibGVzIGluIHBsYWNlIG9mIHRoZSBnbG9iYWwgUHJvbWlzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0UHJlZGljYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJlZGljYXRlKG5hbWUsIHByZWRpY2F0ZSkge1xuICAgICAgdGhpc1tUeXBlUHJlZGljYXRlUmVnaXN0cnlTeW1ib2xdW25hbWVdID0gcHJlZGljYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBnaXZlbiB2YWx1ZSBhZ2FpbnN0IHRoZSBuYW1lZCBwcmVkaWNhdGUuXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiBubyBzdWNoIHByZWRpY2F0ZSBleGlzdHMuXG4gICAgICogZS5nLiBgdC5jaGVja1ByZWRpY2F0ZSgnQXJyYXknLCBbMSwgMiwgM10pYFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja1ByZWRpY2F0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUHJlZGljYXRlKG5hbWUsIGlucHV0KSB7XG4gICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5nZXRQcmVkaWNhdGUobmFtZSk7XG4gICAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUoaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZWNvcmF0b3IgZm9yIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggdGhlIGdpdmVuIHR5cGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlY29yYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb3JhdGUodHlwZSwgc2hvdWxkQXNzZXJ0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHNob3VsZEFzc2VydCA9PSBudWxsKSB7XG4gICAgICAgIHNob3VsZEFzc2VydCA9IHRoaXMubW9kZSA9PT0gJ2Fzc2VydCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgdHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZVByb3BlcnR5RGVzY3JpcHRvcih0eXBlLCBpbnB1dCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLCBCb29sZWFuKHNob3VsZEFzc2VydCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJywgJ0Nhbm5vdCBkZWNvcmF0ZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gYXMgYSBtZXRob2QuJyk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hbm5vdGF0ZShpbnB1dCwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ub3RhdGVzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIElmIGEgdHlwZSBpcyBzcGVjaWZpZWQgYXMgdGhlIHNvbGUgYXJndW1lbnQsIHJldHVybnMgYVxuICAgICAqIGZ1bmN0aW9uIHdoaWNoIGNhbiBkZWNvcmF0ZSBjbGFzc2VzIG9yIGZ1bmN0aW9ucyB3aXRoIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbm5vdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFubm90YXRlKGlucHV0LCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZVZhbHVlKGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZVZhbHVlKGlucHV0LCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRBbm5vdGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgICByZXR1cm4gaW5wdXRbVHlwZVN5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzQW5ub3RhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0Fubm90YXRpb24oaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnB1dFtUeXBlU3ltYm9sXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRBbm5vdGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QW5ub3RhdGlvbihpbnB1dCwgdHlwZSkge1xuICAgICAgaW5wdXRbVHlwZVN5bWJvbF0gPSB0eXBlO1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKG5hbWUsIF90eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIF90eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgUGFyYW1ldGVyaXplZFR5cGVBbGlhcyh0aGlzKTtcbiAgICAgICAgdGFyZ2V0Lm5hbWUgPSBuYW1lO1xuICAgICAgICB0YXJnZXQudHlwZUNyZWF0b3IgPSBfdHlwZTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGFyZ2V0ID0gbmV3IFR5cGVBbGlhcyh0aGlzKTtcbiAgICAgICAgX3RhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RhcmdldC50eXBlID0gX3R5cGU7XG4gICAgICAgIHJldHVybiBfdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY2xhcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNsYXJlKG5hbWUsIHR5cGUpIHtcblxuICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikge1xuICAgICAgICB0eXBlID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IHR5cGUubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSBpbnN0YW5jZW9mIFR5cGVBbGlhcykge1xuICAgICAgICB0eXBlID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IHR5cGUubmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0eXBlID0gdGhpcy50eXBlKG5hbWUsIHR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBNb2R1bGVEZWNsYXJhdGlvbikge1xuICAgICAgICB2YXIgbW9kdWxlUmVnaXN0cnkgPSB0aGlzW01vZHVsZVJlZ2lzdHJ5U3ltYm9sXTtcbiAgICAgICAgbW9kdWxlUmVnaXN0cnlbbmFtZV0gPSB0eXBlO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdOYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBUeXBlLCAnVHlwZSBtdXN0IGJlIHN1cHBsaWVkIHRvIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgIHZhciBuYW1lUmVnaXN0cnkgPSB0aGlzW05hbWVSZWdpc3RyeVN5bWJvbF07XG5cbiAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikge1xuICAgICAgICAgIG5hbWVSZWdpc3RyeVtuYW1lXSA9IHR5cGU7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFR5cGVBbGlhcyB8fCB0eXBlIGluc3RhbmNlb2YgUGFyYW1ldGVyaXplZFR5cGVBbGlhcykge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0YXJnZXQudHlwZUFsaWFzID0gdHlwZTtcbiAgICAgICAgICBuYW1lUmVnaXN0cnlbbmFtZV0gPSB0YXJnZXQ7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RhcmdldDIgPSB0aGlzLnZhcihuYW1lLCB0eXBlKTtcbiAgICAgICAgICBuYW1lUmVnaXN0cnlbbmFtZV0gPSBfdGFyZ2V0MjtcbiAgICAgICAgICByZXR1cm4gX3RhcmdldDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNsYXJhdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZGVjbGFyYXRpb25zKCkge1xuICAgICAgdmFyIG5hbWVSZWdpc3RyeSA9IHRoaXNbTmFtZVJlZ2lzdHJ5U3ltYm9sXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lUmVnaXN0cnkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgeWllbGQgW2tleSwgbmFtZVJlZ2lzdHJ5W2tleV1dO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21vZHVsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogbW9kdWxlcygpIHtcbiAgICAgIHZhciBtb2R1bGVSZWdpc3RyeSA9IHRoaXNbTW9kdWxlUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG1vZHVsZVJlZ2lzdHJ5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgIHlpZWxkIG1vZHVsZVJlZ2lzdHJ5W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW1wb3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ltcG9ydChtb2R1bGVOYW1lKSB7XG4gICAgICB2YXIgbW9kdWxlUmVnaXN0cnkgPSB0aGlzW01vZHVsZVJlZ2lzdHJ5U3ltYm9sXTtcbiAgICAgIGlmIChtb2R1bGVSZWdpc3RyeVttb2R1bGVOYW1lXSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlUmVnaXN0cnlbbW9kdWxlTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBfbW9kdWxlTmFtZSRzcGxpdCA9IG1vZHVsZU5hbWUuc3BsaXQoJy8nKSxcbiAgICAgICAgICBfbW9kdWxlTmFtZSRzcGxpdDIgPSBzbGljZWRUb0FycmF5KF9tb2R1bGVOYW1lJHNwbGl0LCAxKSxcbiAgICAgICAgICBoZWFkID0gX21vZHVsZU5hbWUkc3BsaXQyWzBdO1xuXG4gICAgICB2YXIgbW9kdWxlID0gbW9kdWxlUmVnaXN0cnlbaGVhZF07XG4gICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuaW1wb3J0KG1vZHVsZU5hbWUpO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbUGFyZW50U3ltYm9sXTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5pbXBvcnQobW9kdWxlTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjbGFyZVR5cGVDb25zdHJ1Y3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2xhcmVUeXBlQ29uc3RydWN0b3IoX3JlZikge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgaW1wbCA9IF9yZWYuaW1wbCxcbiAgICAgICAgICB0eXBlTmFtZSA9IF9yZWYudHlwZU5hbWUsXG4gICAgICAgICAgZXJyb3JzID0gX3JlZi5lcnJvcnMsXG4gICAgICAgICAgYWNjZXB0cyA9IF9yZWYuYWNjZXB0cyxcbiAgICAgICAgICBpbmZlclR5cGVQYXJhbWV0ZXJzID0gX3JlZi5pbmZlclR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgIGNvbXBhcmVXaXRoID0gX3JlZi5jb21wYXJlV2l0aDtcblxuICAgICAgdmFyIG5hbWVSZWdpc3RyeSA9IHRoaXNbTmFtZVJlZ2lzdHJ5U3ltYm9sXTtcblxuICAgICAgaWYgKG5hbWVSZWdpc3RyeVtuYW1lXSkge1xuICAgICAgICB0aGlzLmVtaXRXYXJuaW5nTWVzc2FnZShgUmVkZWNsYXJpbmcgdHlwZTogJHtuYW1lfSwgdGhpcyBtYXkgYmUgdW5pbnRlbmRlZC5gKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICB0YXJnZXQudHlwZU5hbWUgPSB0eXBlTmFtZTtcbiAgICAgIHRhcmdldC5pbXBsID0gaW1wbDtcbiAgICAgIHRhcmdldC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0YXJnZXQuYWNjZXB0cyA9IGFjY2VwdHM7XG4gICAgICB0YXJnZXQuaW5mZXJUeXBlUGFyYW1ldGVycyA9IGluZmVyVHlwZVBhcmFtZXRlcnM7XG4gICAgICBpZiAodHlwZW9mIGNvbXBhcmVXaXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhcmdldC5jb21wYXJlV2l0aCA9IGNvbXBhcmVXaXRoO1xuICAgICAgfVxuXG4gICAgICBuYW1lUmVnaXN0cnlbbmFtZV0gPSB0YXJnZXQ7XG5cbiAgICAgIGlmICh0eXBlb2YgaW1wbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgICAgdmFyIGhhbmRsZXJSZWdpc3RyeSA9IHRoaXNbVHlwZUNvbnN0cnVjdG9yUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgICBoYW5kbGVyUmVnaXN0cnk7XG5cbiAgICAgICAgaWYgKGhhbmRsZXJSZWdpc3RyeS5oYXMoaW1wbCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRXYXJuaW5nTWVzc2FnZShgQSB0eXBlIGhhbmRsZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBnaXZlbiBpbXBsZW1lbnRhdGlvbiBvZiAke25hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJSZWdpc3RyeS5zZXQoaW1wbCwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHlwZUNvbnN0cnVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZUNvbnN0cnVjdG9yKGltcGwpIHtcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgdmFyIGhhbmRsZXJSZWdpc3RyeSA9IHRoaXNbVHlwZUNvbnN0cnVjdG9yUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgaGFuZGxlclJlZ2lzdHJ5O1xuXG4gICAgICByZXR1cm4gaGFuZGxlclJlZ2lzdHJ5LmdldChpbXBsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaXRlcmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGl0ZXJhbChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm9pZCgpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvb2xlYW4oaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlcihpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbChpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZU9mKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ251bGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbnVsbCgpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5udWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ251bGxhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVsbGFibGUodHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBOdWxsYWJsZVR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4aXN0ZW50aWFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhpc3RlbnRpYWwoKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMuZXhpc3RlbnRpYWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW1wdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5lbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhbnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnkoKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMuYW55O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21peGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWl4ZWQoKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMubWl4ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndm9pZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92b2lkKCkge1xuICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLnZvaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGhpcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90aGlzKGlucHV0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFRoaXNUeXBlKHRoaXMpO1xuICAgICAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFyZ2V0LnJlY29yZGVkID0gaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ251bWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bWJlcihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBOdW1lcmljTGl0ZXJhbFR5cGUodGhpcyk7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IGlucHV0O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLm51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdib29sZWFuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYm9vbGVhbihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBCb29sZWFuTGl0ZXJhbFR5cGUodGhpcyk7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IGlucHV0O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLmJvb2xlYW47XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5nKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFN0cmluZ0xpdGVyYWxUeXBlKHRoaXMpO1xuICAgICAgICB0YXJnZXQudmFsdWUgPSBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5zdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3ltYm9sJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ltYm9sKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFN5bWJvbExpdGVyYWxUeXBlKHRoaXMpO1xuICAgICAgICB0YXJnZXQudmFsdWUgPSBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5zeW1ib2w7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZVBhcmFtZXRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXIoaWQsIGJvdW5kLCBkZWZhdWx0VHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyKHRoaXMpO1xuICAgICAgdGFyZ2V0LmlkID0gaWQ7XG4gICAgICB0YXJnZXQuYm91bmQgPSBib3VuZDtcbiAgICAgIHRhcmdldC5kZWZhdWx0ID0gZGVmYXVsdFR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zsb3dJbnRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxvd0ludG8odHlwZVBhcmFtZXRlcikge1xuICAgICAgcmV0dXJuIGZsb3dJbnRvVHlwZVBhcmFtZXRlcih0eXBlUGFyYW1ldGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIHRoZSB0eXBlIHBhcmFtZXRlcnMgZm9yIHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhlIGdpdmVuIGluc3RhbmNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiaW5kVHlwZVBhcmFtZXRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVHlwZVBhcmFtZXRlcnMoc3ViamVjdCkge1xuICAgICAgdmFyIGluc3RhbmNlUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YmplY3QpO1xuICAgICAgLy8gSXNzdWVcbiAgICAgIHZhciBwYXJlbnRQcm90b3R5cGUgPSBpbnN0YW5jZVByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2VQcm90b3R5cGUpO1xuICAgICAgLy8gSXNzdWVcbiAgICAgIHZhciBwYXJlbnRDbGFzcyA9IHBhcmVudFByb3RvdHlwZSAmJiBwYXJlbnRQcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbiAgICAgIGlmICghcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdGhpcy5lbWl0V2FybmluZ01lc3NhZ2UoJ0NvdWxkIG5vdCBiaW5kIHR5cGUgcGFyYW1ldGVycyBmb3Igbm9uLWV4aXN0ZW50IHBhcmVudCBjbGFzcy4nKTtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIHZhciB0eXBlUGFyYW1ldGVyc1BvaW50ZXIgPSBwYXJlbnRDbGFzc1tUeXBlUGFyYW1ldGVyc1N5bWJvbF07XG5cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVyc1BvaW50ZXIpIHtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gc3ViamVjdFt0eXBlUGFyYW1ldGVyc1BvaW50ZXJdO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHR5cGVQYXJhbWV0ZXJzKTtcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXlzLmxlbmd0aCwgdHlwZUluc3RhbmNlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR5cGVQYXJhbSA9IHR5cGVQYXJhbWV0ZXJzW2tleXNbaV1dO1xuICAgICAgICAgIHR5cGVQYXJhbS5ib3VuZCA9IHR5cGVJbnN0YW5jZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZHVsZShuYW1lLCBib2R5KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE1vZHVsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgdGFyZ2V0Lm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGlubmVyQ29udGV4dCA9IHRoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICBpbm5lckNvbnRleHRbUGFyZW50U3ltYm9sXSA9IHRoaXM7XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIGlubmVyQ29udGV4dFtDdXJyZW50TW9kdWxlU3ltYm9sXSA9IHRhcmdldDtcblxuICAgICAgdGFyZ2V0LmlubmVyQ29udGV4dCA9IGlubmVyQ29udGV4dDtcbiAgICAgIGJvZHkoaW5uZXJDb250ZXh0KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW9kdWxlRXhwb3J0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZHVsZUV4cG9ydHModHlwZSkge1xuICAgICAgdmFyIGN1cnJlbnRNb2R1bGUgPSB0aGlzW0N1cnJlbnRNb2R1bGVTeW1ib2xdO1xuICAgICAgaWYgKCFjdXJyZW50TW9kdWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY2xhcmUgbW9kdWxlLmV4cG9ydHMgb3V0c2lkZSBvZiBhIG1vZHVsZS4nKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgTW9kdWxlRXhwb3J0cyh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIGN1cnJlbnRNb2R1bGUubW9kdWxlRXhwb3J0cyA9IHRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhcihuYW1lLCB0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFZhckRlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgdGFyZ2V0Lm5hbWUgPSBuYW1lO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGFzcyhuYW1lLCBoZWFkKSB7XG4gICAgICBpZiAodHlwZW9mIGhlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90YXJnZXQzID0gbmV3IFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgICBfdGFyZ2V0My5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RhcmdldDMuYm9keUNyZWF0b3IgPSBoZWFkO1xuICAgICAgICByZXR1cm4gX3RhcmdldDM7XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IENsYXNzRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdGFpbFtfa2V5MyAtIDJdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWQgIT0gbnVsbCkge1xuICAgICAgICB0YWlsLnVuc2hpZnQoaGVhZCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gdGFpbC5sZW5ndGg7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgICB2YXIgYm9keSA9IHZvaWQgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHRhaWxbaV07XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0VHlwZVByb3BlcnR5IHx8IGl0ZW0gaW5zdGFuY2VvZiBPYmplY3RUeXBlSW5kZXhlcikge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0VHlwZSkge1xuICAgICAgICAgIGludmFyaWFudCghYm9keSwgJ0NsYXNzIGJvZHkgbXVzdCBvbmx5IGJlIGRlY2xhcmVkIG9uY2UuJyk7XG4gICAgICAgICAgYm9keSA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEV4dGVuZHNEZWNsYXJhdGlvbikge1xuICAgICAgICAgIGludmFyaWFudCghdGFyZ2V0LnN1cGVyQ2xhc3MsICdDbGFzc2VzIGNhbiBvbmx5IGhhdmUgb25lIHN1cGVyIGNsYXNzLicpO1xuICAgICAgICAgIHRhcmdldC5zdXBlckNsYXNzID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICEoaXRlbSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnByb3BlcnR5KHByb3BlcnR5TmFtZSwgaXRlbVtwcm9wZXJ0eU5hbWVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3NEZWNsYXJhdGlvbiBjYW5ub3QgY29udGFpbiB0aGUgZ2l2ZW4gdHlwZSBkaXJlY3RseS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIGJvZHkgPSBuZXcgT2JqZWN0VHlwZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgX2JvZHkkcHJvcGVydGllcztcblxuICAgICAgICAoX2JvZHkkcHJvcGVydGllcyA9IGJvZHkucHJvcGVydGllcykucHVzaC5hcHBseShfYm9keSRwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC5ib2R5ID0gYm9keTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXh0ZW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9leHRlbmRzKHN1YmplY3QpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgRXh0ZW5kc0RlY2xhcmF0aW9uKHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC50eXBlID0gdGhpcy5yZWYuYXBwbHkodGhpcywgW3N1YmplY3RdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZuKGhlYWQpIHtcbiAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgdGFpbFtfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb24uYXBwbHkodGhpcywgW2hlYWRdLmNvbmNhdCh0YWlsKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZnVuY3Rpb24oaGVhZCkge1xuICAgICAgaWYgKHR5cGVvZiBoZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0NCA9IG5ldyBQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlKHRoaXMpO1xuICAgICAgICBfdGFyZ2V0NC5ib2R5Q3JlYXRvciA9IGhlYWQ7XG4gICAgICAgIHJldHVybiBfdGFyZ2V0NDtcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgRnVuY3Rpb25UeXBlKHRoaXMpO1xuICAgICAgaWYgKGhlYWQgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhaWwgPSBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgICAgdGFpbFtfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwudW5zaGlmdChoZWFkKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRhaWwubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHRhaWxbaV07XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvblR5cGVQYXJhbSkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhcmFtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlc3QgPSBpdGVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVJldHVybikge1xuICAgICAgICAgICAgdGFyZ2V0LnJldHVyblR5cGUgPSBpdGVtO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uVHlwZSBjYW5ub3QgY29udGFpbiB0aGUgZ2l2ZW4gdHlwZSBkaXJlY3RseS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGFyZ2V0LnJldHVyblR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJldHVyblR5cGUgPSB0aGlzLmFueSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXJhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcmFtKG5hbWUsIHR5cGUpIHtcbiAgICAgIHZhciBvcHRpb25hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgRnVuY3Rpb25UeXBlUGFyYW0odGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICB0YXJnZXQub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3QobmFtZSwgdHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBGdW5jdGlvblR5cGVSZXN0UGFyYW0odGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JldHVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXR1cm4odHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBGdW5jdGlvblR5cGVSZXR1cm4odGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dlbmVyYXRvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRvcih5aWVsZFR5cGUsIHJldHVyblR5cGUsIG5leHRUeXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IEdlbmVyYXRvclR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQueWllbGRUeXBlID0geWllbGRUeXBlO1xuICAgICAgdGFyZ2V0LnJldHVyblR5cGUgPSByZXR1cm5UeXBlIHx8IHRoaXMuYW55KCk7XG4gICAgICB0YXJnZXQubmV4dFR5cGUgPSBuZXh0VHlwZSB8fCB0aGlzLmFueSgpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYmplY3QoaGVhZCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlKHRoaXMpO1xuICAgICAgaWYgKGhlYWQgIT0gbnVsbCAmJiB0eXBlb2YgaGVhZCA9PT0gJ29iamVjdCcgJiYgIShoZWFkIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGhlYWQpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgdGFyZ2V0LnByb3BlcnRpZXMucHVzaCh0aGlzLnByb3BlcnR5KHByb3BlcnR5TmFtZSwgaGVhZFtwcm9wZXJ0eU5hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW43ID4gMSA/IF9sZW43IC0gMSA6IDApLCBfa2V5NyA9IDE7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgICB0YWlsW19rZXk3IC0gMV0gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICBib2R5ID0gW2hlYWRdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0YWlsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9keSA9IHRhaWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ib2R5ID0gYm9keSxcbiAgICAgICAgICAgIGxlbmd0aCA9IF9ib2R5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBib2R5W2ldO1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0VHlwZVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0YXJnZXQucHJvcGVydGllcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdFR5cGVJbmRleGVyKSB7XG4gICAgICAgICAgICB0YXJnZXQuaW5kZXhlcnMucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3RUeXBlQ2FsbFByb3BlcnR5KSB7XG4gICAgICAgICAgICB0YXJnZXQuY2FsbFByb3BlcnRpZXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RUeXBlIGNhbm5vdCBjb250YWluIHRoZSBnaXZlbiB0eXBlIGRpcmVjdGx5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleGFjdE9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4YWN0T2JqZWN0KGhlYWQpIHtcbiAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW44ID4gMSA/IF9sZW44IC0gMSA6IDApLCBfa2V5OCA9IDE7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgdGFpbFtfa2V5OCAtIDFdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LmFwcGx5KHRoaXMsIFtoZWFkXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodGFpbCkpKTtcbiAgICAgIG9iamVjdC5leGFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGxQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGxQcm9wZXJ0eSh2YWx1ZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlQ2FsbFByb3BlcnR5KHRoaXMpO1xuICAgICAgdGFyZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9wdGlvbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlUHJvcGVydHkodGhpcyk7XG4gICAgICB0YXJnZXQua2V5ID0ga2V5O1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IHRoaXMub2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhlcihpZCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlSW5kZXhlcih0aGlzKTtcbiAgICAgIHRhcmdldC5pZCA9IGlkO1xuICAgICAgdGFyZ2V0LmtleSA9IGtleTtcbiAgICAgIHRhcmdldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXRob2QobmFtZSwgaGVhZCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlUHJvcGVydHkodGhpcyk7XG4gICAgICB0YXJnZXQua2V5ID0gbmFtZTtcblxuICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCB0YWlsID0gQXJyYXkoX2xlbjkgPiAyID8gX2xlbjkgLSAyIDogMCksIF9rZXk5ID0gMjsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICB0YWlsW19rZXk5IC0gMl0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudmFsdWUgPSB0aGlzLmZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtoZWFkXS5jb25jYXQodGFpbCkpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGF0aWNDYWxsUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0aWNDYWxsUHJvcGVydHkodmFsdWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5jYWxsUHJvcGVydHkodmFsdWUpO1xuICAgICAgcHJvcC5zdGF0aWMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhdGljUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0aWNQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydHkoa2V5LCB2YWx1ZSwgb3B0aW9uYWwpO1xuICAgICAgcHJvcC5zdGF0aWMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhdGljTWV0aG9kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdGljTWV0aG9kKG5hbWUsIGhlYWQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhaWwgPSBBcnJheShfbGVuMTAgPiAyID8gX2xlbjEwIC0gMiA6IDApLCBfa2V5MTAgPSAyOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgIHRhaWxbX2tleTEwIC0gMl0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLm1ldGhvZC5hcHBseSh0aGlzLCBbbmFtZSwgaGVhZF0uY29uY2F0KHRhaWwpKTtcbiAgICAgIHByb3Auc3RhdGljID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NwcmVhZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwcmVhZCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgT2JqZWN0VHlwZSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgIHR5cGVzW19rZXkxMV0gPSBhcmd1bWVudHNbX2tleTExXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldLnVud3JhcCgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlLmNhbGxQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHZhciBfdGFyZ2V0JGNhbGxQcm9wZXJ0aWU7XG5cbiAgICAgICAgICAoX3RhcmdldCRjYWxsUHJvcGVydGllID0gdGFyZ2V0LmNhbGxQcm9wZXJ0aWVzKS5wdXNoLmFwcGx5KF90YXJnZXQkY2FsbFByb3BlcnRpZSwgdG9Db25zdW1hYmxlQXJyYXkodHlwZS5jYWxsUHJvcGVydGllcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUuaW5kZXhlcnMpKSB7XG4gICAgICAgICAgdmFyIF90YXJnZXQkaW5kZXhlcnM7XG5cbiAgICAgICAgICAoX3RhcmdldCRpbmRleGVycyA9IHRhcmdldC5pbmRleGVycykucHVzaC5hcHBseShfdGFyZ2V0JGluZGV4ZXJzLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlLmluZGV4ZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHlwZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHR5cGUucHJvcGVydGllc1tqXTtcbiAgICAgICAgICAgIGludmFyaWFudChwcm9wIGluc3RhbmNlb2YgT2JqZWN0VHlwZVByb3BlcnR5KTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRQcm9wZXJ0eShwcm9wLmtleSwgcHJvcC52YWx1ZSwgcHJvcC5vcHRpb25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R1cGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHVwbGUoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR1cGxlVHlwZSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgX2xlbjEyID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMTIpLCBfa2V5MTIgPSAwOyBfa2V5MTIgPCBfbGVuMTI7IF9rZXkxMisrKSB7XG4gICAgICAgIHR5cGVzW19rZXkxMl0gPSBhcmd1bWVudHNbX2tleTEyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVzID0gdHlwZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FycmF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJyYXkoZWxlbWVudFR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgQXJyYXlUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LmVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGUgfHwgdGhpcy5hbnkoKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5pb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVzID0gQXJyYXkoX2xlbjEzKSwgX2tleTEzID0gMDsgX2tleTEzIDwgX2xlbjEzOyBfa2V5MTMrKykge1xuICAgICAgICB0eXBlc1tfa2V5MTNdID0gYXJndW1lbnRzW19rZXkxM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWtlVW5pb24odGhpcywgdHlwZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ludGVyc2VjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgSW50ZXJzZWN0aW9uVHlwZSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgX2xlbjE0ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMTQpLCBfa2V5MTQgPSAwOyBfa2V5MTQgPCBfbGVuMTQ7IF9rZXkxNCsrKSB7XG4gICAgICAgIHR5cGVzW19rZXkxNF0gPSBhcmd1bWVudHNbX2tleTE0XTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVzID0gdHlwZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ludGVyc2VjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JveCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJveChyZXZlYWwpIHtcbiAgICAgIHZhciBib3ggPSBuZXcgVHlwZUJveCh0aGlzKTtcbiAgICAgIGJveC5yZXZlYWwgPSByZXZlYWw7XG4gICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RkeicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRkeihyZXZlYWwsIG5hbWUpIHtcbiAgICAgIHZhciB0ZHogPSBuZXcgVHlwZVREWih0aGlzKTtcbiAgICAgIHRkei5yZXZlYWwgPSByZXZlYWw7XG4gICAgICB0ZHoubmFtZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGR6O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZihzdWJqZWN0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyB0cnkgYW5kIGVhZ2VybHkgcmVzb2x2ZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZ2V0KHN1YmplY3QpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIC8vIGRlZmVyIGRlcmVmZXJlbmNpbmcgZm9yIG5vd1xuICAgICAgICAgIHRhcmdldCA9IG5ldyBUeXBlUmVmZXJlbmNlKHRoaXMpO1xuICAgICAgICAgIHRhcmdldC5uYW1lID0gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgICAgdmFyIGhhbmRsZXJSZWdpc3RyeSA9IHRoaXNbVHlwZUNvbnN0cnVjdG9yUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgICBoYW5kbGVyUmVnaXN0cnk7XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBkZWRpY2F0ZWQgVHlwZUNvbnN0cnVjdG9yIGZvciB0aGlzLlxuICAgICAgICB0YXJnZXQgPSBoYW5kbGVyUmVnaXN0cnkuZ2V0KHN1YmplY3QpO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgLy8ganVzdCB1c2UgYSBnZW5lcmljIHR5cGUgaGFuZGxlci5cbiAgICAgICAgICB0YXJnZXQgPSBuZXcgR2VuZXJpY1R5cGUodGhpcyk7XG4gICAgICAgICAgdGFyZ2V0LmltcGwgPSBzdWJqZWN0O1xuICAgICAgICAgIHRhcmdldC5uYW1lID0gc3ViamVjdC5uYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgIHRhcmdldCA9IHN1YmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3ViamVjdCA9PSBudWxsIHx8IHR5cGVvZiBzdWJqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMuZW1pdFdhcm5pbmdNZXNzYWdlKGBDb3VsZCBub3QgcmVmZXJlbmNlIHRoZSBnaXZlbiB0eXBlLCB0cnkgdC50eXBlT2YodmFsdWUpIGluc3RlYWQuIChnb3QgJHtTdHJpbmcoc3ViamVjdCl9KWApO1xuICAgICAgICB9IGVsc2UgaWYgKCF3YXJuZWRJbnZhbGlkUmVmZXJlbmNlcy5oYXMoc3ViamVjdCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRXYXJuaW5nTWVzc2FnZSgnQ291bGQgbm90IHJlZmVyZW5jZSB0aGUgZ2l2ZW4gdHlwZSwgdHJ5IHQudHlwZU9mKHZhbHVlKSBpbnN0ZWFkLicpO1xuICAgICAgICAgIHdhcm5lZEludmFsaWRSZWZlcmVuY2VzLmFkZChzdWJqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbnkoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjE1ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4xNSA+IDEgPyBfbGVuMTUgLSAxIDogMCksIF9rZXkxNSA9IDE7IF9rZXkxNSA8IF9sZW4xNTsgX2tleTE1KyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MTVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZUluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF90YXJnZXQ1O1xuXG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgdGFyZ2V0LmFwcGx5ID09PSAnZnVuY3Rpb24nLCBgQ2Fubm90IGFwcGx5IG5vbi1hcHBsaWNhYmxlIHR5cGU6ICR7dGFyZ2V0LnR5cGVOYW1lfS5gKTtcbiAgICAgICAgcmV0dXJuIChfdGFyZ2V0NSA9IHRhcmdldCkuYXBwbHkuYXBwbHkoX3RhcmdldDUsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsaWRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh0eXBlLCBpbnB1dCkge1xuICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgdmFyIHZhbGlkYXRpb24gPSBuZXcgVmFsaWRhdGlvbih0aGlzLCBpbnB1dCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgX3ZhbGlkYXRpb24kcGF0aDtcblxuICAgICAgICAoX3ZhbGlkYXRpb24kcGF0aCA9IHZhbGlkYXRpb24ucGF0aCkucHVzaC5hcHBseShfdmFsaWRhdGlvbiRwYXRoLCB0b0NvbnN1bWFibGVBcnJheShwYXRoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbGlkYXRpb24ucGF0aC5wdXNoKHR5cGUubmFtZSk7XG4gICAgICB9XG4gICAgICB2YWxpZGF0aW9uLnByZWZpeCA9IHByZWZpeDtcbiAgICAgIHZhbGlkYXRpb24uZXJyb3JzID0gQXJyYXkuZnJvbSh0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBbXSwgaW5wdXQpKTtcbiAgICAgIHJldHVybiB2YWxpZGF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2sodHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHNbM107XG5cbiAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdhc3NlcnQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0eXBlLCBpbnB1dCwgcHJlZml4LCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhcm4odHlwZSwgaW5wdXQsIHByZWZpeCwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXNzZXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0KHR5cGUsIGlucHV0KSB7XG4gICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnJztcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUodHlwZSwgaW5wdXQsIHByZWZpeCwgcGF0aCk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLm1ha2VUeXBlRXJyb3IodmFsaWRhdGlvbik7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd2FybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4odHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHNbM107XG5cbiAgICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSh0eXBlLCBpbnB1dCwgcHJlZml4LCBwYXRoKTtcbiAgICAgIHZhciBtZXNzYWdlID0gbWFrZVdhcm5pbmdNZXNzYWdlKHZhbGlkYXRpb24pO1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVtaXRXYXJuaW5nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIHdhcm5pbmcgbWVzc2FnZSwgdXNpbmcgYGNvbnNvbGUud2FybigpYCBieSBkZWZhdWx0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0V2FybmluZ01lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0V2FybmluZ01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgY29uc29sZS53YXJuKCdmbG93LXJ1bnRpbWU6JywgbWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvcFR5cGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcFR5cGVzKHR5cGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVhY3RQcm9wVHlwZXModHlwZS51bndyYXAoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWF0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMTYpLCBfa2V5MTYgPSAwOyBfa2V5MTYgPCBfbGVuMTY7IF9rZXkxNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE2XSA9IGFyZ3VtZW50c1tfa2V5MTZdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhdXNlcyA9IGFyZ3MucG9wKCk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2xhdXNlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdHRlcm4sIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgIH1cbiAgICAgIGNsYXVzZXM7XG4gICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVybi5hcHBseSh0aGlzLCB0b0NvbnN1bWFibGVBcnJheShjbGF1c2VzKSk7XG4gICAgICByZXR1cm4gcGF0dGVybi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdHRlcm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXR0ZXJuKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE3ID0gYXJndW1lbnRzLmxlbmd0aCwgY2xhdXNlcyA9IEFycmF5KF9sZW4xNyksIF9rZXkxNyA9IDA7IF9rZXkxNyA8IF9sZW4xNzsgX2tleTE3KyspIHtcbiAgICAgICAgY2xhdXNlc1tfa2V5MTddID0gYXJndW1lbnRzW19rZXkxN107XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBjbGF1c2VzLmxlbmd0aDtcblxuICAgICAgdmFyIHRlc3RzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbGF1c2UgPSBjbGF1c2VzW2ldO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvbihjbGF1c2UpO1xuICAgICAgICBpZiAoIWFubm90YXRpb24pIHtcbiAgICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFBhdHRlcm4gLSBmb3VuZCB1bmFubm90YXRlZCBmdW5jdGlvbiBpbiBwb3NpdGlvbiAke2l9LCBkZWZhdWx0IGNsYXVzZXMgbXVzdCBiZSBsYXN0LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXN0c1tpXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52YXJpYW50KGFubm90YXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvblR5cGUgfHwgYW5ub3RhdGlvbiBpbnN0YW5jZW9mIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUsICdQYXR0ZXJuIGNsYXVzZXMgbXVzdCBiZSBhbm5vdGF0ZWQgZnVuY3Rpb25zLicpO1xuICAgICAgICAgIHRlc3RzW2ldID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRlc3RzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciB0ZXN0ID0gdGVzdHNbX2ldO1xuICAgICAgICAgIHZhciBfY2xhdXNlID0gY2xhdXNlc1tfaV07XG4gICAgICAgICAgaWYgKHRlc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfY2xhdXNlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlc3QuYWNjZXB0c1BhcmFtcy5hcHBseSh0ZXN0LCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NsYXVzZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGRpZCBub3QgbWF0Y2ggYW55IG9mIHRoZSBjYW5kaWRhdGVzLicpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ1J1bnRpbWVUeXBlRXJyb3InO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd3JhcEl0ZXJhdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JhcEl0ZXJhdG9yKHR5cGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiogd3JhcHBlZEl0ZXJhdG9yKGlucHV0KSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgeWllbGQgdC5jaGVjayh0eXBlLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlZmluZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZpbmVtZW50KHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgUmVmaW5lbWVudFR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIGZvciAodmFyIF9sZW4xOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbnN0cmFpbnRzID0gQXJyYXkoX2xlbjE4ID4gMSA/IF9sZW4xOCAtIDEgOiAwKSwgX2tleTE4ID0gMTsgX2tleTE4IDwgX2xlbjE4OyBfa2V5MTgrKykge1xuICAgICAgICBjb25zdHJhaW50c1tfa2V5MTggLSAxXSA9IGFyZ3VtZW50c1tfa2V5MThdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuYWRkQ29uc3RyYWludC5hcHBseSh0YXJnZXQsIHRvQ29uc3VtYWJsZUFycmF5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRleGFjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRleGFjdCh0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGUodGhpcyk7XG4gICAgICB0eXBlID0gdHlwZS51bndyYXAoKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUuY2FsbFByb3BlcnRpZXMpKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0JGNhbGxQcm9wZXJ0aWUyO1xuXG4gICAgICAgIChfdGFyZ2V0JGNhbGxQcm9wZXJ0aWUyID0gdGFyZ2V0LmNhbGxQcm9wZXJ0aWVzKS5wdXNoLmFwcGx5KF90YXJnZXQkY2FsbFByb3BlcnRpZTIsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUuY2FsbFByb3BlcnRpZXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUuaW5kZXhlcnMpKSB7XG4gICAgICAgIHZhciBfdGFyZ2V0JGluZGV4ZXJzMjtcblxuICAgICAgICAoX3RhcmdldCRpbmRleGVyczIgPSB0YXJnZXQuaW5kZXhlcnMpLnB1c2guYXBwbHkoX3RhcmdldCRpbmRleGVyczIsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUuaW5kZXhlcnMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUucHJvcGVydGllcykpIHtcbiAgICAgICAgdmFyIF90YXJnZXQkcHJvcGVydGllcztcblxuICAgICAgICAoX3RhcmdldCRwcm9wZXJ0aWVzID0gdGFyZ2V0LnByb3BlcnRpZXMpLnB1c2guYXBwbHkoX3RhcmdldCRwcm9wZXJ0aWVzLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlLnByb3BlcnRpZXMpKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC5leGFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRkaWZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJGRpZmYoYVR5cGUsIGJUeXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICREaWZmVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC5hVHlwZSA9IGFUeXBlO1xuICAgICAgdGFyZ2V0LmJUeXBlID0gYlR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRmbG93Rml4TWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkZmxvd0ZpeE1lKCkge1xuICAgICAgcmV0dXJuIG5ldyAkRmxvd0ZpeE1lVHlwZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICcka2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRrZXlzKHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJEtleXNUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckb2JqTWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJG9iak1hcChvYmplY3QsIG1hcHBlcikge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkT2JqTWFwVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0YXJnZXQubWFwcGVyID0gbWFwcGVyO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckb2JqTWFwaScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRvYmpNYXBpKG9iamVjdCwgbWFwcGVyKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICRPYmpNYXBpVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0YXJnZXQubWFwcGVyID0gbWFwcGVyO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckcHJvcGVydHlUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJHByb3BlcnR5VHlwZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICRQcm9wZXJ0eVR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICB2YXIgdW53cmFwcGVkID0gcHJvcGVydHkudW53cmFwKCk7XG4gICAgICAgIHRhcmdldC5wcm9wZXJ0eSA9IHVud3JhcHBlZC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckc2hhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkc2hhcGUodHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkU2hhcGVUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckc3VidHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRzdWJ0eXBlKHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJFN1YlR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRzdXBlcnR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkc3VwZXJ0eXBlKHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJFN1cGVyVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJHR1cGxlTWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJHR1cGxlTWFwKHR1cGxlLCBtYXBwZXIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJFR1cGxlTWFwVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50dXBsZSA9IHR1cGxlO1xuICAgICAgdGFyZ2V0Lm1hcHBlciA9IG1hcHBlcjtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJHZhbHVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICR2YWx1ZXModHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkVmFsdWVzVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnQ2xhc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBDbGFzcyhpbnN0YW5jZVR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgQ2xhc3NUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0Lmluc3RhbmNlVHlwZSA9IGluc3RhbmNlVHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnVHlwZVBhcmFtZXRlcnNTeW1ib2wnLFxuXG5cbiAgICAvLyBJc3N1ZSAyNTJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBUeXBlUGFyYW1ldGVyc1N5bWJvbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVDb250ZXh0O1xufSgpO1xuXG52YXIgZ2xvYmFsQ29udGV4dCQxID0gdm9pZCAwO1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwuX19GTE9XX1JVTlRJTUVfR0xPQkFMX0NPTlRFWFRfRE9fTk9UX1VTRV9USElTX1ZBUklBQkxFX18gIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbENvbnRleHQkMSA9IGdsb2JhbC5fX0ZMT1dfUlVOVElNRV9HTE9CQUxfQ09OVEVYVF9ET19OT1RfVVNFX1RISVNfVkFSSUFCTEVfXztcbn0gZWxzZSB7XG4gIGdsb2JhbENvbnRleHQkMSA9IG5ldyBUeXBlQ29udGV4dCgpO1xuICByZWdpc3RlclByaW1pdGl2ZVR5cGVzKGdsb2JhbENvbnRleHQkMSk7XG4gIHJlZ2lzdGVyQnVpbHRpblR5cGVDb25zdHJ1Y3RvcnMoZ2xvYmFsQ29udGV4dCQxKTtcbiAgcmVnaXN0ZXJUeXBlUHJlZGljYXRlcyhnbG9iYWxDb250ZXh0JDEpO1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuX19GTE9XX1JVTlRJTUVfR0xPQkFMX0NPTlRFWFRfRE9fTk9UX1VTRV9USElTX1ZBUklBQkxFX18gPSBnbG9iYWxDb250ZXh0JDE7XG4gIH1cbn1cblxudmFyIGdsb2JhbENvbnRleHQkMiA9IGdsb2JhbENvbnRleHQkMTtcblxuZXhwb3J0IHsgQW55VHlwZSwgQXJyYXlUeXBlLCBCb29sZWFuTGl0ZXJhbFR5cGUsIEJvb2xlYW5UeXBlLCBFbXB0eVR5cGUsIEV4aXN0ZW50aWFsVHlwZSwgRmxvd0ludG9UeXBlLCBGdW5jdGlvblR5cGUsIEZ1bmN0aW9uVHlwZVBhcmFtLCBGdW5jdGlvblR5cGVSZXN0UGFyYW0sIEZ1bmN0aW9uVHlwZVJldHVybiwgR2VuZXJhdG9yVHlwZSwgR2VuZXJpY1R5cGUsIEludGVyc2VjdGlvblR5cGUsIE1peGVkVHlwZSwgVHlwZUFsaWFzLCBOdWxsYWJsZVR5cGUsIE51bGxMaXRlcmFsVHlwZSwgTnVtYmVyVHlwZSwgTnVtZXJpY0xpdGVyYWxUeXBlLCBPYmplY3RUeXBlLCBPYmplY3RUeXBlQ2FsbFByb3BlcnR5LCBPYmplY3RUeXBlSW5kZXhlciwgT2JqZWN0VHlwZVByb3BlcnR5LCBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzLCBQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlLCBQYXJ0aWFsVHlwZSwgUmVmaW5lbWVudFR5cGUsIFN0cmluZ0xpdGVyYWxUeXBlLCBTdHJpbmdUeXBlLCBTeW1ib2xMaXRlcmFsVHlwZSwgU3ltYm9sVHlwZSwgVGhpc1R5cGUsIFR1cGxlVHlwZSwgVHlwZSwgVHlwZUJveCwgVHlwZUNvbnN0cnVjdG9yLCBUeXBlUGFyYW1ldGVyLCBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24sIFR5cGVSZWZlcmVuY2UsIFR5cGVURFosIFVuaW9uVHlwZSwgVm9pZFR5cGUsIERlY2xhcmF0aW9uLCBUeXBlRGVjbGFyYXRpb24sIFZhckRlY2xhcmF0aW9uLCBNb2R1bGVEZWNsYXJhdGlvbiwgTW9kdWxlRXhwb3J0cyBhcyBNb2R1bGVFeHBvcnRzRGVjbGFyYXRpb24sIENsYXNzRGVjbGFyYXRpb24sIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uLCBFeHRlbmRzRGVjbGFyYXRpb24sIFR5cGVQYXJhbWV0ZXJzU3ltYm9sLCBUeXBlU3ltYm9sIH07ZXhwb3J0IGRlZmF1bHQgZ2xvYmFsQ29udGV4dCQyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy1ydW50aW1lLmVzMjAxNS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Zsb3ctcnVudGltZS9kaXN0L2Zsb3ctcnVudGltZS5lczIwMTUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n");

/***/ })
/******/ ]);