/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var _flowRuntime = __webpack_require__(1);var _flowRuntime2 = _interopRequireDefault(_flowRuntime);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\nvar sum = _flowRuntime2.default.annotate(function sum(a, b) {return a + b;}, _flowRuntime2.default.function(_flowRuntime2.default.param(\"a\", _flowRuntime2.default.number()), _flowRuntime2.default.param(\"b\", _flowRuntime2.default.number()), _flowRuntime2.default.return(_flowRuntime2.default.number())));\n\nconsole.log(sum(1, 2));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhIiwiYiIsImNvbnNvbGUiLCJsb2ciXSwibWFwcGluZ3MiOiI7O0FBRUEsSUFBSUEscUNBQU0sYUFBQ0MsQ0FBRCxFQUFZQyxDQUFaLFVBQWtDRCxJQUFJQyxDQUF0QyxFQUFOLEVBQU0sZ0VBQUUsOEJBQUYsb0NBQWEsOEJBQWIsZ0NBQXNCLDhCQUF0QixFQUFOLENBQUo7O0FBRUFDLFFBQVFDLEdBQVIsQ0FBWUosSUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3Nob3V2aWsvUHJvamVjdHMvZmxvdy10ZXN0Iiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxubGV0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciA9PiBhICsgYjtcblxuY29uc29sZS5sb2coc3VtKDEsIDIpKTtcbiJdfQ==//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/ODc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSwwQ0FBMkMseURBQXlELHNDQUFzQyxzQ0FBc0M7O0FBRTdMLDZEQUE2RCxjQUFjOztBQUUzRTtBQUNBLDJDQUEyQyxjQUFjIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjt2YXIgX2Zsb3dSdW50aW1lID0gcmVxdWlyZShcImZsb3ctcnVudGltZVwiKTt2YXIgX2Zsb3dSdW50aW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zsb3dSdW50aW1lKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge3JldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O31cblxudmFyIHN1bSA9IF9mbG93UnVudGltZTIuZGVmYXVsdC5hbm5vdGF0ZShmdW5jdGlvbiBzdW0oYSwgYikge3JldHVybiBhICsgYjt9LCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQuZnVuY3Rpb24oX2Zsb3dSdW50aW1lMi5kZWZhdWx0LnBhcmFtKFwiYVwiLCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQubnVtYmVyKCkpLCBfZmxvd1J1bnRpbWUyLmRlZmF1bHQucGFyYW0oXCJiXCIsIF9mbG93UnVudGltZTIuZGVmYXVsdC5udW1iZXIoKSksIF9mbG93UnVudGltZTIuZGVmYXVsdC5yZXR1cm4oX2Zsb3dSdW50aW1lMi5kZWZhdWx0Lm51bWJlcigpKSkpO1xuXG5jb25zb2xlLmxvZyhzdW0oMSwgMikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OXBibVJsZUM1cWN5SmRMQ0p1WVcxbGN5STZXeUp6ZFcwaUxDSmhJaXdpWWlJc0ltTnZibk52YkdVaUxDSnNiMmNpWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUlVFc1NVRkJTVUVzY1VOQlFVMHNZVUZCUTBNc1EwRkJSQ3hGUVVGWlF5eERRVUZhTEZWQlFXdERSQ3hKUVVGSlF5eERRVUYwUXl4RlFVRk9MRVZCUVUwc1owVkJRVVVzT0VKQlFVWXNiME5CUVdFc09FSkJRV0lzWjBOQlFYTkNMRGhDUVVGMFFpeEZRVUZPTEVOQlFVbzdPMEZCUlVGRExGRkJRVkZETEVkQlFWSXNRMEZCV1Vvc1NVRkJTU3hEUVVGS0xFVkJRVThzUTBGQlVDeERRVUZhSWl3aVptbHNaU0k2SW1sdVpHVjRMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaTlvYjIxbEwzTm9iM1YyYVdzdlVISnZhbVZqZEhNdlpteHZkeTEwWlhOMElpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnUUdac2IzZGNibHh1YkdWMElITjFiU0E5SUNoaE9pQnVkVzFpWlhJc0lHSTZJRzUxYldKbGNpazZJRzUxYldKbGNpQTlQaUJoSUNzZ1lqdGNibHh1WTI5dWMyOXNaUzVzYjJjb2MzVnRLREVzSURJcEtUdGNiaUpkZlE9PVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnyType\", function() { return AnyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayType\", function() { return ArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanLiteralType\", function() { return BooleanLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanType\", function() { return BooleanType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyType\", function() { return EmptyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExistentialType\", function() { return ExistentialType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlowIntoType\", function() { return FlowIntoType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionType\", function() { return FunctionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeParam\", function() { return FunctionTypeParam; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeRestParam\", function() { return FunctionTypeRestParam; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionTypeReturn\", function() { return FunctionTypeReturn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneratorType\", function() { return GeneratorType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenericType\", function() { return GenericType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntersectionType\", function() { return IntersectionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixedType\", function() { return MixedType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeAlias\", function() { return TypeAlias; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullableType\", function() { return NullableType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullLiteralType\", function() { return NullLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumberType\", function() { return NumberType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumericLiteralType\", function() { return NumericLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectType\", function() { return ObjectType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeCallProperty\", function() { return ObjectTypeCallProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeIndexer\", function() { return ObjectTypeIndexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectTypeProperty\", function() { return ObjectTypeProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedTypeAlias\", function() { return ParameterizedTypeAlias; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedFunctionType\", function() { return ParameterizedFunctionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PartialType\", function() { return PartialType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RefinementType\", function() { return RefinementType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringLiteralType\", function() { return StringLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringType\", function() { return StringType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolLiteralType\", function() { return SymbolLiteralType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolType\", function() { return SymbolType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThisType\", function() { return ThisType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TupleType\", function() { return TupleType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeBox\", function() { return TypeBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeConstructor\", function() { return TypeConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParameter\", function() { return TypeParameter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParameterApplication\", function() { return TypeParameterApplication; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeReference\", function() { return TypeReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeTDZ\", function() { return TypeTDZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnionType\", function() { return UnionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VoidType\", function() { return VoidType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Declaration\", function() { return Declaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeDeclaration\", function() { return TypeDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VarDeclaration\", function() { return VarDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ModuleDeclaration\", function() { return ModuleDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ModuleExportsDeclaration\", function() { return ModuleExports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassDeclaration\", function() { return ClassDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterizedClassDeclaration\", function() { return ParameterizedClassDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtendsDeclaration\", function() { return ExtendsDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeParametersSymbol\", function() { return TypeParametersSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeSymbol\", function() { return TypeSymbol; });\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nvar primitiveTypes = {};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction makeJSONError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var errors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : null;\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n      var field = stringifyPath(validation.path.concat(path));\n\n      var pointer = `/${path.join('/')}`;\n\n      errors.push({\n        pointer,\n        field,\n        message,\n        expected,\n        actual\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Tracks whether we're in validation of cyclic objects.\nvar cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\n\n\nvar cyclicToString = new WeakSet();\n\nfunction inValidationCycle(type, input) {\n  try {\n    var tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    } else {\n      return weakSetHas(tracked, input);\n    }\n  } catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nfunction startValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nfunction endValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nfunction inToStringCycle(type) {\n  return cyclicToString.has(type);\n}\n\nfunction startToStringCycle(type) {\n  cyclicToString.add(type);\n}\n\nfunction endToStringCycle(type) {\n  cyclicToString.delete(type);\n}\n\nfunction weakSetHas(weakset, value) {\n  try {\n    return weakset.has(value);\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction weakSetAdd(weakset, value) {\n  try {\n    weakset.add(value);\n  } catch (e) {}\n}\n\nfunction weakSetDelete(weakset, value) {\n  try {\n    weakset.delete(value);\n  } catch (e) {}\n}\n\nvar validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nvar Validation = function () {\n  function Validation(context, input) {\n    classCallCheck(this, Validation);\n    this.path = [];\n    this.prefix = '';\n    this.errors = [];\n    this.cyclic = new WeakMap();\n\n    this.context = context;\n    this.input = input;\n  }\n\n  // Tracks whether we're in validation of cyclic objects.\n\n\n  createClass(Validation, [{\n    key: 'inCycle',\n    value: function inCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        return false;\n      } else {\n        return weakSetHas(tracked, input);\n      }\n    }\n  }, {\n    key: 'startCycle',\n    value: function startCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        tracked = new WeakSet();\n        this.cyclic.set(type, tracked);\n      }\n      weakSetAdd(tracked, input);\n    }\n  }, {\n    key: 'endCycle',\n    value: function endCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (tracked) {\n        weakSetDelete(tracked, input);\n      }\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors(path) {\n      if (path) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var candidate = _ref2[0];\n\n            if (matchPath(path, candidate)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        return this.errors.length > 0;\n      }\n    }\n  }, {\n    key: 'addError',\n    value: function addError(path, expectedType, message) {\n      this.errors.push([path, message, expectedType]);\n      return this;\n    }\n  }, {\n    key: 'clearError',\n    value: function clearError(path) {\n      var didClear = false;\n      if (path) {\n        var _errors = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var error = _step2.value;\n\n            if (matchPath(path, error[0])) {\n              didClear = true;\n            } else {\n              _errors.push(error);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.errors = _errors;\n      } else {\n        didClear = this.errors.length > 0;\n        this.errors = [];\n      }\n      return didClear;\n    }\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path) {\n      return _resolvePath(this.input, path);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return makeJSONError(this);\n    }\n  }]);\n  return Validation;\n}();\n\nfunction stringifyPath(path) {\n  if (!path.length) {\n    return 'Value';\n  }\n  var length = path.length;\n\n  var parts = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    } else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    } else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    } else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nfunction _resolvePath(input, path) {\n  var subject = input;\n  var length = path.length;\n\n  for (var i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    } else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nfunction matchPath(path, candidate) {\n  var length = path.length;\n\n  if (length > candidate.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar RuntimeTypeError = function (_TypeError) {\n  inherits(RuntimeTypeError, _TypeError);\n\n  function RuntimeTypeError(message, options) {\n    classCallCheck(this, RuntimeTypeError);\n\n    var _this = possibleConstructorReturn(this, (RuntimeTypeError.__proto__ || Object.getPrototypeOf(RuntimeTypeError)).call(this, message));\n\n    _this.name = \"RuntimeTypeError\";\n\n    Object.assign(_this, options);\n    return _this;\n  }\n\n  return RuntimeTypeError;\n}(TypeError);\n\nvar delimiter = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeTypeError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var prefix = validation.prefix,\n      input = validation.input,\n      context = validation.context,\n      errors = validation.errors;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = _resolvePath(input, path);\n      var actualType = context.typeOf(actual).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      var actualAsString = makeString(actual);\n\n      if (typeof actualAsString === 'string') {\n        collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n      } else {\n        collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`, { errors });\n  } else {\n    return new RuntimeTypeError(collected.join(delimiter), { errors });\n  }\n}\n\nfunction makeString(value) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // Issue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        } catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}\n\nfunction makeError(expected, input) {\n  var context = expected.context;\n\n  var validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\n\n\nfunction compareTypes(a, b) {\n  var result = void 0;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  } else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  } else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  } else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  } else {\n    return result;\n  }\n}\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nvar Type = function () {\n  function Type(context) {\n    classCallCheck(this, Type);\n    this.typeName = 'Type';\n\n    this.context = context;\n  }\n\n  createClass(Type, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var validation = new Validation(this.context, input);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.errors(validation, [], input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n          // eslint-disable-line no-unused-vars\n          return false;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsType',\n    value: function acceptsType(input) {\n      if (compareTypes(this, input) === -1) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return -1;\n    }\n  }, {\n    key: 'assert',\n    value: function assert(input) {\n      var error = makeError(this, input);\n      if (error) {\n        if (typeof Error.captureStackTrace === 'function') {\n          Error.captureStackTrace(error, this.assert);\n        }\n        throw error;\n      }\n      return input;\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Type';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return Type;\n}();\n\nvar AnyType = function (_Type) {\n  inherits(AnyType, _Type);\n\n  function AnyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AnyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AnyType.__proto__ || Object.getPrototypeOf(AnyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'AnyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AnyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'any';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return AnyType;\n}(Type);\n\nvar errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nfunction getErrorMessage(key) {\n  for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, function (m, i) {\n      return String(params[i]);\n    });\n  } else {\n    return message;\n  }\n}\n\nvar TupleType = function (_Type) {\n  inherits(TupleType, _Type);\n\n  function TupleType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TupleType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TupleType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n      for (var i = 0; i < length; i++) {\n        yield* types[i].errors(validation, path.concat(i), input[i]);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n\n      if (!context.checkPredicate('Array', input) || input.length < length) {\n        return false;\n      }\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof TupleType)) {\n        return -1;\n      }\n      var types = this.types;\n      var inputTypes = input.types;\n      if (inputTypes.length < types.length) {\n        return -1;\n      }\n      var isGreater = false;\n      for (var i = 0; i < types.length; i++) {\n        var result = compareTypes(types[i], inputTypes[i]);\n        if (result === 1) {\n          isGreater = true;\n        } else if (result === -1) {\n          return -1;\n        }\n      }\n      if (types.length < inputTypes.length) {\n        return 0;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `[${this.types.join(', ')}]`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return TupleType;\n}(Type);\n\nvar ArrayType = function (_Type) {\n  inherits(ArrayType, _Type);\n\n  function ArrayType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ArrayType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ArrayType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ArrayType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n      if (validation.inCycle(this, input)) {\n        return;\n      }\n      validation.startCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n\n      for (var i = 0; i < length; i++) {\n        yield* elementType.errors(validation, path.concat(i), input[i]);\n      }\n      validation.endCycle(this, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n      for (var i = 0; i < length; i++) {\n        if (!elementType.accepts(input[i])) {\n          endValidationCycle(this, input);\n          return false;\n        }\n      }\n      endValidationCycle(this, input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var elementType = this.elementType;\n\n      if (input instanceof TupleType) {\n        var types = input.types;\n\n        for (var i = 0; i < types.length; i++) {\n          var result = compareTypes(elementType, types[i]);\n          if (result === -1) {\n            return -1;\n          }\n        }\n        return 1;\n      } else if (input instanceof ArrayType) {\n        return compareTypes(elementType, input.elementType);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var elementType = this.elementType;\n\n      if (inToStringCycle(this)) {\n        if (typeof elementType.name === 'string') {\n          return `Array<$Cycle<${elementType.name}>>`;\n        } else {\n          return `Array<$Cycle<Object>>`;\n        }\n      }\n      startToStringCycle(this);\n      var output = `Array<${elementType.toString()}>`;\n      endToStringCycle(this);\n      return output;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        elementType: this.elementType\n      };\n    }\n  }]);\n  return ArrayType;\n}(Type);\n\nvar BooleanLiteralType = function (_Type) {\n  inherits(BooleanLiteralType, _Type);\n\n  function BooleanLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanLiteralType.__proto__ || Object.getPrototypeOf(BooleanLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== this.value) {\n        yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.value ? 'true' : 'false';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        type: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return BooleanLiteralType;\n}(Type);\n\nvar BooleanType = function (_Type) {\n  inherits(BooleanType, _Type);\n\n  function BooleanType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanType.__proto__ || Object.getPrototypeOf(BooleanType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'boolean') {\n        yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'boolean';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType) {\n        return 1;\n      } else if (input instanceof BooleanType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'boolean';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return BooleanType;\n}(Type);\n\nvar EmptyType = function (_Type) {\n  inherits(EmptyType, _Type);\n\n  function EmptyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, EmptyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EmptyType.__proto__ || Object.getPrototypeOf(EmptyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'EmptyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(EmptyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return false; // empty types accepts nothing.\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof EmptyType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'empty';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return EmptyType;\n}(Type);\n\nvar ExistentialType = function (_Type) {\n  inherits(ExistentialType, _Type);\n\n  function ExistentialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExistentialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExistentialType.__proto__ || Object.getPrototypeOf(ExistentialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExistentialType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExistentialType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '*';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ExistentialType;\n}(Type);\n\n/**\n * # TypeParameterApplication\n *\n */\nvar TypeParameterApplication = function (_Type) {\n  inherits(TypeParameterApplication, _Type);\n\n  function TypeParameterApplication() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameterApplication);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameterApplication.__proto__ || Object.getPrototypeOf(TypeParameterApplication)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameterApplication', _this.typeInstances = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeParameterApplication, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      yield* parent.errors.apply(parent, [validation, path, input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      return parent.accepts.apply(parent, [input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var _parent;\n\n      return (_parent = this.parent).compareWith.apply(_parent, [input].concat(toConsumableArray(this.typeInstances)));\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.hasProperty === 'function') {\n        var _ref2;\n\n        return (_ref2 = inner).hasProperty.apply(_ref2, [name].concat(toConsumableArray(this.typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.getProperty === 'function') {\n        var _ref3;\n\n        return (_ref3 = inner).getProperty.apply(_ref3, [name].concat(toConsumableArray(this.typeInstances)));\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _parent2;\n\n      return (_parent2 = this.parent).unwrap.apply(_parent2, toConsumableArray(this.typeInstances));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n      var name = parent.name;\n\n      if (typeInstances.length) {\n        var items = [];\n        for (var i = 0; i < typeInstances.length; i++) {\n          var typeInstance = typeInstances[i];\n          items.push(typeInstance.toString());\n        }\n        return `${name}<${items.join(', ')}>`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeInstances: this.typeInstances\n      };\n    }\n  }]);\n  return TypeParameterApplication;\n}(Type);\n\n/**\n * Add constraints to the given subject type.\n */\nfunction addConstraints(subject) {\n  var _subject$constraints;\n\n  for (var _len = arguments.length, constraints = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    constraints[_key - 1] = arguments[_key];\n  }\n\n  (_subject$constraints = subject.constraints).push.apply(_subject$constraints, toConsumableArray(constraints));\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\n\n\nfunction* collectConstraintErrors(subject, validation, path) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len2 = arguments.length, input = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    input[_key2 - 3] = arguments[_key2];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    var violation = constraint.apply(undefined, toConsumableArray(input));\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nfunction constraintsAccept(subject) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len3 = arguments.length, input = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    input[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    if (typeof constraint.apply(undefined, toConsumableArray(input)) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar TypeAlias = function (_Type) {\n  inherits(TypeAlias, _Type);\n\n  function TypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeAlias.__proto__ || Object.getPrototypeOf(TypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeAlias', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeAlias, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          type = this.type;\n\n      if (withDeclaration) {\n        return `type ${name} = ${type.toString()};`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return this.type.properties;\n    }\n  }, {\n    key: 'hasConstraints',\n    get: function get$$1() {\n      return this.constraints.length > 0;\n    }\n  }]);\n  return TypeAlias;\n}(Type);\n\nvar FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\n\nvar TypeParameter = function (_Type) {\n  inherits(TypeParameter, _Type);\n\n  function TypeParameter() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  createClass(TypeParameter, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n\n      if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        yield* boundOrDefault.errors(validation, path, input);\n        return;\n      } else if (recorded) {\n        // we've already recorded a value for this type parameter\n        yield* recorded.errors(validation, path, input);\n        return;\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n          return;\n        } else {\n          var hasErrors = false;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = boundOrDefault.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var error = _step.value;\n\n              hasErrors = true;\n              yield error;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (hasErrors) {\n            return;\n          }\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n      if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        return boundOrDefault.accepts(input);\n      } else if (recorded) {\n        return recorded.accepts(input);\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n          return true;\n        } else if (!boundOrDefault.accepts(input)) {\n          return false;\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (input instanceof TypeParameter) {\n        // We don't need to check for `recorded` or `bound` fields\n        // because the input has already been unwrapped, so\n        // if we got a type parameter it must be totally generic and\n        // we treat it like Any.\n        return 1;\n      } else if (recorded) {\n        return compareTypes(recorded, input);\n      } else if (boundOrDefault) {\n        return compareTypes(boundOrDefault, input);\n      } else {\n        // A generic type parameter accepts any input.\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (recorded) {\n        return recorded.unwrap();\n      } else if (boundOrDefault) {\n        return boundOrDefault.unwrap();\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      var id = this.id,\n          bound = this.bound,\n          defaultType = this.default;\n\n      if (withBinding) {\n        if (defaultType) {\n          return `${id} = ${defaultType.toString()}`;\n        } else if (bound) {\n          return `${id}: ${bound.toString()}`;\n        }\n      }\n      return id;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        bound: this.bound,\n        recorded: this.recorded\n      };\n    }\n  }]);\n  return TypeParameter;\n}(Type);\n\nfunction flowIntoTypeParameter(typeParameter) {\n  var existing = typeParameter[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  var target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  typeParameter[FlowIntoSymbol] = target;\n  return target;\n}\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\n\nvar FlowIntoType = function (_Type) {\n  inherits(FlowIntoType, _Type);\n\n  function FlowIntoType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FlowIntoType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FlowIntoType.__proto__ || Object.getPrototypeOf(FlowIntoType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FlowIntoType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FlowIntoType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        yield* bound.errors(validation, path, input);\n        return;\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound) {\n          var hasError = false;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = bound.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var error = _step.value;\n\n              yield error;\n              hasError = true;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (hasError) {\n            return;\n          }\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return;\n        } else {\n          var _hasError = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = bound.errors(validation, path, input)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _error = _step2.value;\n\n              yield _error;\n              _hasError = true;\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (_hasError) {\n            return;\n          }\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.accepts(input);\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound && !bound.accepts(input)) {\n          return false;\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return true;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return true;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return true;\n        } else if (!bound.accepts(input)) {\n          return false;\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.compareWith(input);\n      }\n      if (recorded) {\n        if (bound && compareTypes(bound, input) === -1) {\n          return -1;\n        }\n        var result = compareTypes(recorded, input);\n        if (result === 0) {\n          // our existing type already permits this value, there's nothing to do.\n          return 0;\n        }\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, input);\n        return 1;\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return 1;\n        }\n        var _result = compareTypes(bound, input);\n        if (_result === -1) {\n          return -1;\n        }\n      }\n\n      typeParameter.recorded = input;\n      return 0;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.typeParameter.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return this.typeParameter.toString(withBinding);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.typeParameter.toJSON();\n    }\n  }]);\n  return FlowIntoType;\n}(Type);\n\nvar FunctionTypeRestParam = function (_Type) {\n  inherits(FunctionTypeRestParam, _Type);\n\n  function FunctionTypeRestParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeRestParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeRestParam.__proto__ || Object.getPrototypeOf(FunctionTypeRestParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeRestParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeRestParam, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      yield* type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return `...${this.name}: ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeRestParam;\n}(Type);\n\nvar FunctionTypeParam = function (_Type) {\n  inherits(FunctionTypeParam, _Type);\n\n  function FunctionTypeParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeParam.__proto__ || Object.getPrototypeOf(FunctionTypeParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeParam, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return;\n      } else {\n        yield* type.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return true;\n      } else {\n        return type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var optional = this.optional,\n          type = this.type;\n\n      return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        optional: this.optional,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeParam;\n}(Type);\n\nvar FunctionTypeReturn = function (_Type) {\n  inherits(FunctionTypeReturn, _Type);\n\n  function FunctionTypeReturn() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeReturn);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeReturn.__proto__ || Object.getPrototypeOf(FunctionTypeReturn)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeReturn', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeReturn, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeReturn) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeReturn;\n}(Type);\n\nvar ParentSymbol = Symbol('Parent');\nvar NameRegistrySymbol = Symbol('NameRegistry');\nvar ModuleRegistrySymbol = Symbol('ModuleRegistry');\nvar CurrentModuleSymbol = Symbol('CurrentModule');\nvar TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nvar InferrerSymbol = Symbol('Inferrer');\n\n\nvar TypeSymbol = Symbol('Type');\nvar TypeParametersSymbol = Symbol('TypeParameters');\nvar TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\nvar FunctionType = function (_Type) {\n  inherits(FunctionType, _Type);\n\n  function FunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      var annotation = input[TypeSymbol];\n      var returnType = this.returnType,\n          params = this.params;\n\n      if (annotation) {\n        if (!annotation.params) {\n          return;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            yield [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n          } else if (!param.acceptsType(annotationParam)) {\n            yield [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          yield [path, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()), this];\n        }\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i = 0; _i < params.length; _i++) {\n          var _param = params[_i];\n          _param.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var returnType = this.returnType,\n          params = this.params;\n\n      var annotation = input[TypeSymbol];\n      if (annotation) {\n        if (!annotation.params) {\n          return true;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            return false;\n          } else if (!param.acceptsType(annotationParam)) {\n            return false;\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          return false;\n        }\n        return true;\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i2 = 0; _i2 < params.length; _i2++) {\n          var _param2 = params[_i2];\n          _param2.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof FunctionType)) {\n        return -1;\n      }\n      var returnType = this.returnType;\n      var inputReturnType = input.returnType;\n      var isGreater = false;\n      var returnTypeResult = compareTypes(returnType, inputReturnType);\n      if (returnTypeResult === -1) {\n        return -1;\n      } else if (returnTypeResult === 1) {\n        isGreater = true;\n      }\n\n      var params = this.params;\n      var inputParams = input.params;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        var inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n        if (inputParam == null) {\n          return -1;\n        }\n        var result = compareTypes(param, inputParam);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n      }\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.accepts(args[i])) {\n            return false;\n          }\n        } else if (!param.accepts(undefined)) {\n          return false;\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {\n          if (!rest.accepts(args[_i3])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          param.assert(args[i]);\n        } else {\n          param.assert(undefined);\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i4 = paramsLength; _i4 < argsLength; _i4++) {\n          rest.assert(args[_i4]);\n        }\n      }\n\n      return args;\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      this.returnType.assert(input);\n      return input;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var params = this.params,\n          rest = this.rest,\n          context = this.context;\n\n      var paramsLength = params.length;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.acceptsType(args[i])) {\n            return context.empty();\n          }\n        } else if (!param.accepts(undefined)) {\n          return context.empty();\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i5 = paramsLength; _i5 < argsLength; _i5++) {\n          if (!rest.acceptsType(args[_i5])) {\n            return context.empty();\n          }\n        }\n      }\n\n      return this.returnType.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = this.params,\n          rest = this.rest,\n          returnType = this.returnType;\n\n      var args = [];\n      for (var i = 0; i < params.length; i++) {\n        args.push(params[i].toString());\n      }\n      if (rest) {\n        args.push(rest.toString());\n      }\n      return `(${args.join(', ')}) => ${returnType.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        params: this.params,\n        rest: this.rest,\n        returnType: this.returnType\n      };\n    }\n  }]);\n  return FunctionType;\n}(Type);\n\nvar GeneratorType = function (_Type) {\n  inherits(GeneratorType, _Type);\n\n  function GeneratorType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeneratorType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeneratorType.__proto__ || Object.getPrototypeOf(GeneratorType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GeneratorType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeneratorType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var isValid = input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n      if (!isValid) {\n        yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof GeneratorType)) {\n        var _result = compareTypes(this.yieldType, input);\n        if (_result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      var isGreater = false;\n      var result = compareTypes(this.yieldType, input.yieldType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.returnType, input.returnType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.nextType, input.nextType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsYield',\n    value: function acceptsYield(input) {\n      return this.yieldType.accepts(input);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'acceptsNext',\n    value: function acceptsNext(input) {\n      return this.nextType.accepts(input);\n    }\n  }, {\n    key: 'assertYield',\n    value: function assertYield(input) {\n      return this.yieldType.assert(input);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return this.returnType.assert(input);\n    }\n  }, {\n    key: 'assertNext',\n    value: function assertNext(input) {\n      return this.nextType.assert(input);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var yieldType = this.yieldType,\n          returnType = this.returnType,\n          nextType = this.nextType;\n\n      return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        yieldType: this.yieldType,\n        returnType: this.returnType,\n        nextType: this.nextType\n      };\n    }\n  }]);\n  return GeneratorType;\n}(Type);\n\nvar warnedInstances = new WeakSet();\n\nvar TypeConstructor = function (_Type) {\n  inherits(TypeConstructor, _Type);\n\n  function TypeConstructor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeConstructor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeConstructor.__proto__ || Object.getPrototypeOf(TypeConstructor)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeConstructor', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeConstructor, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n        warnedInstances.add(this);\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n        warnedInstances.add(this);\n      }\n      return -1;\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }]);\n  return TypeConstructor;\n}(Type);\n\nvar GenericType = function (_TypeConstructor) {\n  inherits(GenericType, _TypeConstructor);\n\n  function GenericType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GenericType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GenericType.__proto__ || Object.getPrototypeOf(GenericType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = \"GenericType\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GenericType, [{\n    key: \"errors\",\n    value: function* errors(validation, path, input) {\n      var name = this.name,\n          impl = this.impl;\n\n      if (!(input instanceof impl)) {\n        yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n      }\n    }\n  }, {\n    key: \"accepts\",\n    value: function accepts(input) {\n      var impl = this.impl;\n\n      return input instanceof impl;\n    }\n  }, {\n    key: \"compareWith\",\n    value: function compareWith(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var expected = annotation.unwrap.apply(annotation, toConsumableArray(typeInstances));\n        return compareTypes(input, expected);\n      } else if (input instanceof GenericType && (input.impl === impl || impl && impl.isPrototypeOf(input.impl))) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      var context = this.context,\n          impl = this.impl;\n\n      if (typeof impl !== \"function\") {\n        return this;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation != null) {\n        return annotation.unwrap.apply(annotation, arguments);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"inferTypeParameters\",\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }]);\n  return GenericType;\n}(TypeConstructor);\n\nfunction invariant(input, message) {\n  if (!input) {\n    var error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\nvar NullLiteralType = function (_Type) {\n  inherits(NullLiteralType, _Type);\n\n  function NullLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullLiteralType.__proto__ || Object.getPrototypeOf(NullLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== null) {\n        yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === null;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'null';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NullLiteralType;\n}(Type);\n\nvar VoidType = function (_Type) {\n  inherits(VoidType, _Type);\n\n  function VoidType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VoidType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VoidType.__proto__ || Object.getPrototypeOf(VoidType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VoidType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VoidType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input !== undefined) {\n        yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === undefined;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof VoidType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'void';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return VoidType;\n}(Type);\n\nvar NullableType = function (_Type) {\n  inherits(NullableType, _Type);\n\n  function NullableType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullableType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullableType.__proto__ || Object.getPrototypeOf(NullableType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullableType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullableType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input != null) {\n        yield* this.type.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input == null) {\n        return true;\n      } else {\n        return this.type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType || input instanceof VoidType) {\n        return 1;\n      } else if (input instanceof NullableType) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `? ${this.type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return NullableType;\n}(Type);\n\nvar ObjectTypeProperty = function (_Type) {\n  inherits(ObjectTypeProperty, _Type);\n\n  function ObjectTypeProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeProperty.__proto__ || Object.getPrototypeOf(ObjectTypeProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeProperty', _this['static'] = false, _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeProperty, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n\n    /**\n     * Determine whether the property is nullable.\n     */\n\n  }, {\n    key: 'isNullable',\n    value: function isNullable() {\n      return this.value instanceof NullableType;\n    }\n\n    /**\n     * Determine whether the property exists on the given input or its prototype chain.\n     */\n\n  }, {\n    key: 'existsOn',\n    value: function existsOn(input) {\n      // Ignore\n      var key = this.key,\n          isStatic = this.static;\n\n      return key in (isStatic ? input.constructor : input) === true;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      var targetPath = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        targetPath = path.concat('constructor');\n        if (typeof input.constructor !== 'function') {\n          if (!optional) {\n            yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n          }\n          return;\n        }\n        targetPath.push(key);\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n        targetPath = path.concat(key);\n      }\n      if (optional && target === undefined) {\n        return;\n      }\n      if (this.isNullable() && !this.existsOn(input)) {\n        yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n        return;\n      }\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = value.errors(validation, targetPath, target)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, targetPath, target);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return optional ? true : false;\n        }\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n      }\n\n      if (optional && target === undefined) {\n        return true;\n      }\n\n      if (this.isNullable() && !this.existsOn(input)) {\n        return false;\n      }\n\n      if (!value.accepts(target)) {\n        return false;\n      } else {\n        return constraintsAccept(this, target);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeProperty)) {\n        return -1;\n      } else if (input.key !== this.key) {\n        return -1;\n      } else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var key = this.key;\n      // Issue 252\n      if (typeof key === 'symbol') {\n        key = `[${key.toString()}]`;\n      }\n      if (this.static) {\n        return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n      } else {\n        return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        key: this.key,\n        value: this.value,\n        optional: this.optional\n      };\n    }\n  }]);\n  return ObjectTypeProperty;\n}(Type);\n\nvar ObjectTypeIndexer = function (_Type) {\n  inherits(ObjectTypeIndexer, _Type);\n\n  function ObjectTypeIndexer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeIndexer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeIndexer.__proto__ || Object.getPrototypeOf(ObjectTypeIndexer)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeIndexer', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectTypeIndexer, [{\n    key: 'errors',\n    value: function* errors(validation, path, key, value) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n\n      yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n      yield* this.value.errors(validation, path.concat(key), value);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'acceptsKey',\n    value: function acceptsKey(key) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n      return this.key.accepts(key);\n    }\n  }, {\n    key: 'acceptsValue',\n    value: function acceptsValue(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ObjectTypeProperty) {\n        if (!this.key.accepts(input.key)) {\n          return -1;\n        } else {\n          return compareTypes(this.value, input.value);\n        }\n      } else if (!(input instanceof ObjectTypeIndexer)) {\n        return -1;\n      }\n\n      var keyResult = compareTypes(this.key, input.key);\n      if (keyResult === -1) {\n        return -1;\n      }\n      var valueResult = compareTypes(this.value, input.value);\n      if (valueResult === -1) {\n        return -1;\n      }\n\n      if (keyResult === 0 && valueResult === 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        key: this.key,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeIndexer;\n}(Type);\n\nvar ObjectTypeCallProperty = function (_Type) {\n  inherits(ObjectTypeCallProperty, _Type);\n\n  function ObjectTypeCallProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeCallProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeCallProperty.__proto__ || Object.getPrototypeOf(ObjectTypeCallProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeCallProperty', _this['static'] = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeCallProperty, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n\n      var target = void 0;\n      var targetPath = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        targetPath = path.concat('constructor');\n        if (typeof input.constructor !== 'function') {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n          return;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n        targetPath = path;\n      }\n      yield* value.errors(validation, targetPath, target);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return false;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n      }\n      return value.accepts(target);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeCallProperty)) {\n        return -1;\n      }\n      return compareTypes(this.value, input.value);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.static) {\n        return `static ${this.value.toString()};`;\n      } else {\n        return this.value.toString();\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeCallProperty;\n}(Type);\n\nvar Declaration = function (_Type) {\n  inherits(Declaration, _Type);\n\n  function Declaration() {\n    classCallCheck(this, Declaration);\n    return possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).apply(this, arguments));\n  }\n\n  return Declaration;\n}(Type);\n\nvar VarDeclaration = function (_Declaration) {\n  inherits(VarDeclaration, _Declaration);\n\n  function VarDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VarDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VarDeclaration.__proto__ || Object.getPrototypeOf(VarDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VarDeclaration', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VarDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare var ${this.name}: ${this.type.toString()};`;\n    }\n  }]);\n  return VarDeclaration;\n}(Declaration);\n\nvar TypeDeclaration = function (_Declaration) {\n  inherits(TypeDeclaration, _Declaration);\n\n  function TypeDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeDeclaration.__proto__ || Object.getPrototypeOf(TypeDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      var _typeAlias;\n\n      (_typeAlias = this.typeAlias).addConstraint.apply(_typeAlias, arguments);\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.typeAlias.errors(validation, path, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _typeAlias2;\n\n      return (_typeAlias2 = this.typeAlias).apply.apply(_typeAlias2, arguments);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.typeAlias.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.typeAlias, input);\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var _typeAlias3;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_typeAlias3 = this.typeAlias).hasProperty.apply(_typeAlias3, [name].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var _typeAlias4;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_typeAlias4 = this.typeAlias).getProperty.apply(_typeAlias4, [name].concat(toConsumableArray(typeInstances)));\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _typeAlias5;\n\n      return (_typeAlias5 = this.typeAlias).unwrap.apply(_typeAlias5, arguments);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare ${this.typeAlias.toString(true)};`;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return this.typeAlias.type;\n    }\n  }]);\n  return TypeDeclaration;\n}(Declaration);\n\nvar ModuleDeclaration = function (_Declaration) {\n  inherits(ModuleDeclaration, _Declaration);\n\n  function ModuleDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleDeclaration.__proto__ || Object.getPrototypeOf(ModuleDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleDeclaration, [{\n    key: 'get',\n    value: function get$$1(name) {\n      var moduleExports = this.moduleExports;\n\n      if (moduleExports) {\n        var exporting = moduleExports.unwrap();\n        if (typeof exporting.getProperty === 'function') {\n          var prop = exporting.getProperty(name);\n          if (prop) {\n            return prop.unwrap();\n          }\n        }\n      } else {\n        var declaration = this.declarations[name];\n        if (declaration) {\n          return declaration.unwrap();\n        }\n      }\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Can't validate a module directly.\n      // @todo should this throw?\n    }\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      if (/^\\.\\//.test(moduleName)) {\n        moduleName = `${this.name}${moduleName.slice(1)}`;\n      }\n      return this.innerContext.import(moduleName);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var name = this.name,\n          declarations = this.declarations,\n          modules = this.modules,\n          moduleExports = this.moduleExports;\n\n      var body = [];\n      for (var _name in declarations) {\n        // eslint-disable-line guard-for-in\n        var declaration = declarations[_name];\n        body.push(declaration.toString(true));\n      }\n      if (modules) {\n        for (var _name2 in modules) {\n          // eslint-disable-line guard-for-in\n          var module = modules[_name2];\n          body.push(module.toString());\n        }\n      }\n      if (moduleExports) {\n        body.push(moduleExports.toString());\n      }\n      return `declare module \"${name}\" {\\n${indent$1(body.join('\\n\\n'))}}`;\n    }\n  }, {\n    key: 'moduleType',\n    get: function get$$1() {\n      if (this.moduleExports) {\n        return 'commonjs';\n      } else {\n        return 'es6';\n      }\n    }\n  }, {\n    key: 'isCommonJS',\n    get: function get$$1() {\n      return this.moduleExports ? true : false;\n    }\n  }, {\n    key: 'isES6',\n    get: function get$$1() {\n      return this.moduleExports ? false : true;\n    }\n  }, {\n    key: 'declarations',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[NameRegistrySymbol];\n    }\n  }, {\n    key: 'modules',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[ModuleRegistrySymbol];\n    }\n  }]);\n  return ModuleDeclaration;\n}(Declaration);\n\nfunction indent$1(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\nvar ModuleExports = function (_Declaration) {\n  inherits(ModuleExports, _Declaration);\n\n  function ModuleExports() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleExports);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleExports.__proto__ || Object.getPrototypeOf(ModuleExports)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleExports', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleExports, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `declare module.exports: ${this.type.toString()};`;\n    }\n  }]);\n  return ModuleExports;\n}(Declaration);\n\nvar ClassDeclaration = function (_Declaration) {\n  inherits(ClassDeclaration, _Declaration);\n\n  function ClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassDeclaration.__proto__ || Object.getPrototypeOf(ClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n        return;\n      }\n      if (superClass) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = superClass.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n\n            var _ref3 = slicedToArray(_ref2, 3);\n\n            var errorPath = _ref3[0];\n            var errorMessage = _ref3[1];\n            var expectedType = _ref3[2];\n\n            var propertyName = errorPath[path.length];\n            if (body.getProperty(propertyName)) {\n              continue;\n            } else {\n              yield [errorPath, errorMessage, expectedType];\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      yield* body.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      } else if (superClass && !superClass.accepts(input)) {\n        return false;\n      } else if (!body.accepts(input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ClassDeclaration) {\n        if (input === this) {\n          return 0;\n        } else if (this.isSuperClassOf(input)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      return compareTypes(this.body, input);\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      var prop = body.getProperty(key);\n      if (prop) {\n        return prop;\n      } else if (superClass && typeof superClass.getProperty === 'function') {\n        return superClass.getProperty(key);\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (body.hasProperty(key)) {\n        return true;\n      } else if (superClass && typeof superClass.hasProperty === 'function') {\n        return superClass.hasProperty(key);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine whether this class declaration represents a super class of\n     * the given type.\n     */\n\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      var body = this.body,\n          shapeID = this.shapeID;\n\n      var current = candidate;\n\n      while (current != null) {\n        if (current === this || current === body || current.shapeID === shapeID) {\n          return true;\n        }\n        if (current instanceof ClassDeclaration) {\n          current = current.superClass;\n        } else {\n          current = current.unwrap();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          superClass = this.superClass,\n          body = this.body;\n\n      if (withDeclaration) {\n        var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n        return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (superClass == null) {\n        return body.properties;\n      }\n      var bodyProps = body.properties;\n      var superProps = superClass.unwrap().properties;\n      if (superProps == null) {\n        return bodyProps;\n      }\n      var seen = {};\n      var seenStatic = {};\n      var props = [];\n      for (var i = 0; i < superProps.length; i++) {\n        var prop = superProps[i];\n        props.push(prop);\n        if (prop.static) {\n          seenStatic[prop.key] = i;\n        } else {\n          seen[prop.key] = i;\n        }\n      }\n      for (var _i = 0; _i < bodyProps.length; _i++) {\n        var _prop = bodyProps[_i];\n        if (seen[_prop.key]) {\n          props[_i] = _prop;\n        } else {\n          props.push(_prop);\n        }\n      }\n      return props;\n    }\n  }]);\n  return ClassDeclaration;\n}(Declaration);\n\nvar PartialType = function (_Type) {\n  inherits(PartialType, _Type);\n\n  function PartialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, PartialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PartialType.__proto__ || Object.getPrototypeOf(PartialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'PartialType', _this.typeParameters = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(PartialType, [{\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this.context);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      this.typeParameters.push(target);\n      return target;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors && constraints) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (constraints && !constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(expand) {\n      var type = this.type;\n\n      return type.toString(expand);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeParameters: this.typeParameters,\n        type: this.type\n      };\n    }\n  }]);\n  return PartialType;\n}(Type);\n\nvar ParameterizedClassDeclaration = function (_Declaration) {\n  inherits(ParameterizedClassDeclaration, _Declaration);\n\n  function ParameterizedClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedClassDeclaration.__proto__ || Object.getPrototypeOf(ParameterizedClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedClassDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return getPartial(this).compareWith(input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).type;\n    }\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      return getPartial(this).type.isSuperClassOf(candidate);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len5 = arguments.length, typeInstances = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeInstances[_key5] = arguments[_key5];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      if (!withDeclaration) {\n        return this.name;\n      }\n      var partial = getPartial(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return partial.toString(true);\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      var superClass = type.superClass,\n          body = type.body;\n\n      var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n      return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getPartial(this).toJSON();\n    }\n  }, {\n    key: 'superClass',\n    get: function get$$1() {\n      return getPartial(this).type.superClass;\n    }\n  }, {\n    key: 'body',\n    get: function get$$1() {\n      return getPartial(this).type.body;\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial(this).type.properties;\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial(this).typeParameters;\n    }\n  }]);\n  return ParameterizedClassDeclaration;\n}(Declaration);\n\nfunction getPartial(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class.apply(context, [parent.name].concat(toConsumableArray(body)));\n  } else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  partial.type.shapeID = parent.shapeID;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len6 = arguments.length, typeInstances = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    typeInstances[_key6 - 1] = arguments[_key6];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ExtendsDeclaration = function (_Declaration) {\n  inherits(ExtendsDeclaration, _Declaration);\n\n  function ExtendsDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExtendsDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExtendsDeclaration.__proto__ || Object.getPrototypeOf(ExtendsDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExtendsDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExtendsDeclaration, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var type = this.type;\n\n      if (withDeclaration) {\n        return `extends ${type.toString()}`;\n      } else {\n        return type.toString();\n      }\n    }\n  }]);\n  return ExtendsDeclaration;\n}(Declaration);\n\nvar ObjectType = function (_Type) {\n  inherits(ObjectType, _Type);\n\n  function ObjectType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectType, [{\n    key: 'getProperty',\n\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n    value: function getProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return property;\n        }\n      }\n      return this.getIndexer(key);\n    }\n  }, {\n    key: 'setProperty',\n    value: function setProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var context = this.context,\n          properties = this.properties;\n      var length = properties.length;\n\n      var newProp = new ObjectTypeProperty(context);\n      newProp.key = key;\n      newProp.value = value;\n      newProp.optional = optional;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          properties[i] = newProp;\n          return;\n        }\n      }\n      properties.push(newProp);\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return true;\n        }\n      }\n      return this.hasIndexer(key);\n    }\n\n    /**\n     * Get an indexer with which matches the given key type.\n     */\n\n  }, {\n    key: 'getIndexer',\n    value: function getIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return indexer;\n        }\n      }\n    }\n\n    /**\n     * Determine whether an indexer exists which matches the given key type.\n     */\n\n  }, {\n    key: 'hasIndexer',\n    value: function hasIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (input === null) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n        }\n      } else if (typeof input !== 'object') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      if (validation.inCycle(this, input)) {\n        return;\n      }\n      validation.startCycle(this, input);\n\n      if (this.indexers.length > 0) {\n        if (input instanceof Object && Array.isArray(input)) {\n          yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n          return;\n        }\n        yield* collectErrorsWithIndexers(this, validation, path, input);\n      } else {\n        yield* collectErrorsWithoutIndexers(this, validation, path, input);\n      }\n      if (this.exact) {\n        yield* collectErrorsExact(this, validation, path, input);\n      }\n      validation.endCycle(this, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input === null) {\n        return false;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          return false;\n        }\n      } else if (typeof input !== 'object') {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = acceptsWithIndexers(this, input);\n      } else {\n        result = acceptsWithoutIndexers(this, input);\n      }\n      if (result && this.exact) {\n        result = acceptsExact(this, input);\n      }\n      endValidationCycle(this, input);\n      return result;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n        return -1;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      var isGreater = false;\n      if (hasCallProperties) {\n        var _result = compareTypeCallProperties(this, input);\n        if (_result === -1) {\n          return -1;\n        } else if (_result === 1) {\n          isGreater = true;\n        }\n      }\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = compareTypeWithIndexers(this, input);\n      } else {\n        result = compareTypeWithoutIndexers(this, input);\n      }\n\n      if (result === -1) {\n        return -1;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var callProperties = this.callProperties,\n          properties = this.properties,\n          indexers = this.indexers;\n\n      if (inToStringCycle(this)) {\n        return '$Cycle<Object>';\n      }\n      startToStringCycle(this);\n      var body = [];\n      for (var i = 0; i < callProperties.length; i++) {\n        body.push(callProperties[i].toString());\n      }\n      for (var _i = 0; _i < properties.length; _i++) {\n        body.push(properties[_i].toString());\n      }\n      for (var _i2 = 0; _i2 < indexers.length; _i2++) {\n        body.push(indexers[_i2].toString());\n      }\n      endToStringCycle(this);\n      if (this.exact) {\n        return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n      } else {\n        return `{\\n${indent(body.join('\\n'))}\\n}`;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        callProperties: this.callProperties,\n        properties: this.properties,\n        indexers: this.indexers,\n        exact: this.exact\n      };\n    }\n  }]);\n  return ObjectType;\n}(Type);\n\nfunction acceptsCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareTypeCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  var inputCallProperties = input.callProperties;\n  var identicalCount = 0;\n  loop: for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n\n    for (var j = 0; j < inputCallProperties.length; j++) {\n      var inputCallProperty = inputCallProperties[j];\n      var result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      } else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers(type, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i3 = 0; _i3 < indexers.length; _i3++) {\n      var indexer = indexers[_i3];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers(type, input) {\n  var indexers = type.indexers,\n      properties = type.properties;\n\n  var inputIndexers = input.indexers;\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {\n    var indexer = indexers[_i4];\n    for (var _j = 0; _j < inputIndexers.length; _j++) {\n      var inputIndexer = inputIndexers[_j];\n      var _result2 = compareTypes(indexer, inputIndexer);\n      if (_result2 === 1) {\n        isGreater = true;\n        continue loop;\n      } else if (_result2 === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction acceptsWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact(type, input) {\n  var properties = type.properties;\n\n  var _loop = function _loop(key) {\n    // eslint-disable-line guard-for-in\n    if (!properties.some(function (property) {\n      return property.key === key;\n    })) {\n      return {\n        v: false\n      };\n    }\n  };\n\n  for (var key in input) {\n    var _ret2 = _loop(key);\n\n    if (typeof _ret2 === \"object\") return _ret2.v;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction* collectErrorsWithIndexers(type, validation, path, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i5 = 0; _i5 < indexers.length; _i5++) {\n      var indexer = indexers[_i5];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\nfunction* collectErrorsWithoutIndexers(type, validation, path, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\nfunction* collectErrorsExact(type, validation, path, input) {\n  var properties = type.properties;\n\n  var _loop2 = function* _loop2(key) {\n    // eslint-disable-line guard-for-in\n    if (!properties.some(function (property) {\n      return property.key === key;\n    })) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  };\n\n  for (var key in input) {\n    yield* _loop2(key);\n  }\n}\n\nfunction indent(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\nvar IntersectionType = function (_Type) {\n  inherits(IntersectionType, _Type);\n\n  function IntersectionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, IntersectionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IntersectionType.__proto__ || Object.getPrototypeOf(IntersectionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'IntersectionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(IntersectionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        yield* types[i].errors(validation, path, input);\n      }\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = length - 1; i >= 0; i--) {\n        var type = types[i];\n        if (typeof type.getProperty === 'function') {\n          var prop = type.getProperty(key);\n          if (prop) {\n            return prop;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      var identicalCount = 0;\n      if (input instanceof IntersectionType) {\n        var inputTypes = input.types;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n        return identicalCount === types.length ? 0 : 1;\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          var _result = compareTypes(_type, input);\n          if (_result === -1) {\n            return -1;\n          } else if (_result === 0) {\n            identicalCount++;\n          }\n        }\n        return identicalCount === types.length ? 0 : 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _ref2;\n\n      var callProperties = [];\n      var properties = [];\n      var indexers = [];\n      var types = this.types,\n          context = this.context;\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        invariant(type instanceof ObjectType, 'Can only intersect object types');\n        callProperties.push.apply(callProperties, toConsumableArray(type.callProperties));\n        indexers.push.apply(indexers, toConsumableArray(type.indexers));\n        mergeProperties(properties, type.properties);\n      }\n      return (_ref2 = context).object.apply(_ref2, callProperties.concat(properties, indexers));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.types.join(' & ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return IntersectionType;\n}(Type);\n\nfunction getPropertyIndex(name, properties) {\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    var typeProp = source[i];\n    var index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    } else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\nvar MixedType = function (_Type) {\n  inherits(MixedType, _Type);\n\n  function MixedType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, MixedType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MixedType.__proto__ || Object.getPrototypeOf(MixedType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'MixedType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(MixedType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {}\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'mixed';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return MixedType;\n}(Type);\n\nvar NumericLiteralType = function (_Type) {\n  inherits(NumericLiteralType, _Type);\n\n  function NumericLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumericLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumericLiteralType.__proto__ || Object.getPrototypeOf(NumericLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumericLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumericLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumericLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `${this.value}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return NumericLiteralType;\n}(Type);\n\nvar NumberType = function (_Type) {\n  inherits(NumberType, _Type);\n\n  function NumberType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumberType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumberType.__proto__ || Object.getPrototypeOf(NumberType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumberType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumberType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'number') {\n        yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'number';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumberType) {\n        return 0;\n      } else if (input instanceof NumericLiteralType) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'number';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NumberType;\n}(Type);\n\nvar ParameterizedTypeAlias = function (_TypeAlias) {\n  inherits(ParameterizedTypeAlias, _TypeAlias);\n\n  function ParameterizedTypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedTypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedTypeAlias.__proto__ || Object.getPrototypeOf(ParameterizedTypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedTypeAlias', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedTypeAlias, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      var partial = getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances)));\n      if (!partial.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(getPartial$1(this), input);\n      }\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        typeInstances[_key5 - 1] = arguments[_key5];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len6 = arguments.length, typeInstances = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeInstances[_key6] = arguments[_key6];\n      }\n\n      return getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var partial = getPartial$1(this);\n      var typeParameters = partial.typeParameters;\n\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n\n      var name = this.name;\n\n      var identifier = typeParameters.length > 0 ? `${name}<${items.join(', ')}>` : name;\n\n      if (withDeclaration) {\n        return `type ${identifier} = ${partial.toString()};`;\n      } else {\n        return identifier;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$1(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial$1(this).type.properties;\n    }\n  }]);\n  return ParameterizedTypeAlias;\n}(TypeAlias);\n\nfunction getPartial$1(parent) {\n  var typeCreator = parent.typeCreator,\n      context = parent.context,\n      name = parent.name;\n\n  var partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len7 = arguments.length, typeInstances = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    typeInstances[_key7 - 1] = arguments[_key7];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ParameterizedFunctionType = function (_Type) {\n  inherits(ParameterizedFunctionType, _Type);\n\n  function ParameterizedFunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedFunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedFunctionType.__proto__ || Object.getPrototypeOf(ParameterizedFunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedFunctionType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedFunctionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      yield* getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getPartial$2(this), input);\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var _getPartial$type;\n\n      return (_getPartial$type = getPartial$2(this).type).acceptsParams.apply(_getPartial$type, arguments);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return getPartial$2(this).type.acceptsReturn(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var _getPartial$type2;\n\n      return (_getPartial$type2 = getPartial$2(this).type).assertParams.apply(_getPartial$type2, arguments);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return getPartial$2(this).type.assertReturn(input);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var partial = getPartial$2(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return type.toString();\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      return `<${items.join(', ')}> ${type.toString()}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$2(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial$2(this).typeParameters;\n    }\n  }, {\n    key: 'params',\n    get: function get$$1() {\n      return getPartial$2(this).type.params;\n    }\n  }, {\n    key: 'rest',\n    get: function get$$1() {\n      return getPartial$2(this).type.rest;\n    }\n  }, {\n    key: 'returnType',\n    get: function get$$1() {\n      return getPartial$2(this).type.returnType;\n    }\n  }]);\n  return ParameterizedFunctionType;\n}(Type);\n\nfunction getPartial$2(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  partial.type = context.function.apply(context, toConsumableArray(body));\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    typeInstances[_key5 - 1] = arguments[_key5];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar RefinementType = function (_Type) {\n  inherits(RefinementType, _Type);\n\n  function RefinementType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RefinementType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RefinementType.__proto__ || Object.getPrototypeOf(RefinementType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'RefinementType', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(RefinementType, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n      var hasErrors = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = type.errors(validation, path, input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n\n          hasErrors = true;\n          yield error;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!hasErrors) {\n        yield* collectConstraintErrors(this, validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return `$Refinment<${type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return RefinementType;\n}(Type);\n\nvar StringLiteralType = function (_Type) {\n  inherits(StringLiteralType, _Type);\n\n  function StringLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringLiteralType.__proto__ || Object.getPrototypeOf(StringLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return StringLiteralType;\n}(Type);\n\nvar StringType = function (_Type) {\n  inherits(StringType, _Type);\n\n  function StringType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringType.__proto__ || Object.getPrototypeOf(StringType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      if (typeof input !== 'string') {\n        yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'string';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType) {\n        return 1;\n      } else if (input instanceof StringType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return StringType;\n}(Type);\n\nvar SymbolLiteralType = function (_Type) {\n  inherits(SymbolLiteralType, _Type);\n\n  function SymbolLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolLiteralType.__proto__ || Object.getPrototypeOf(SymbolLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolLiteralType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var value = this.value;\n\n      if (input !== value) {\n        yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `typeof ${String(this.value)}`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return SymbolLiteralType;\n}(Type);\n\nvar SymbolType = function (_Type) {\n  inherits(SymbolType, _Type);\n\n  function SymbolType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolType.__proto__ || Object.getPrototypeOf(SymbolType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      // Issue 252\n      if (typeof input !== 'symbol') {\n        yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'symbol';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType) {\n        return 1;\n      } else if (input instanceof SymbolType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Symbol';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return SymbolType;\n}(Type);\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\n\nvar ThisType = function (_Type) {\n  inherits(ThisType, _Type);\n\n  function ThisType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ThisType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ThisType.__proto__ || Object.getPrototypeOf(ThisType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ThisType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ThisType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return;\n      } else if (recorded != null) {\n        yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return true;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return true;\n      } else if (recorded != null) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ThisType)) {\n        return -1;\n      } else if (input.recorded && this.recorded) {\n        return input.recorded === this.recorded ? 0 : -1;\n      } else if (this.recorded) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return 'this';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ThisType;\n}(Type);\n\nvar warnedInstances$1 = new WeakSet();\n\nvar TypeBox = function (_Type) {\n  inherits(TypeBox, _Type);\n\n  function TypeBox() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeBox);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeBox.__proto__ || Object.getPrototypeOf(TypeBox)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeBox', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeBox, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this.type;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.type.toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      return this.type.name;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var reveal = this.reveal;\n\n      var type = reveal();\n      if (!type) {\n        if (!warnedInstances$1.has(this)) {\n          this.context.emitWarningMessage('Failed to reveal boxed type.');\n          warnedInstances$1.add(this);\n        }\n        return this.context.mixed();\n      } else if (!(type instanceof Type)) {\n        // we got a boxed reference to something like a class\n        return this.context.ref(type);\n      }\n      return type;\n    }\n  }]);\n  return TypeBox;\n}(Type);\n\nvar warnedMissing = {};\n\nvar TypeReference = function (_Type) {\n  inherits(TypeReference, _Type);\n\n  function TypeReference() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeReference);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeReference.__proto__ || Object.getPrototypeOf(TypeReference)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeReference', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeReference, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var context = this.context,\n          name = this.name;\n\n      var type = context.get(name);\n      if (!type) {\n        if (!warnedMissing[name]) {\n          context.emitWarningMessage(`Cannot resolve type: ${name}`);\n          warnedMissing[name] = true;\n        }\n        return context.any();\n      }\n      return type;\n    }\n  }]);\n  return TypeReference;\n}(Type);\n\nvar warnedInstances$2 = new WeakSet();\n\nvar RevealedName = Symbol('RevealedName');\nvar RevealedValue = Symbol('RevealedValue');\n\nvar TypeTDZ = function (_Type) {\n  inherits(TypeTDZ, _Type);\n\n  function TypeTDZ() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeTDZ);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeTDZ.__proto__ || Object.getPrototypeOf(TypeTDZ)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeTDZ', _this[RevealedName] = undefined, _this[RevealedValue] = undefined, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeTDZ, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* getRevealed(this).errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return getRevealed(this).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getRevealed(this), input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = getRevealed(this);\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return getRevealed(this).unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return getRevealed(this).toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getRevealed(this).toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      var name = this[RevealedName];\n      if (!name) {\n        name = getRevealed(this).name;\n      }\n      return name;\n    },\n    set: function set$$1(value) {\n      this[RevealedName] = value;\n    }\n  }]);\n  return TypeTDZ;\n}(Type);\n\nfunction getRevealed(container) {\n  var existing = container[RevealedValue];\n  if (existing) {\n    return existing;\n  } else {\n    var reveal = container.reveal;\n\n    var type = reveal();\n    if (!type) {\n      if (!warnedInstances$2.has(container)) {\n        var name = container[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        } else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances$2.add(container);\n      }\n      return container.context.mixed();\n    } else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\nvar UnionType = function (_Type) {\n  inherits(UnionType, _Type);\n\n  function UnionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, UnionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnionType.__proto__ || Object.getPrototypeOf(UnionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'UnionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(UnionType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return;\n        }\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      if (input instanceof UnionType) {\n        var inputTypes = input.types;\n        var identicalCount = 0;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n\n        if (identicalCount === types.length) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          if (compareTypes(_type, input) >= 0) {\n            return 1;\n          }\n        }\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var types = this.types;\n\n      var normalized = new Array(types.length);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n          normalized[i] = `(${type.toString()})`;\n        } else {\n          normalized[i] = type.toString();\n        }\n      }\n      return normalized.join(' | ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return UnionType;\n}(Type);\n\nfunction registerPrimitiveTypes(t) {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\nfunction registerBuiltinTypeConstructors(t) {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors(validation, path, input) {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      } else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts(input) {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors(validation, path, input, futureType) {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts(input) {\n      var context = this.context;\n\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors(validation, path, input, keyType, valueType) {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          if (!keyType.accepts(key)) {\n            yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n          }\n\n          yield* valueType.errors(validation, path.concat(key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    accepts(input, keyType, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref3 = _step2.value;\n\n          var _ref4 = slicedToArray(_ref3, 2);\n\n          var key = _ref4[0];\n          var value = _ref4[1];\n\n          if (!keyType.accepts(key) || !valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      var keyTypes = [];\n      var valueTypes = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        loop: for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref5 = _step3.value;\n\n          var _ref6 = slicedToArray(_ref5, 2);\n\n          var key = _ref6[0];\n          var value = _ref6[1];\n\n          findKey: {\n            for (var i = 0; i < keyTypes.length; i++) {\n              var type = keyTypes[i];\n              if (type.accepts(key)) {\n                break findKey;\n              }\n            }\n            keyTypes.push(t.typeOf(key));\n          }\n\n          for (var _i = 0; _i < valueTypes.length; _i++) {\n            var _type = valueTypes[_i];\n            if (_type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors(validation, path, input, valueType) {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = input[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var value = _step4.value;\n\n          yield* valueType.errors(validation, path, value);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    },\n    accepts(input, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (!valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters(input) {\n      var valueTypes = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        loop: for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n\n          for (var i = 0; i < valueTypes.length; i++) {\n            var type = valueTypes[i];\n            if (type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      } else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      } else {\n        return [t.union.apply(t, valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\nfunction registerTypePredicates(context) {\n  context.setPredicate('Array', function (input) {\n    return Array.isArray(input);\n  });\n  context.setPredicate('Map', function (input) {\n    return input instanceof Map;\n  });\n  context.setPredicate('Set', function (input) {\n    return input instanceof Set;\n  });\n  context.setPredicate('Promise', function (input) {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null && (typeof input === 'object' || typeof input === 'function') && typeof input.then === 'function';\n    }\n  });\n}\n\nvar TypeInferer = function () {\n  function TypeInferer(context) {\n    classCallCheck(this, TypeInferer);\n\n    this.context = context;\n  }\n\n  createClass(TypeInferer, [{\n    key: 'infer',\n    value: function infer(input) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      var inferred = new Map();\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferInternal',\n    value: function inferInternal(input, inferred) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferPrimitive',\n    value: function inferPrimitive(input) {\n      var context = this.context;\n\n      if (input === null) {\n        return context.null();\n      } else if (input === undefined) {\n        return context.void();\n      } else if (typeof input === 'number') {\n        return context.number();\n      } else if (typeof input === 'boolean') {\n        return context.boolean();\n      } else if (typeof input === 'string') {\n        return context.string();\n      }\n      // Issue 252\n      else if (typeof input === 'symbol') {\n          return context.symbol(input);\n        } else {\n          return undefined;\n        }\n    }\n  }, {\n    key: 'inferComplex',\n    value: function inferComplex(input, inferred) {\n      var context = this.context;\n\n\n      if (typeof input === 'function') {\n        return this.inferFunction(input, inferred);\n      } else if (input !== null && typeof input === 'object') {\n        return this.inferObject(input, inferred);\n      } else {\n        return context.any();\n      }\n    }\n  }, {\n    key: 'inferFunction',\n    value: function inferFunction(input, inferred) {\n      var context = this.context;\n      var length = input.length;\n\n      var body = new Array(length + 1);\n      for (var i = 0; i < length; i++) {\n        body[i] = context.param(String.fromCharCode(97 + i), context.existential());\n      }\n      body[length] = context.return(context.existential());\n      return context.fn.apply(context, body);\n    }\n  }, {\n    key: 'inferObject',\n    value: function inferObject(input, inferred) {\n      var existing = inferred.get(input);\n      if (existing) {\n        return existing;\n      }\n      var context = this.context;\n\n      var type = void 0;\n\n      // Temporarily create a box for this type to catch cyclical references.\n      // Nested references to this object will receive the boxed type.\n      var box = context.box(function () {\n        return type;\n      });\n      inferred.set(input, box);\n\n      if (context.checkPredicate('Array', input)) {\n        type = this.inferArray(input, inferred);\n      } else if (!(input instanceof Object)) {\n        type = this.inferDict(input, inferred);\n      } else if (input.constructor !== Object) {\n        var handler = context.getTypeConstructor(input.constructor);\n        if (handler) {\n          var typeParameters = handler.inferTypeParameters(input);\n          type = handler.apply.apply(handler, toConsumableArray(typeParameters));\n        } else {\n          type = context.ref(input.constructor);\n        }\n      } else {\n        var body = [];\n        for (var key in input) {\n          // eslint-disable-line\n          var value = input[key];\n          body.push(context.property(key, this.inferInternal(value, inferred)));\n        }\n        type = context.object.apply(context, body);\n      }\n\n      // Overwrite the box with the real value.\n      inferred.set(input, type);\n      return type;\n    }\n  }, {\n    key: 'inferDict',\n    value: function inferDict(input, inferred) {\n      var numericIndexers = [];\n      var stringIndexers = [];\n      loop: for (var key in input) {\n        // eslint-disable-line\n        var value = input[key];\n        var types = isNaN(+key) ? stringIndexers : numericIndexers;\n        for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        types.push(this.inferInternal(value, inferred));\n      }\n\n      var context = this.context;\n\n      var body = [];\n      if (numericIndexers.length === 1) {\n        body.push(context.indexer('index', context.number(), numericIndexers[0]));\n      } else if (numericIndexers.length > 1) {\n        body.push(context.indexer('index', context.number(), context.union.apply(context, numericIndexers)));\n      }\n\n      if (stringIndexers.length === 1) {\n        body.push(context.indexer('key', context.string(), stringIndexers[0]));\n      } else if (stringIndexers.length > 1) {\n        body.push(context.indexer('key', context.string(), context.union.apply(context, stringIndexers)));\n      }\n\n      return context.object.apply(context, body);\n    }\n  }, {\n    key: 'inferArray',\n    value: function inferArray(input, inferred) {\n      var context = this.context;\n\n      var types = [];\n      var values = [];\n      var length = input.length;\n\n      loop: for (var i = 0; i < length; i++) {\n        var item = input[i];\n        var inferredType = this.inferInternal(item, inferred);\n        for (var j = 0; j < types.length; j++) {\n          var type = types[j];\n          if (type.accepts(item) && inferredType.accepts(values[j])) {\n            continue loop;\n          }\n        }\n        types.push(inferredType);\n        values.push(item);\n      }\n      if (types.length === 0) {\n        return context.array(context.any());\n      } else if (types.length === 1) {\n        return context.array(types[0]);\n      } else {\n        return context.array(context.union.apply(context, types));\n      }\n    }\n  }]);\n  return TypeInferer;\n}();\n\nfunction makeReactPropTypes(objectType) {\n  var output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n\n  var _loop = function _loop(property) {\n    output[property.key] = function (props, propName, componentName) {\n      return makeError(property, props);\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = objectType.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return output;\n}\n\nvar delimiter$1 = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeWarningMessage(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return `Warning: ${collected.join(delimiter$1)}`;\n}\n\nfunction makeUnion(context, types) {\n  var length = types.length;\n  var merged = [];\n  for (var i = 0; i < length; i++) {\n    var type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return type;\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    } else {\n      merged.push(type);\n    }\n  }\n  var union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes(aTypes, bTypes) {\n  loop: for (var i = 0; i < bTypes.length; i++) {\n    var bType = bTypes[i];\n    for (var j = 0; j < aTypes.length; j++) {\n      var aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\nfunction makePropertyDescriptor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert);\n  } else {\n    return propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert);\n  }\n}\n\nfunction makePropertyName(name) {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName(input) {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  } else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  } else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType(receiver, typeSource) {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  } else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  var safeName = makePropertyName(propertyName);\n  var className = getClassName(input);\n  var initializer = descriptor.initializer,\n      writable = descriptor.writable,\n      config = objectWithoutProperties(descriptor, ['initializer', 'writable']); // eslint-disable-line no-unused-vars\n\n  var propertyPath = [className, propertyName];\n\n  return _extends({}, config, {\n    type: 'accessor',\n    get() {\n      if (safeName in this) {\n        return this[safeName];\n      } else if (initializer) {\n        var type = resolveType(this, typeSource);\n        var _value = initializer.call(this);\n        var context = type.context;\n        context.check(type, _value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: _value\n        });\n        return _value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set(value) {\n      var type = resolveType(this, typeSource);\n      var context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      } else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  });\n}\n\nfunction augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert) {\n\n  var className = getClassName(input);\n  var propertyPath = [className, propertyName];\n\n  var originalSetter = descriptor.set;\n\n  descriptor.set = function set$$1(value) {\n    var type = resolveType(this, typeSource);\n    var context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    } else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n}\n\n// eslint-disable-line no-redeclare\n\nfunction annotateValue(input, type) {\n  // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  } else {\n    var _type = input;\n    return function (input) {\n      input[TypeSymbol] = _type;\n      return input;\n    };\n  }\n}\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nvar $DiffType = function (_Type) {\n  inherits($DiffType, _Type);\n\n  function $DiffType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $DiffType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $DiffType.__proto__ || Object.getPrototypeOf($DiffType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$DiffType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($DiffType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        yield* property.errors(validation, path.concat(property.key), input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        if (!property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var aType = this.aType,\n          bType = this.bType;\n\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      var args = [];\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        args.push(property);\n      }\n      return (_context = this.context).object.apply(_context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        aType: this.aType,\n        bType: this.bType\n      };\n    }\n  }]);\n  return $DiffType;\n}(Type);\n\n// Any subtype of T\n\nvar $FlowFixMeType = function (_Type) {\n  inherits($FlowFixMeType, _Type);\n\n  function $FlowFixMeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $FlowFixMeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $FlowFixMeType.__proto__ || Object.getPrototypeOf($FlowFixMeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$FlowFixMeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($FlowFixMeType, [{\n    key: 'errors',\n    value: function* errors(validation, input) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$FlowFixMe';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return $FlowFixMeType;\n}(Type);\n\n// The set of keys of T.\n\nvar $KeysType = function (_Type) {\n  inherits($KeysType, _Type);\n\n  function $KeysType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $KeysType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $KeysType.__proto__ || Object.getPrototypeOf($KeysType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$KeysType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($KeysType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return;\n        }\n      }\n      var keys = new Array(length);\n      for (var _i = 0; _i < length; _i++) {\n        keys[_i] = properties[_i].key;\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var keys = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        keys[i] = context.literal(property.key);\n      }\n      return (_context = this.context).union.apply(_context, keys);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Keys<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $KeysType;\n}(Type);\n\n// Map over the keys and values in an object.\n\nvar $ObjMapiType = function (_Type) {\n  inherits($ObjMapiType, _Type);\n\n  function $ObjMapiType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapiType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapiType.__proto__ || Object.getPrototypeOf($ObjMapiType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapiType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapiType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = target.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          yield* returnType.errors(validation, path.concat(prop.key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key), prop.value)));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapiType;\n}(Type);\n\n// Map over the keys in an object.\n\nvar $ObjMapType = function (_Type) {\n  inherits($ObjMapType, _Type);\n\n  function $ObjMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapType.__proto__ || Object.getPrototypeOf($ObjMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = target.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          yield* returnType.errors(validation, path.concat(prop.key), value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key))));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapType;\n}(Type);\n\n// The type of the named object property\n\nvar $PropertyType = function (_Type) {\n  inherits($PropertyType, _Type);\n\n  function $PropertyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $PropertyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $PropertyType.__proto__ || Object.getPrototypeOf($PropertyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$PropertyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($PropertyType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.unwrap().errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.unwrap().accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          property = this.property;\n\n      var unwrapped = object.unwrap();\n      invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n      return unwrapped.getProperty(property).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        property: this.property\n      };\n    }\n  }]);\n  return $PropertyType;\n}(Type);\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nvar $ShapeType = function (_Type) {\n  inherits($ShapeType, _Type);\n\n  function $ShapeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ShapeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ShapeType.__proto__ || Object.getPrototypeOf($ShapeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ShapeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ShapeType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type;\n\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property) {\n          continue;\n        }\n        yield* property.errors(validation, path, input);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (input === null || typeof input !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property || !property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context;\n\n      var type = this.type;\n\n      type = type.unwrap();\n      var context = this.context;\n      invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n      var properties = type.properties;\n      var args = new Array(properties.length);\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        args[i] = context.property(property.key, property.value, true);\n      }\n      return (_context = this.context).object.apply(_context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Shape<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ShapeType;\n}(Type);\n\n// Any subtype of T\n\nvar $SubType = function (_Type) {\n  inherits($SubType, _Type);\n\n  function $SubType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SubType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SubType.__proto__ || Object.getPrototypeOf($SubType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SubType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SubType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(input, path);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Subtype<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SubType;\n}(Type);\n\n// Any, but at least T.\n\nvar $SuperType = function (_Type) {\n  inherits($SuperType, _Type);\n\n  function $SuperType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SuperType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SuperType.__proto__ || Object.getPrototypeOf($SuperType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SuperType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SuperType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Supertype<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SuperType;\n}(Type);\n\n// Map over the values in a tuple.\n\nvar $TupleMapType = function (_Type) {\n  inherits($TupleMapType, _Type);\n\n  function $TupleMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $TupleMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $TupleMapType.__proto__ || Object.getPrototypeOf($TupleMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$TupleMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($TupleMapType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n        return;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        var expected = applied.invoke(type);\n        var value = input[i];\n        yield* expected.errors(validation, path.concat(i), value);\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        if (!applied.invoke(type).accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n      var args = [];\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        args.push(applied.invoke(type).unwrap().unwrap());\n      }\n\n      return context.tuple.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        tuple: this.tuple,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $TupleMapType;\n}(Type);\n\n// The set of keys of T.\n\nvar $ValuesType = function (_Type) {\n  inherits($ValuesType, _Type);\n\n  function $ValuesType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ValuesType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ValuesType.__proto__ || Object.getPrototypeOf($ValuesType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ValuesType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ValuesType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.value.accepts(input)) {\n          return;\n        }\n      }\n      var values = new Array(length);\n      for (var _i = 0; _i < length; _i++) {\n        values[_i] = properties[_i].value.toString();\n      }\n      yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.value.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var values = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        values[i] = property.value;\n      }\n      return context.union.apply(context, values);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `$Values<${this.type.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ValuesType;\n}(Type);\n\nfunction checkGenericType(context, expected, input) {\n  var impl = expected.impl;\n\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  } else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  var annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  } else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType(context, expected, input) {\n  var annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    var result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\nvar ClassType = function (_Type) {\n  inherits(ClassType, _Type);\n\n  function ClassType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassType.__proto__ || Object.getPrototypeOf(ClassType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassType, [{\n    key: 'errors',\n    value: function* errors(validation, path, input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n        return;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      var isValid = expectedType instanceof GenericType ? checkGenericType(context, expectedType, input) : checkType(context, expectedType, input);\n      if (!isValid) {\n        yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      }\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      if (expectedType instanceof GenericType) {\n        return checkGenericType(context, expectedType, input);\n      } else {\n        return checkType(context, expectedType, input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var instanceType = this.instanceType;\n\n      if (input instanceof ClassType) {\n        return compareTypes(instanceType, input.instanceType);\n      }\n      return -1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return `Class<${this.instanceType.toString()}>`;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        instanceType: this.instanceType\n      };\n    }\n  }]);\n  return ClassType;\n}(Type);\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nvar warnedInvalidReferences = new WeakSet();\n\nvar TypeContext = function () {\n  function TypeContext() {\n    classCallCheck(this, TypeContext);\n    this.mode = 'assert';\n    this[NameRegistrySymbol] = {};\n    this[TypePredicateRegistrySymbol] = {};\n    this[TypeConstructorRegistrySymbol] = new Map();\n    this[InferrerSymbol] = new TypeInferer(this);\n    this[ModuleRegistrySymbol] = {};\n  }\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeContext, [{\n    key: 'makeJSONError',\n    value: function makeJSONError$$1(validation) {\n      return makeJSONError(validation);\n    }\n  }, {\n    key: 'makeTypeError',\n    value: function makeTypeError$$1(validation) {\n      return makeTypeError(validation);\n    }\n  }, {\n    key: 'createContext',\n    value: function createContext() {\n      var context = new TypeContext();\n      // Issue 252\n      context[ParentSymbol] = this;\n      return context;\n    }\n  }, {\n    key: 'typeOf',\n    value: function typeOf(input) {\n\n      var annotation = this.getAnnotation(input);\n      if (annotation) {\n        if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n          return this.Class(annotation);\n        }\n        return annotation;\n      }\n      // Issue 252\n      var inferrer = this[InferrerSymbol];\n      inferrer;\n\n      return inferrer.infer(input);\n    }\n  }, {\n    key: 'compareTypes',\n    value: function compareTypes$$1(a, b) {\n      return compareTypes(a, b);\n    }\n  }, {\n    key: 'get',\n    value: function get$$1(name) {\n      // Issue 252\n      var item = this[NameRegistrySymbol][name];\n\n      for (var _len = arguments.length, propertyNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        propertyNames[_key - 1] = arguments[_key];\n      }\n\n      if (item != null) {\n        var current = typeof item === 'function' ? new item(this) : item;\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n          if (typeof current.getProperty !== 'function') {\n            return;\n          }\n          current = current.getProperty(propertyName);\n          if (!current) {\n            return;\n          }\n          current = current.unwrap();\n        }\n        return current;\n      }\n      // Issue 252\n      var parent = this[ParentSymbol];\n      if (parent) {\n        var fromParent = parent.get.apply(parent, [name].concat(toConsumableArray(propertyNames)));\n        if (fromParent) {\n          return fromParent;\n        }\n      }\n\n      // if we got this far, see if we have a global type with this name.\n      if (typeof global[name] === 'function') {\n        var target = new GenericType(this);\n        target.name = name;\n        target.impl = global[name];\n        // Issue 252\n        this[NameRegistrySymbol][name] = target;\n        return target;\n      }\n    }\n\n    /**\n     * Get the predicate for a given type name.\n     * e.g. `t.getPredicate('Array')`.\n     */\n\n  }, {\n    key: 'getPredicate',\n    value: function getPredicate(name) {\n      var item = this[TypePredicateRegistrySymbol][name];\n      if (item) {\n        return item;\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.getPredicate(name);\n      }\n    }\n\n    /**\n     * Set the predicate for a given type name.\n     * This can be used to customise the behaviour of things like Array\n     * detection or allowing Thenables in place of the global Promise.\n     */\n\n  }, {\n    key: 'setPredicate',\n    value: function setPredicate(name, predicate) {\n      this[TypePredicateRegistrySymbol][name] = predicate;\n    }\n\n    /**\n     * Check the given value against the named predicate.\n     * Returns false if no such predicate exists.\n     * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n     */\n\n  }, {\n    key: 'checkPredicate',\n    value: function checkPredicate(name, input) {\n      var predicate = this.getPredicate(name);\n      if (predicate) {\n        return predicate(input);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Returns a decorator for a function or object with the given type.\n     */\n\n  }, {\n    key: 'decorate',\n    value: function decorate(type, shouldAssert) {\n      var _this2 = this;\n\n      if (shouldAssert == null) {\n        shouldAssert = this.mode === 'assert';\n      }\n      return function (input, propertyName, descriptor) {\n        if (descriptor && typeof propertyName === 'string') {\n          return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n        } else {\n          invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n          return _this2.annotate(input, type);\n        }\n      };\n    }\n\n    /**\n     * Annotates an object or function with the given type.\n     * If a type is specified as the sole argument, returns a\n     * function which can decorate classes or functions with the given type.\n     */\n\n  }, {\n    key: 'annotate',\n    value: function annotate(input, type) {\n      if (type === undefined) {\n        return annotateValue(input);\n      } else {\n        return annotateValue(input, type);\n      }\n    }\n  }, {\n    key: 'getAnnotation',\n    value: function getAnnotation(input) {\n      if (input !== null && typeof input === 'object' || typeof input === 'function') {\n        // Issue 252\n        return input[TypeSymbol];\n      }\n    }\n  }, {\n    key: 'hasAnnotation',\n    value: function hasAnnotation(input) {\n      if (input == null) {\n        return false;\n      } else {\n        return input[TypeSymbol] ? true : false;\n      }\n    }\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(input, type) {\n      input[TypeSymbol] = type;\n      return input;\n    }\n  }, {\n    key: 'type',\n    value: function type(name, _type) {\n      if (typeof _type === 'function') {\n        var target = new ParameterizedTypeAlias(this);\n        target.name = name;\n        target.typeCreator = _type;\n        return target;\n      } else {\n        var _target = new TypeAlias(this);\n        _target.name = name;\n        _target.type = _type;\n        return _target;\n      }\n    }\n  }, {\n    key: 'declare',\n    value: function declare(name, type) {\n\n      if (name instanceof Declaration) {\n        type = name;\n        name = type.name;\n      } else if (name instanceof TypeAlias) {\n        type = name;\n        name = type.name;\n      }\n      if (typeof type === 'function') {\n        type = this.type(name, type);\n      }\n      if (type instanceof ModuleDeclaration) {\n        var moduleRegistry = this[ModuleRegistrySymbol];\n        moduleRegistry[name] = type;\n        return type;\n      } else {\n        invariant(typeof name === 'string', 'Name must be a string');\n        invariant(type instanceof Type, 'Type must be supplied to declaration');\n        var nameRegistry = this[NameRegistrySymbol];\n\n        if (type instanceof Declaration) {\n          nameRegistry[name] = type;\n          return type;\n        } else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n          var target = new TypeDeclaration(this);\n          target.name = name;\n          target.typeAlias = type;\n          nameRegistry[name] = target;\n          return target;\n        } else {\n          var _target2 = this.var(name, type);\n          nameRegistry[name] = _target2;\n          return _target2;\n        }\n      }\n    }\n  }, {\n    key: 'declarations',\n    value: function* declarations() {\n      var nameRegistry = this[NameRegistrySymbol];\n      for (var key in nameRegistry) {\n        // eslint-disable-line guard-for-in\n        yield [key, nameRegistry[key]];\n      }\n    }\n  }, {\n    key: 'modules',\n    value: function* modules() {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      for (var key in moduleRegistry) {\n        // eslint-disable-line guard-for-in\n        yield moduleRegistry[key];\n      }\n    }\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      if (moduleRegistry[moduleName]) {\n        return moduleRegistry[moduleName];\n      }\n\n      var _moduleName$split = moduleName.split('/'),\n          _moduleName$split2 = slicedToArray(_moduleName$split, 1),\n          head = _moduleName$split2[0];\n\n      var module = moduleRegistry[head];\n      if (module) {\n        return module.import(moduleName);\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.import(moduleName);\n      }\n    }\n  }, {\n    key: 'declareTypeConstructor',\n    value: function declareTypeConstructor(_ref) {\n      var name = _ref.name,\n          impl = _ref.impl,\n          typeName = _ref.typeName,\n          errors = _ref.errors,\n          accepts = _ref.accepts,\n          inferTypeParameters = _ref.inferTypeParameters,\n          compareWith = _ref.compareWith;\n\n      var nameRegistry = this[NameRegistrySymbol];\n\n      if (nameRegistry[name]) {\n        this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n      }\n\n      var target = new TypeConstructor(this);\n      target.name = name;\n      target.typeName = typeName;\n      target.impl = impl;\n      target.errors = errors;\n      target.accepts = accepts;\n      target.inferTypeParameters = inferTypeParameters;\n      if (typeof compareWith === 'function') {\n        target.compareWith = compareWith;\n      }\n\n      nameRegistry[name] = target;\n\n      if (typeof impl === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        if (handlerRegistry.has(impl)) {\n          this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n        }\n        handlerRegistry.set(impl, target);\n      }\n      return target;\n    }\n  }, {\n    key: 'getTypeConstructor',\n    value: function getTypeConstructor(impl) {\n      // Issue 252\n      var handlerRegistry = this[TypeConstructorRegistrySymbol];\n      handlerRegistry;\n\n      return handlerRegistry.get(impl);\n    }\n  }, {\n    key: 'literal',\n    value: function literal(input) {\n      if (input === undefined) {\n        return this.void();\n      } else if (input === null) {\n        return this.null();\n      } else if (typeof input === 'boolean') {\n        return this.boolean(input);\n      } else if (typeof input === 'number') {\n        return this.number(input);\n      } else if (typeof input === 'string') {\n        return this.string(input);\n      }\n      // Issue 252\n      else if (typeof input === 'symbol') {\n          return this.symbol(input);\n        } else {\n          return this.typeOf(input);\n        }\n    }\n  }, {\n    key: 'null',\n    value: function _null() {\n      return primitiveTypes.null;\n    }\n  }, {\n    key: 'nullable',\n    value: function nullable(type) {\n      var target = new NullableType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'existential',\n    value: function existential() {\n      return primitiveTypes.existential;\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return primitiveTypes.empty;\n    }\n  }, {\n    key: 'any',\n    value: function any() {\n      return primitiveTypes.any;\n    }\n  }, {\n    key: 'mixed',\n    value: function mixed() {\n      return primitiveTypes.mixed;\n    }\n  }, {\n    key: 'void',\n    value: function _void() {\n      return primitiveTypes.void;\n    }\n  }, {\n    key: 'this',\n    value: function _this(input) {\n      var target = new ThisType(this);\n      if (input !== undefined) {\n        target.recorded = input;\n      }\n      return target;\n    }\n  }, {\n    key: 'number',\n    value: function number(input) {\n      if (input !== undefined) {\n        var target = new NumericLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.number;\n      }\n    }\n  }, {\n    key: 'boolean',\n    value: function boolean(input) {\n      if (input !== undefined) {\n        var target = new BooleanLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.boolean;\n      }\n    }\n  }, {\n    key: 'string',\n    value: function string(input) {\n      if (input !== undefined) {\n        var target = new StringLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.string;\n      }\n    }\n  }, {\n    key: 'symbol',\n    value: function symbol(input) {\n      if (input !== undefined) {\n        var target = new SymbolLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.symbol;\n      }\n    }\n  }, {\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      return target;\n    }\n  }, {\n    key: 'flowInto',\n    value: function flowInto(typeParameter) {\n      return flowIntoTypeParameter(typeParameter);\n    }\n\n    /**\n     * Bind the type parameters for the parent class of the given instance.\n     */\n\n  }, {\n    key: 'bindTypeParameters',\n    value: function bindTypeParameters(subject) {\n      var instancePrototype = Object.getPrototypeOf(subject);\n      // Issue\n      var parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n      // Issue\n      var parentClass = parentPrototype && parentPrototype.constructor;\n\n      if (!parentClass) {\n        this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n        return subject;\n      }\n      // Issue 252\n      var typeParametersPointer = parentClass[TypeParametersSymbol];\n\n      if (typeParametersPointer) {\n        var typeParameters = subject[typeParametersPointer];\n        var keys = Object.keys(typeParameters);\n\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var length = Math.min(keys.length, typeInstances.length);\n        for (var i = 0; i < length; i++) {\n          var typeParam = typeParameters[keys[i]];\n          typeParam.bound = typeInstances[i];\n        }\n      }\n      return subject;\n    }\n  }, {\n    key: 'module',\n    value: function module(name, body) {\n      var target = new ModuleDeclaration(this);\n      target.name = name;\n      var innerContext = this.createContext();\n      // Issue 252\n      innerContext[ParentSymbol] = this;\n      // Issue 252\n      innerContext[CurrentModuleSymbol] = target;\n\n      target.innerContext = innerContext;\n      body(innerContext);\n      return target;\n    }\n  }, {\n    key: 'moduleExports',\n    value: function moduleExports(type) {\n      var currentModule = this[CurrentModuleSymbol];\n      if (!currentModule) {\n        throw new Error('Cannot declare module.exports outside of a module.');\n      }\n      var target = new ModuleExports(this);\n      target.type = type;\n      currentModule.moduleExports = target;\n      return target;\n    }\n  }, {\n    key: 'var',\n    value: function _var(name, type) {\n      var target = new VarDeclaration(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'class',\n    value: function _class(name, head) {\n      if (typeof head === 'function') {\n        var _target3 = new ParameterizedClassDeclaration(this);\n        _target3.name = name;\n        _target3.bodyCreator = head;\n        return _target3;\n      }\n      var target = new ClassDeclaration(this);\n      target.name = name;\n\n      for (var _len3 = arguments.length, tail = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        tail[_key3 - 2] = arguments[_key3];\n      }\n\n      if (head != null) {\n        tail.unshift(head);\n      }\n      var length = tail.length;\n\n      var properties = [];\n      var body = void 0;\n\n      for (var i = 0; i < length; i++) {\n        var item = tail[i];\n        if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n          properties.push(item);\n        } else if (item instanceof ObjectType) {\n          invariant(!body, 'Class body must only be declared once.');\n          body = item;\n        } else if (item instanceof ExtendsDeclaration) {\n          invariant(!target.superClass, 'Classes can only have one super class.');\n          target.superClass = item;\n        } else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n          for (var propertyName in item) {\n            // eslint-disable-line\n            properties.push(this.property(propertyName, item[propertyName]));\n          }\n        } else {\n          throw new Error('ClassDeclaration cannot contain the given type directly.');\n        }\n      }\n      if (!body) {\n        body = new ObjectType(this);\n      }\n      if (properties.length) {\n        var _body$properties;\n\n        (_body$properties = body.properties).push.apply(_body$properties, properties);\n      }\n      target.body = body;\n      return target;\n    }\n  }, {\n    key: 'extends',\n    value: function _extends(subject) {\n      var target = new ExtendsDeclaration(this);\n\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      target.type = this.ref.apply(this, [subject].concat(toConsumableArray(typeInstances)));\n      return target;\n    }\n  }, {\n    key: 'fn',\n    value: function fn(head) {\n      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        tail[_key5 - 1] = arguments[_key5];\n      }\n\n      return this.function.apply(this, [head].concat(tail));\n    }\n  }, {\n    key: 'function',\n    value: function _function(head) {\n      if (typeof head === 'function') {\n        var _target4 = new ParameterizedFunctionType(this);\n        _target4.bodyCreator = head;\n        return _target4;\n      }\n      var target = new FunctionType(this);\n      if (head != null) {\n        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          tail[_key6 - 1] = arguments[_key6];\n        }\n\n        tail.unshift(head);\n        var length = tail.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = tail[i];\n          if (item instanceof FunctionTypeParam) {\n            target.params.push(item);\n          } else if (item instanceof FunctionTypeRestParam) {\n            target.rest = item;\n          } else if (item instanceof FunctionTypeReturn) {\n            target.returnType = item;\n          } else {\n            throw new Error('FunctionType cannot contain the given type directly.');\n          }\n        }\n      }\n      if (!target.returnType) {\n        target.returnType = this.any();\n      }\n      return target;\n    }\n  }, {\n    key: 'param',\n    value: function param(name, type) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new FunctionTypeParam(this);\n      target.name = name;\n      target.type = type;\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'rest',\n    value: function rest(name, type) {\n      var target = new FunctionTypeRestParam(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'return',\n    value: function _return(type) {\n      var target = new FunctionTypeReturn(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'generator',\n    value: function generator(yieldType, returnType, nextType) {\n      var target = new GeneratorType(this);\n      target.yieldType = yieldType;\n      target.returnType = returnType || this.any();\n      target.nextType = nextType || this.any();\n      return target;\n    }\n  }, {\n    key: 'object',\n    value: function object(head) {\n      var target = new ObjectType(this);\n      if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n        for (var propertyName in head) {\n          // eslint-disable-line\n          target.properties.push(this.property(propertyName, head[propertyName]));\n        }\n      } else {\n        var body = void 0;\n\n        for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          tail[_key7 - 1] = arguments[_key7];\n        }\n\n        if (head) {\n          body = [head].concat(toConsumableArray(tail));\n        } else {\n          body = tail;\n        }\n        var _body = body,\n            length = _body.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = body[i];\n          if (item instanceof ObjectTypeProperty) {\n            target.properties.push(item);\n          } else if (item instanceof ObjectTypeIndexer) {\n            target.indexers.push(item);\n          } else if (item instanceof ObjectTypeCallProperty) {\n            target.callProperties.push(item);\n          } else {\n            throw new Error('ObjectType cannot contain the given type directly.');\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'exactObject',\n    value: function exactObject(head) {\n      for (var _len8 = arguments.length, tail = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        tail[_key8 - 1] = arguments[_key8];\n      }\n\n      var object = this.object.apply(this, [head].concat(toConsumableArray(tail)));\n      object.exact = true;\n      return object;\n    }\n  }, {\n    key: 'callProperty',\n    value: function callProperty(value) {\n      var target = new ObjectTypeCallProperty(this);\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'property',\n    value: function property(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new ObjectTypeProperty(this);\n      target.key = key;\n      if (value instanceof Type) {\n        target.value = value;\n      } else {\n        target.value = this.object(value);\n      }\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'indexer',\n    value: function indexer(id, key, value) {\n      var target = new ObjectTypeIndexer(this);\n      target.id = id;\n      target.key = key;\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'method',\n    value: function method(name, head) {\n      var target = new ObjectTypeProperty(this);\n      target.key = name;\n\n      for (var _len9 = arguments.length, tail = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        tail[_key9 - 2] = arguments[_key9];\n      }\n\n      target.value = this.function.apply(this, [head].concat(tail));\n      return target;\n    }\n  }, {\n    key: 'staticCallProperty',\n    value: function staticCallProperty(value) {\n      var prop = this.callProperty(value);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticProperty',\n    value: function staticProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var prop = this.property(key, value, optional);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticMethod',\n    value: function staticMethod(name, head) {\n      for (var _len10 = arguments.length, tail = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        tail[_key10 - 2] = arguments[_key10];\n      }\n\n      var prop = this.method.apply(this, [name, head].concat(tail));\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'spread',\n    value: function spread() {\n      var target = new ObjectType(this);\n\n      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        types[_key11] = arguments[_key11];\n      }\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        if (Array.isArray(type.callProperties)) {\n          var _target$callPropertie;\n\n          (_target$callPropertie = target.callProperties).push.apply(_target$callPropertie, toConsumableArray(type.callProperties));\n        }\n        if (Array.isArray(type.indexers)) {\n          var _target$indexers;\n\n          (_target$indexers = target.indexers).push.apply(_target$indexers, toConsumableArray(type.indexers));\n        }\n        if (Array.isArray(type.properties)) {\n          for (var j = 0; j < type.properties.length; j++) {\n            var prop = type.properties[j];\n            invariant(prop instanceof ObjectTypeProperty);\n            target.setProperty(prop.key, prop.value, prop.optional);\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'tuple',\n    value: function tuple() {\n      var target = new TupleType(this);\n\n      for (var _len12 = arguments.length, types = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        types[_key12] = arguments[_key12];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'array',\n    value: function array(elementType) {\n      var target = new ArrayType(this);\n      target.elementType = elementType || this.any();\n      return target;\n    }\n  }, {\n    key: 'union',\n    value: function union() {\n      for (var _len13 = arguments.length, types = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        types[_key13] = arguments[_key13];\n      }\n\n      return makeUnion(this, types);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect() {\n      var target = new IntersectionType(this);\n\n      for (var _len14 = arguments.length, types = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        types[_key14] = arguments[_key14];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'intersection',\n    value: function intersection() {\n      return this.intersect.apply(this, arguments);\n    }\n  }, {\n    key: 'box',\n    value: function box(reveal) {\n      var box = new TypeBox(this);\n      box.reveal = reveal;\n      return box;\n    }\n  }, {\n    key: 'tdz',\n    value: function tdz(reveal, name) {\n      var tdz = new TypeTDZ(this);\n      tdz.reveal = reveal;\n      tdz.name = name;\n      return tdz;\n    }\n  }, {\n    key: 'ref',\n    value: function ref(subject) {\n      var target = void 0;\n      if (typeof subject === 'string') {\n        // try and eagerly resolve the reference\n        target = this.get(subject);\n        if (!target) {\n          // defer dereferencing for now\n          target = new TypeReference(this);\n          target.name = subject;\n        }\n      } else if (typeof subject === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        // see if we have a dedicated TypeConstructor for this.\n        target = handlerRegistry.get(subject);\n\n        if (!target) {\n          // just use a generic type handler.\n          target = new GenericType(this);\n          target.impl = subject;\n          target.name = subject.name;\n        }\n      } else if (subject instanceof Type) {\n        target = subject;\n      } else {\n        if (subject == null || typeof subject !== 'object') {\n          this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n        } else if (!warnedInvalidReferences.has(subject)) {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n          warnedInvalidReferences.add(subject);\n        }\n        return this.any();\n      }\n\n      for (var _len15 = arguments.length, typeInstances = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n        typeInstances[_key15 - 1] = arguments[_key15];\n      }\n\n      if (typeInstances.length) {\n        var _target5;\n\n        invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n        return (_target5 = target).apply.apply(_target5, toConsumableArray(typeInstances));\n      } else {\n        return target;\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = new Validation(this, input);\n      if (path) {\n        var _validation$path;\n\n        (_validation$path = validation.path).push.apply(_validation$path, toConsumableArray(path));\n      } else if (typeof type.name === 'string') {\n        validation.path.push(type.name);\n      }\n      validation.prefix = prefix;\n      validation.errors = Array.from(type.errors(validation, [], input));\n      return validation;\n    }\n  }, {\n    key: 'check',\n    value: function check(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      if (this.mode === 'assert') {\n        return this.assert(type, input, prefix, path);\n      } else {\n        return this.warn(type, input, prefix, path);\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var error = this.makeTypeError(validation);\n      if (error) {\n        throw error;\n      }\n      return input;\n    }\n  }, {\n    key: 'warn',\n    value: function warn(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var message = makeWarningMessage(validation);\n      if (typeof message === 'string') {\n        this.emitWarningMessage(message);\n      }\n      return input;\n    }\n\n    /**\n     * Emits a warning message, using `console.warn()` by default.\n     */\n\n  }, {\n    key: 'emitWarningMessage',\n    value: function emitWarningMessage(message) {\n      console.warn('flow-runtime:', message);\n    }\n  }, {\n    key: 'propTypes',\n    value: function propTypes(type) {\n      return makeReactPropTypes(type.unwrap());\n    }\n  }, {\n    key: 'match',\n    value: function match() {\n      for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      var clauses = args.pop();\n      if (!Array.isArray(clauses)) {\n        throw new Error('Invalid pattern, last argument must be an array.');\n      }\n      clauses;\n      var pattern = this.pattern.apply(this, toConsumableArray(clauses));\n      return pattern.apply(undefined, args);\n    }\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      for (var _len17 = arguments.length, clauses = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        clauses[_key17] = arguments[_key17];\n      }\n\n      var length = clauses.length;\n\n      var tests = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var clause = clauses[i];\n        var annotation = this.getAnnotation(clause);\n        if (!annotation) {\n          if (i !== length - 1) {\n            throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n          }\n          tests[i] = true;\n        } else {\n          invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n          tests[i] = annotation;\n        }\n      }\n      return function () {\n        for (var _i = 0; _i < tests.length; _i++) {\n          var test = tests[_i];\n          var _clause = clauses[_i];\n          if (test === true) {\n            return _clause.apply(undefined, arguments);\n          } else if (test.acceptsParams.apply(test, arguments)) {\n            return _clause.apply(undefined, arguments);\n          }\n        }\n        var error = new TypeError('Value did not match any of the candidates.');\n        error.name = 'RuntimeTypeError';\n        throw error;\n      };\n    }\n  }, {\n    key: 'wrapIterator',\n    value: function wrapIterator(type) {\n      var t = this;\n      return function* wrappedIterator(input) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            yield t.check(type, item);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: 'refinement',\n    value: function refinement(type) {\n      var target = new RefinementType(this);\n      target.type = type;\n\n      for (var _len18 = arguments.length, constraints = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n        constraints[_key18 - 1] = arguments[_key18];\n      }\n\n      target.addConstraint.apply(target, toConsumableArray(constraints));\n      return target;\n    }\n  }, {\n    key: '$exact',\n    value: function $exact(type) {\n      var target = new ObjectType(this);\n      type = type.unwrap();\n      if (Array.isArray(type.callProperties)) {\n        var _target$callPropertie2;\n\n        (_target$callPropertie2 = target.callProperties).push.apply(_target$callPropertie2, toConsumableArray(type.callProperties));\n      }\n      if (Array.isArray(type.indexers)) {\n        var _target$indexers2;\n\n        (_target$indexers2 = target.indexers).push.apply(_target$indexers2, toConsumableArray(type.indexers));\n      }\n      if (Array.isArray(type.properties)) {\n        var _target$properties;\n\n        (_target$properties = target.properties).push.apply(_target$properties, toConsumableArray(type.properties));\n      }\n      target.exact = true;\n      return target;\n    }\n  }, {\n    key: '$diff',\n    value: function $diff(aType, bType) {\n      var target = new $DiffType(this);\n      target.aType = aType;\n      target.bType = bType;\n      return target;\n    }\n  }, {\n    key: '$flowFixMe',\n    value: function $flowFixMe() {\n      return new $FlowFixMeType(this);\n    }\n  }, {\n    key: '$keys',\n    value: function $keys(type) {\n      var target = new $KeysType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$objMap',\n    value: function $objMap(object, mapper) {\n      var target = new $ObjMapType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$objMapi',\n    value: function $objMapi(object, mapper) {\n      var target = new $ObjMapiType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$propertyType',\n    value: function $propertyType(object, property) {\n      var target = new $PropertyType(this);\n      target.object = object;\n      if (property instanceof Type) {\n        var unwrapped = property.unwrap();\n        target.property = unwrapped.value;\n      } else {\n        target.property = property;\n      }\n      return target;\n    }\n  }, {\n    key: '$shape',\n    value: function $shape(type) {\n      var target = new $ShapeType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$subtype',\n    value: function $subtype(type) {\n      var target = new $SubType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$supertype',\n    value: function $supertype(type) {\n      var target = new $SuperType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$tupleMap',\n    value: function $tupleMap(tuple, mapper) {\n      var target = new $TupleMapType(this);\n      target.tuple = tuple;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$values',\n    value: function $values(type) {\n      var target = new $ValuesType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'Class',\n    value: function Class(instanceType) {\n      var target = new ClassType(this);\n      target.instanceType = instanceType;\n      return target;\n    }\n  }, {\n    key: 'TypeParametersSymbol',\n\n\n    // Issue 252\n    get: function get$$1() {\n      return TypeParametersSymbol;\n    }\n  }]);\n  return TypeContext;\n}();\n\nvar globalContext$1 = void 0;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext$1 = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n} else {\n  globalContext$1 = new TypeContext();\n  registerPrimitiveTypes(globalContext$1);\n  registerBuiltinTypeConstructors(globalContext$1);\n  registerTypePredicates(globalContext$1);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext$1;\n  }\n}\n\nvar globalContext$2 = globalContext$1;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (globalContext$2);\n//# sourceMappingURL=flow-runtime.es2015.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdy1ydW50aW1lL2Rpc3QvZmxvdy1ydW50aW1lLmVzMjAxNS5qcz81MmI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWNEO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCOztBQUU3RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGdFQUFnRTtBQUNySTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGdFQUFnRTtBQUNySTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEZBQTBGLGdFQUFnRTtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0ZBQXNGLGFBQWE7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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGLGVBQWU7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGLGVBQWU7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSztBQUNyRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsZ0VBQWdFO0FBQzdIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELG1FQUFtRTtBQUNsSTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0IsSUFBSSxzQkFBc0I7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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QUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUdBQW1HLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1R0FBdUcsZUFBZTtBQUN0SDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFKzJCO0FBQy8yQiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgZXhwb3J0cyBhIGRpY3Rpb25hcnkgb2YgZ2xvYmFsIHByaW1pdGl2ZSB0eXBlcyB0aGF0IGFyZSBzaGFyZWQgYnkgYWxsIGNvbnRleHRzLlxuICogSXQgaXMgcG9wdWxhdGVkIGluIFtyZWdpc3RlclByaW1pdGl2ZVR5cGVzKCldKC4vcmVnaXN0ZXJQcmltaXRpdmVUeXBlcy5qcykuXG4gKi9cblxudmFyIHByaW1pdGl2ZVR5cGVzID0ge307XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuXG5cblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlSlNPTkVycm9yKHZhbGlkYXRpb24pIHtcbiAgaWYgKCF2YWxpZGF0aW9uLmhhc0Vycm9ycygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbnB1dCA9IHZhbGlkYXRpb24uaW5wdXQsXG4gICAgICBjb250ZXh0ID0gdmFsaWRhdGlvbi5jb250ZXh0O1xuXG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmFsaWRhdGlvbi5lcnJvcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgX3JlZiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgX3JlZjIgPSBzbGljZWRUb0FycmF5KF9yZWYsIDMpO1xuXG4gICAgICB2YXIgcGF0aCA9IF9yZWYyWzBdO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfcmVmMlsxXTtcbiAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBfcmVmMlsyXTtcblxuICAgICAgdmFyIGV4cGVjdGVkID0gZXhwZWN0ZWRUeXBlID8gZXhwZWN0ZWRUeXBlLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgdmFyIGFjdHVhbCA9IGNvbnRleHQudHlwZU9mKF9yZXNvbHZlUGF0aChpbnB1dCwgcGF0aCkpLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgZmllbGQgPSBzdHJpbmdpZnlQYXRoKHZhbGlkYXRpb24ucGF0aC5jb25jYXQocGF0aCkpO1xuXG4gICAgICB2YXIgcG9pbnRlciA9IGAvJHtwYXRoLmpvaW4oJy8nKX1gO1xuXG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZpZWxkLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgYWN0dWFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuLy8gVHJhY2tzIHdoZXRoZXIgd2UncmUgaW4gdmFsaWRhdGlvbiBvZiBjeWNsaWMgb2JqZWN0cy5cbnZhciBjeWNsaWNWYWxpZGF0aW9uID0gbmV3IFdlYWtNYXAoKTtcbi8vIFRyYWNrcyB3aGV0aGVyIHdlJ3JlIHRvU3RyaW5nKCkgb2YgY3ljbGljIG9iamVjdHMuXG5cblxudmFyIGN5Y2xpY1RvU3RyaW5nID0gbmV3IFdlYWtTZXQoKTtcblxuZnVuY3Rpb24gaW5WYWxpZGF0aW9uQ3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdHJhY2tlZCA9IGN5Y2xpY1ZhbGlkYXRpb24uZ2V0KHR5cGUpO1xuICAgIGlmICghdHJhY2tlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2Vha1NldEhhcyh0cmFja2VkLCBpbnB1dCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc29tZSBleG90aWMgdmFsdWVzIGNhbm5vdCBiZSBjaGVja2VkXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW9uQ3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgdmFyIHRyYWNrZWQgPSBjeWNsaWNWYWxpZGF0aW9uLmdldCh0eXBlKTtcbiAgaWYgKCF0cmFja2VkKSB7XG4gICAgdHJhY2tlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgY3ljbGljVmFsaWRhdGlvbi5zZXQodHlwZSwgdHJhY2tlZCk7XG4gIH1cbiAgd2Vha1NldEFkZCh0cmFja2VkLCBpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGVuZFZhbGlkYXRpb25DeWNsZSh0eXBlLCBpbnB1dCkge1xuICB2YXIgdHJhY2tlZCA9IGN5Y2xpY1ZhbGlkYXRpb24uZ2V0KHR5cGUpO1xuICBpZiAodHJhY2tlZCkge1xuICAgIHdlYWtTZXREZWxldGUodHJhY2tlZCwgaW5wdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluVG9TdHJpbmdDeWNsZSh0eXBlKSB7XG4gIHJldHVybiBjeWNsaWNUb1N0cmluZy5oYXModHlwZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VG9TdHJpbmdDeWNsZSh0eXBlKSB7XG4gIGN5Y2xpY1RvU3RyaW5nLmFkZCh0eXBlKTtcbn1cblxuZnVuY3Rpb24gZW5kVG9TdHJpbmdDeWNsZSh0eXBlKSB7XG4gIGN5Y2xpY1RvU3RyaW5nLmRlbGV0ZSh0eXBlKTtcbn1cblxuZnVuY3Rpb24gd2Vha1NldEhhcyh3ZWFrc2V0LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB3ZWFrc2V0Lmhhcyh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWFrU2V0QWRkKHdlYWtzZXQsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgd2Vha3NldC5hZGQodmFsdWUpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiB3ZWFrU2V0RGVsZXRlKHdlYWtzZXQsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgd2Vha3NldC5kZWxldGUodmFsdWUpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG52YXIgdmFsaWRJZGVudGlmaWVyT3JBY2Nlc3NvciA9IC9eWyRBLVpfXVswLTlBLVpfJFtcXF0uXSokL2k7XG5cbnZhciBWYWxpZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYWxpZGF0aW9uKGNvbnRleHQsIGlucHV0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdGlvbik7XG4gICAgdGhpcy5wYXRoID0gW107XG4gICAgdGhpcy5wcmVmaXggPSAnJztcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuY3ljbGljID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB9XG5cbiAgLy8gVHJhY2tzIHdoZXRoZXIgd2UncmUgaW4gdmFsaWRhdGlvbiBvZiBjeWNsaWMgb2JqZWN0cy5cblxuXG4gIGNyZWF0ZUNsYXNzKFZhbGlkYXRpb24sIFt7XG4gICAga2V5OiAnaW5DeWNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluQ3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciB0cmFja2VkID0gdGhpcy5jeWNsaWMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKCF0cmFja2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3ZWFrU2V0SGFzKHRyYWNrZWQsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydEN5Y2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRDeWNsZSh0eXBlLCBpbnB1dCkge1xuICAgICAgdmFyIHRyYWNrZWQgPSB0aGlzLmN5Y2xpYy5nZXQodHlwZSk7XG4gICAgICBpZiAoIXRyYWNrZWQpIHtcbiAgICAgICAgdHJhY2tlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHRoaXMuY3ljbGljLnNldCh0eXBlLCB0cmFja2VkKTtcbiAgICAgIH1cbiAgICAgIHdlYWtTZXRBZGQodHJhY2tlZCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuZEN5Y2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kQ3ljbGUodHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciB0cmFja2VkID0gdGhpcy5jeWNsaWMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgICAgd2Vha1NldERlbGV0ZSh0cmFja2VkLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzRXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRXJyb3JzKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuZXJyb3JzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCAxKTtcblxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IF9yZWYyWzBdO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hQYXRoKHBhdGgsIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9ycy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZEVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXJyb3IocGF0aCwgZXhwZWN0ZWRUeXBlLCBtZXNzYWdlKSB7XG4gICAgICB0aGlzLmVycm9ycy5wdXNoKFtwYXRoLCBtZXNzYWdlLCBleHBlY3RlZFR5cGVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyRXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckVycm9yKHBhdGgpIHtcbiAgICAgIHZhciBkaWRDbGVhciA9IGZhbHNlO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIF9lcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuZXJyb3JzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFBhdGgocGF0aCwgZXJyb3JbMF0pKSB7XG4gICAgICAgICAgICAgIGRpZENsZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVycm9ycyA9IF9lcnJvcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWRDbGVhciA9IHRoaXMuZXJyb3JzLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlkQ2xlYXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzb2x2ZVBhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gX3Jlc29sdmVQYXRoKHRoaXMuaW5wdXQsIHBhdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiBtYWtlSlNPTkVycm9yKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmFsaWRhdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGF0aChwYXRoKSB7XG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ1ZhbHVlJztcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgdmFyIHBhcnRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhdGhbaV07XG4gICAgaWYgKHBhcnQgPT09ICdbW1JldHVybiBUeXBlXV0nKSB7XG4gICAgICBwYXJ0c1tpXSA9ICdSZXR1cm4gVHlwZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycgfHwgIXZhbGlkSWRlbnRpZmllck9yQWNjZXNzb3IudGVzdChwYXJ0KSkge1xuICAgICAgcGFydHNbaV0gPSBgWyR7U3RyaW5nKHBhcnQpfV1gO1xuICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgIHBhcnRzW2ldID0gYC4ke1N0cmluZyhwYXJ0KX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0c1tpXSA9IFN0cmluZyhwYXJ0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVBhdGgoaW5wdXQsIHBhdGgpIHtcbiAgdmFyIHN1YmplY3QgPSBpbnB1dDtcbiAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3ViamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcGFydCA9IHBhdGhbaV07XG4gICAgaWYgKHBhcnQgPT09ICdbW1JldHVybiBUeXBlXV0nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmdldChwYXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3RbcGFydF07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJqZWN0O1xufVxuXG5mdW5jdGlvbiBtYXRjaFBhdGgocGF0aCwgY2FuZGlkYXRlKSB7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID4gY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbmRpZGF0ZVtpXSAhPT0gcGF0aFtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFJ1bnRpbWVUeXBlRXJyb3IgPSBmdW5jdGlvbiAoX1R5cGVFcnJvcikge1xuICBpbmhlcml0cyhSdW50aW1lVHlwZUVycm9yLCBfVHlwZUVycm9yKTtcblxuICBmdW5jdGlvbiBSdW50aW1lVHlwZUVycm9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSdW50aW1lVHlwZUVycm9yKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJ1bnRpbWVUeXBlRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSdW50aW1lVHlwZUVycm9yKSkuY2FsbCh0aGlzLCBtZXNzYWdlKSk7XG5cbiAgICBfdGhpcy5uYW1lID0gXCJSdW50aW1lVHlwZUVycm9yXCI7XG5cbiAgICBPYmplY3QuYXNzaWduKF90aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUnVudGltZVR5cGVFcnJvcjtcbn0oVHlwZUVycm9yKTtcblxudmFyIGRlbGltaXRlciA9ICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuJztcblxuZnVuY3Rpb24gbWFrZVR5cGVFcnJvcih2YWxpZGF0aW9uKSB7XG4gIGlmICghdmFsaWRhdGlvbi5oYXNFcnJvcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJlZml4ID0gdmFsaWRhdGlvbi5wcmVmaXgsXG4gICAgICBpbnB1dCA9IHZhbGlkYXRpb24uaW5wdXQsXG4gICAgICBjb250ZXh0ID0gdmFsaWRhdGlvbi5jb250ZXh0LFxuICAgICAgZXJyb3JzID0gdmFsaWRhdGlvbi5lcnJvcnM7XG5cbiAgdmFyIGNvbGxlY3RlZCA9IFtdO1xuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBlcnJvcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgX3JlZiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgX3JlZjIgPSBzbGljZWRUb0FycmF5KF9yZWYsIDMpO1xuXG4gICAgICB2YXIgcGF0aCA9IF9yZWYyWzBdO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfcmVmMlsxXTtcbiAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBfcmVmMlsyXTtcblxuICAgICAgdmFyIGV4cGVjdGVkID0gZXhwZWN0ZWRUeXBlID8gZXhwZWN0ZWRUeXBlLnRvU3RyaW5nKCkgOiBcIipcIjtcbiAgICAgIHZhciBhY3R1YWwgPSBfcmVzb2x2ZVBhdGgoaW5wdXQsIHBhdGgpO1xuICAgICAgdmFyIGFjdHVhbFR5cGUgPSBjb250ZXh0LnR5cGVPZihhY3R1YWwpLnRvU3RyaW5nKCk7XG5cbiAgICAgIHZhciBmaWVsZCA9IHN0cmluZ2lmeVBhdGgodmFsaWRhdGlvbi5wYXRoLmNvbmNhdChwYXRoKSk7XG5cbiAgICAgIHZhciBhY3R1YWxBc1N0cmluZyA9IG1ha2VTdHJpbmcoYWN0dWFsKTtcblxuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxBc1N0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29sbGVjdGVkLnB1c2goYCR7ZmllbGR9ICR7bWVzc2FnZX1cXG5cXG5FeHBlY3RlZDogJHtleHBlY3RlZH1cXG5cXG5BY3R1YWwgVmFsdWU6ICR7YWN0dWFsQXNTdHJpbmd9XFxuXFxuQWN0dWFsIFR5cGU6ICR7YWN0dWFsVHlwZX1cXG5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxlY3RlZC5wdXNoKGAke2ZpZWxkfSAke21lc3NhZ2V9XFxuXFxuRXhwZWN0ZWQ6ICR7ZXhwZWN0ZWR9XFxuXFxuQWN0dWFsOiAke2FjdHVhbFR5cGV9XFxuYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICByZXR1cm4gbmV3IFJ1bnRpbWVUeXBlRXJyb3IoYCR7cHJlZml4LnRyaW0oKX0gJHtjb2xsZWN0ZWQuam9pbihkZWxpbWl0ZXIpfWAsIHsgZXJyb3JzIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgUnVudGltZVR5cGVFcnJvcihjb2xsZWN0ZWQuam9pbihkZWxpbWl0ZXIpLCB7IGVycm9ycyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlU3RyaW5nKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgIC8vIElzc3VlXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUVycm9yKGV4cGVjdGVkLCBpbnB1dCkge1xuICB2YXIgY29udGV4dCA9IGV4cGVjdGVkLmNvbnRleHQ7XG5cbiAgdmFyIHZhbGlkYXRpb24gPSBjb250ZXh0LnZhbGlkYXRlKGV4cGVjdGVkLCBpbnB1dCk7XG4gIHJldHVybiBtYWtlVHlwZUVycm9yKHZhbGlkYXRpb24pO1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byB0eXBlcywgQSBhbmQgQiwgY29tcGFyZSB0aGVtIGFuZCByZXR1cm4gZWl0aGVyIC0xLCAwLCBvciAxOlxuICpcbiAqICAgLTEgaWYgQSBjYW5ub3QgYWNjZXB0IHR5cGUgQi5cbiAqXG4gKiAgICAwIGlmIHRoZSB0eXBlcyBhcmUgZWZmZWN0aXZlbHkgaWRlbnRpY2FsLlxuICpcbiAqICAgIDEgaWYgQSBhY2NlcHRzIGV2ZXJ5IHBvc3NpYmxlIEIuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlVHlwZXMoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYiBpbnN0YW5jZW9mIFR5cGVBbGlhcyB8fCBiIGluc3RhbmNlb2YgVHlwZVBhcmFtZXRlciB8fCBiIGluc3RhbmNlb2YgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uIHx8IGIgaW5zdGFuY2VvZiBUeXBlVERaKSB7XG4gICAgYiA9IGIudW53cmFwKCk7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIFR5cGVBbGlhcykge1xuICAgIHJlc3VsdCA9IGEuY29tcGFyZVdpdGgoYik7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEZsb3dJbnRvVHlwZSB8fCBhIGluc3RhbmNlb2YgVHlwZVBhcmFtZXRlciB8fCBiIGluc3RhbmNlb2YgRmxvd0ludG9UeXBlKSB7XG4gICAgcmVzdWx0ID0gYS5jb21wYXJlV2l0aChiKTtcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQW55VHlwZSB8fCBhIGluc3RhbmNlb2YgRXhpc3RlbnRpYWxUeXBlIHx8IGEgaW5zdGFuY2VvZiBNaXhlZFR5cGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBhLmNvbXBhcmVXaXRoKGIpO1xuICB9XG5cbiAgaWYgKGIgaW5zdGFuY2VvZiBBbnlUeXBlKSB7XG4gICAgLy8gTm90ZTogVGhpcyBjaGVjayBjYW5ub3QgYmUgbW92ZWQgaGlnaGVyIGluIHRoZSBzY29wZSxcbiAgICAvLyBhcyB0aGlzIHdvdWxkIHByZXZlbnQgdHlwZXMgZnJvbSBiZWluZyBwcm9wYWdhdGVkIHVwd2FyZHMuXG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqICMgVHlwZVxuICpcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcy5cbiAqL1xudmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFR5cGUoY29udGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGUpO1xuICAgIHRoaXMudHlwZU5hbWUgPSAnVHlwZSc7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7fVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gbmV3IFZhbGlkYXRpb24odGhpcy5jb250ZXh0LCBpbnB1dCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5lcnJvcnModmFsaWRhdGlvbiwgW10sIGlucHV0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c1R5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzVHlwZShpbnB1dCkge1xuICAgICAgaWYgKGNvbXBhcmVUeXBlcyh0aGlzLCBpbnB1dCkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnQoaW5wdXQpIHtcbiAgICAgIHZhciBlcnJvciA9IG1ha2VFcnJvcih0aGlzLCBpbnB1dCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCB0aGlzLmFzc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICckVHlwZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlO1xufSgpO1xuXG52YXIgQW55VHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhBbnlUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gQW55VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBbnlUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEFueVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBbnlUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnQW55VHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhBbnlUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnYW55JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFueVR5cGU7XG59KFR5cGUpO1xuXG52YXIgZXJyb3JNZXNzYWdlcyA9IHtcbiAgRVJSX0NPTlNUUkFJTlRfVklPTEFUSU9OOiAndmlvbGF0ZWQgYSBjb25zdHJhaW50JyxcbiAgRVJSX0VYUEVDVF9BUlJBWTogJ211c3QgYmUgYW4gQXJyYXknLFxuICBFUlJfRVhQRUNUX1RSVUU6ICdtdXN0IGJlIHRydWUnLFxuICBFUlJfRVhQRUNUX0ZBTFNFOiAnbXVzdCBiZSBmYWxzZScsXG4gIEVSUl9FWFBFQ1RfQk9PTEVBTjogJ211c3QgYmUgdHJ1ZSBvciBmYWxzZScsXG4gIEVSUl9FWFBFQ1RfRU1QVFk6ICdtdXN0IGJlIGVtcHR5JyxcbiAgRVJSX0VYUEVDVF9FWEFDVF9WQUxVRTogJ211c3QgYmUgZXhhY3RseSAkMCcsXG4gIEVSUl9FWFBFQ1RfQ0FMTEFCTEU6ICdtdXN0IGJlIGNhbGxhYmxlJyxcbiAgRVJSX0VYUEVDVF9DTEFTUzogJ211c3QgYmUgYSBDbGFzcyBvZiAkMCcsXG4gIEVSUl9FWFBFQ1RfRlVOQ1RJT046ICdtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICBFUlJfRVhQRUNUX0dFTkVSQVRPUjogJ211c3QgYmUgYSBnZW5lcmF0b3IgZnVuY3Rpb24nLFxuICBFUlJfRVhQRUNUX0lURVJBQkxFOiAnbXVzdCBiZSBpdGVyYWJsZScsXG4gIEVSUl9FWFBFQ1RfQVJHVU1FTlQ6ICdhcmd1bWVudCBcIiQwXCIgbXVzdCBiZTogJDEnLFxuICBFUlJfRVhQRUNUX1JFVFVSTjogJ2V4cGVjdGVkIHJldHVybiB0eXBlIG9mOiAkMCcsXG4gIEVSUl9FWFBFQ1RfTl9BUkdVTUVOVFM6ICdyZXF1aXJlcyAkMCBhcmd1bWVudChzKScsXG4gIEVSUl9FWFBFQ1RfSU5TVEFOQ0VPRjogJ211c3QgYmUgYW4gaW5zdGFuY2Ugb2YgJDAnLFxuICBFUlJfRVhQRUNUX0tFWV9UWVBFOiAna2V5cyBtdXN0IGJlOiAkMCcsXG4gIEVSUl9FWFBFQ1RfTlVMTDogJ211c3QgYmUgbnVsbCcsXG4gIEVSUl9FWFBFQ1RfTlVNQkVSOiAnbXVzdCBiZSBhIG51bWJlcicsXG4gIEVSUl9FWFBFQ1RfT0JKRUNUOiAnbXVzdCBiZSBhbiBvYmplY3QnLFxuICBFUlJfRVhQRUNUX1BST01JU0U6ICdtdXN0IGJlIGEgcHJvbWlzZSBvZiAkMCcsXG4gIEVSUl9FWFBFQ1RfU1RSSU5HOiAnbXVzdCBiZSBhIHN0cmluZycsXG4gIEVSUl9FWFBFQ1RfU1lNQk9MOiAnbXVzdCBiZSBhIHN5bWJvbCcsXG4gIEVSUl9FWFBFQ1RfVEhJUzogJ211c3QgYmUgZXhhY3RseSB0aGlzJyxcbiAgRVJSX0VYUEVDVF9WT0lEOiAnbXVzdCBiZSB1bmRlZmluZWQnLFxuICBFUlJfSU5WQUxJRF9EQVRFOiAnbXVzdCBiZSBhIHZhbGlkIGRhdGUnLFxuICBFUlJfTUlTU0lOR19QUk9QRVJUWTogJ2RvZXMgbm90IGV4aXN0IG9uIG9iamVjdCcsXG4gIEVSUl9OT19JTkRFWEVSOiAnaXMgbm90IG9uZSBvZiB0aGUgcGVybWl0dGVkIGluZGV4ZXIgdHlwZXMnLFxuICBFUlJfTk9fVU5JT046ICdtdXN0IGJlIG9uZSBvZjogJDAnLFxuICBFUlJfVU5LTk9XTl9LRVk6ICdzaG91bGQgbm90IGNvbnRhaW4gdGhlIGtleTogXCIkMFwiJ1xufTtcblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGtleSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IGVycm9yTWVzc2FnZXNba2V5XTtcbiAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvXFwkKFxcZCspL2csIGZ1bmN0aW9uIChtLCBpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHBhcmFtc1tpXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cbn1cblxudmFyIFR1cGxlVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhUdXBsZVR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUdXBsZVR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHVwbGVUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFR1cGxlVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR1cGxlVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R1cGxlVHlwZScsIF90aGlzLnR5cGVzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUdXBsZVR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0FSUkFZJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkKiB0eXBlc1tpXS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQoaSksIGlucHV0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ0FycmF5JywgaW5wdXQpIHx8IGlucHV0Lmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICghdHlwZS5hY2NlcHRzKGlucHV0W2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBUdXBsZVR5cGUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgaW5wdXRUeXBlcyA9IGlucHV0LnR5cGVzO1xuICAgICAgaWYgKGlucHV0VHlwZXMubGVuZ3RoIDwgdHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0dyZWF0ZXIgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0eXBlc1tpXSwgaW5wdXRUeXBlc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5sZW5ndGggPCBpbnB1dFR5cGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoaXNHcmVhdGVyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgWyR7dGhpcy50eXBlcy5qb2luKCcsICcpfV1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlczogdGhpcy50eXBlc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR1cGxlVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBBcnJheVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoQXJyYXlUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gQXJyYXlUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5VHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBBcnJheVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBcnJheVR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdBcnJheVR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQXJyYXlUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ0FycmF5JywgaW5wdXQpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQVJSQVknKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0aW9uLmluQ3ljbGUodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRpb24uc3RhcnRDeWNsZSh0aGlzLCBpbnB1dCk7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB0aGlzLmVsZW1lbnRUeXBlO1xuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkKiBlbGVtZW50VHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQoaSksIGlucHV0W2ldKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRpb24uZW5kQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaW5WYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3RhcnRWYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy5lbGVtZW50VHlwZTtcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlbGVtZW50VHlwZS5hY2NlcHRzKGlucHV0W2ldKSkge1xuICAgICAgICAgIGVuZFZhbGlkYXRpb25DeWNsZSh0aGlzLCBpbnB1dCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmRWYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVHVwbGVUeXBlKSB7XG4gICAgICAgIHZhciB0eXBlcyA9IGlucHV0LnR5cGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKGVsZW1lbnRUeXBlLCB0eXBlc1tpXSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXlUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoZWxlbWVudFR5cGUsIGlucHV0LmVsZW1lbnRUeXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKGluVG9TdHJpbmdDeWNsZSh0aGlzKSkge1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGBBcnJheTwkQ3ljbGU8JHtlbGVtZW50VHlwZS5uYW1lfT4+YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYEFycmF5PCRDeWNsZTxPYmplY3Q+PmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0VG9TdHJpbmdDeWNsZSh0aGlzKTtcbiAgICAgIHZhciBvdXRwdXQgPSBgQXJyYXk8JHtlbGVtZW50VHlwZS50b1N0cmluZygpfT5gO1xuICAgICAgZW5kVG9TdHJpbmdDeWNsZSh0aGlzKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIGVsZW1lbnRUeXBlOiB0aGlzLmVsZW1lbnRUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXJyYXlUeXBlO1xufShUeXBlKTtcblxudmFyIEJvb2xlYW5MaXRlcmFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhCb29sZWFuTGl0ZXJhbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9vbGVhbkxpdGVyYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEJvb2xlYW5MaXRlcmFsVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5MaXRlcmFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0Jvb2xlYW5MaXRlcmFsVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhCb29sZWFuTGl0ZXJhbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UodGhpcy52YWx1ZSA/ICdFUlJfRVhQRUNUX1RSVUUnIDogJ0VSUl9FWFBFQ1RfRkFMU0UnKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCA9PT0gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCb29sZWFuTGl0ZXJhbFR5cGUgJiYgaW5wdXQudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2xlYW5MaXRlcmFsVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBCb29sZWFuVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhCb29sZWFuVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEJvb2xlYW5UeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5UeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEJvb2xlYW5UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhblR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdCb29sZWFuVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhCb29sZWFuVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9CT09MRUFOJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQm9vbGVhbkxpdGVyYWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIEJvb2xlYW5UeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhblR5cGU7XG59KFR5cGUpO1xuXG52YXIgRW1wdHlUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEVtcHR5VHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEVtcHR5VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFbXB0eVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gRW1wdHlUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1wdHlUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnRW1wdHlUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEVtcHR5VHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0VNUFRZJyksIHRoaXNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGVtcHR5IHR5cGVzIGFjY2VwdHMgbm90aGluZy5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBFbXB0eVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnZW1wdHknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW1wdHlUeXBlO1xufShUeXBlKTtcblxudmFyIEV4aXN0ZW50aWFsVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhFeGlzdGVudGlhbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBFeGlzdGVudGlhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhpc3RlbnRpYWxUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEV4aXN0ZW50aWFsVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEV4aXN0ZW50aWFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0V4aXN0ZW50aWFsVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhFeGlzdGVudGlhbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge31cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcqJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEV4aXN0ZW50aWFsVHlwZTtcbn0oVHlwZSk7XG5cbi8qKlxuICogIyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb25cbiAqXG4gKi9cbnZhciBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24gPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24nLCBfdGhpcy50eXBlSW5zdGFuY2VzID0gW10sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24sIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIHR5cGVJbnN0YW5jZXMgPSB0aGlzLnR5cGVJbnN0YW5jZXM7XG5cbiAgICAgIHlpZWxkKiBwYXJlbnQuZXJyb3JzLmFwcGx5KHBhcmVudCwgW3ZhbGlkYXRpb24sIHBhdGgsIGlucHV0XS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIHR5cGVJbnN0YW5jZXMgPSB0aGlzLnR5cGVJbnN0YW5jZXM7XG5cbiAgICAgIHJldHVybiBwYXJlbnQuYWNjZXB0cy5hcHBseShwYXJlbnQsIFtpbnB1dF0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIF9wYXJlbnQ7XG5cbiAgICAgIHJldHVybiAoX3BhcmVudCA9IHRoaXMucGFyZW50KS5jb21wYXJlV2l0aC5hcHBseShfcGFyZW50LCBbaW5wdXRdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0aGlzLnR5cGVJbnN0YW5jZXMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnBhcmVudDtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuaGFzUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIHJldHVybiAoX3JlZjIgPSBpbm5lcikuaGFzUHJvcGVydHkuYXBwbHkoX3JlZjIsIFtuYW1lXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodGhpcy50eXBlSW5zdGFuY2VzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy5wYXJlbnQ7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICByZXR1cm4gKF9yZWYzID0gaW5uZXIpLmdldFByb3BlcnR5LmFwcGx5KF9yZWYzLCBbbmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHRoaXMudHlwZUluc3RhbmNlcykpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgX3BhcmVudDI7XG5cbiAgICAgIHJldHVybiAoX3BhcmVudDIgPSB0aGlzLnBhcmVudCkudW53cmFwLmFwcGx5KF9wYXJlbnQyLCB0b0NvbnN1bWFibGVBcnJheSh0aGlzLnR5cGVJbnN0YW5jZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIHR5cGVJbnN0YW5jZXMgPSB0aGlzLnR5cGVJbnN0YW5jZXM7XG4gICAgICB2YXIgbmFtZSA9IHBhcmVudC5uYW1lO1xuXG4gICAgICBpZiAodHlwZUluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZUluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0eXBlSW5zdGFuY2UgPSB0eXBlSW5zdGFuY2VzW2ldO1xuICAgICAgICAgIGl0ZW1zLnB1c2godHlwZUluc3RhbmNlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuYW1lfTwke2l0ZW1zLmpvaW4oJywgJyl9PmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZUluc3RhbmNlczogdGhpcy50eXBlSW5zdGFuY2VzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uO1xufShUeXBlKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludHMgdG8gdGhlIGdpdmVuIHN1YmplY3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gYWRkQ29uc3RyYWludHMoc3ViamVjdCkge1xuICB2YXIgX3N1YmplY3QkY29uc3RyYWludHM7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbnN0cmFpbnRzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNvbnN0cmFpbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIChfc3ViamVjdCRjb25zdHJhaW50cyA9IHN1YmplY3QuY29uc3RyYWludHMpLnB1c2guYXBwbHkoX3N1YmplY3QkY29uc3RyYWludHMsIHRvQ29uc3VtYWJsZUFycmF5KGNvbnN0cmFpbnRzKSk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBhbnkgZXJyb3JzIGZyb20gY29uc3RyYWludHMgb24gdGhlIGdpdmVuIHN1YmplY3QgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uKiBjb2xsZWN0Q29uc3RyYWludEVycm9ycyhzdWJqZWN0LCB2YWxpZGF0aW9uLCBwYXRoKSB7XG4gIHZhciBjb25zdHJhaW50cyA9IHN1YmplY3QuY29uc3RyYWludHM7XG4gIHZhciBsZW5ndGggPSBjb25zdHJhaW50cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpbnB1dCA9IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBpbnB1dFtfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuICAgIHZhciB2aW9sYXRpb24gPSBjb25zdHJhaW50LmFwcGx5KHVuZGVmaW5lZCwgdG9Db25zdW1hYmxlQXJyYXkoaW5wdXQpKTtcbiAgICBpZiAodHlwZW9mIHZpb2xhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHlpZWxkIFtwYXRoLCB2aW9sYXRpb24sIHRoaXNdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBpbnB1dCBwYXNzZXMgdGhlIGNvbnN0cmFpbnRzIG9uIHRoZSBzdWJqZWN0IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cmFpbnRzQWNjZXB0KHN1YmplY3QpIHtcbiAgdmFyIGNvbnN0cmFpbnRzID0gc3ViamVjdC5jb25zdHJhaW50cztcbiAgdmFyIGxlbmd0aCA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcblxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGlucHV0ID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGlucHV0W19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50LmFwcGx5KHVuZGVmaW5lZCwgdG9Db25zdW1hYmxlQXJyYXkoaW5wdXQpKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBUeXBlQWxpYXMgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHlwZUFsaWFzLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVHlwZUFsaWFzKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVBbGlhcyk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlQWxpYXMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlQWxpYXMpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlQWxpYXMnLCBfdGhpcy5jb25zdHJhaW50cyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZUFsaWFzLCBbe1xuICAgIGtleTogJ2FkZENvbnN0cmFpbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb25zdHJhaW50KCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBjb25zdHJhaW50cyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGFkZENvbnN0cmFpbnRzLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25zdHJhaW50cykpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRXJyb3JzKSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0Q29uc3RyYWludEVycm9ycyh0aGlzLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghY29uc3RyYWludHNBY2NlcHQodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gMDsgLy8gc2hvdWxkIG5ldmVyIG5lZWQgdGhpcyBiZWNhdXNlIGl0J3MgdGFrZW4gY2FyZSBvZiBieSBjb21wYXJlVHlwZXMuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQ29uc3RyYWludHMpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBjb25zdHJhaW50cyB0aGUgdHlwZXMgY2Fubm90IGJlIHRoZSBzYW1lXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmhhc1Byb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5oYXNQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAoaW5uZXIgJiYgdHlwZW9mIGlubmVyLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbm5lci5nZXRQcm9wZXJ0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgaWYgKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYHR5cGUgJHtuYW1lfSA9ICR7dHlwZS50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5wcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc0NvbnN0cmFpbnRzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlQWxpYXM7XG59KFR5cGUpO1xuXG52YXIgRmxvd0ludG9TeW1ib2wgPSBTeW1ib2woJ0Zsb3dJbnRvJyk7XG5cbi8qKlxuICogIyBUeXBlUGFyYW1ldGVyXG4gKlxuICogVHlwZSBwYXJhbWV0ZXJzIGFsbG93IHBvbHltb3JwaGljIHR5cGUgc2FmZXR5LlxuICogVGhlIGZpcnN0IHRpbWUgYSB0eXBlIHBhcmFtZXRlciBpcyBjaGVja2VkLCBpdCByZWNvcmRzIHRoZSBzaGFwZSBvZiBpdHMgaW5wdXQsXG4gKiB0aGlzIHJlY29yZGVkIHNoYXBlIGlzIHVzZWQgdG8gY2hlY2sgYWxsIGZ1dHVyZSBpbnB1dHMgZm9yIHRoaXMgcGFydGljdWxhciBpbnN0YW5jZS5cbiAqL1xuXG52YXIgVHlwZVBhcmFtZXRlciA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhUeXBlUGFyYW1ldGVyLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVHlwZVBhcmFtZXRlcigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlUGFyYW1ldGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFR5cGVQYXJhbWV0ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlUGFyYW1ldGVyKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVHlwZVBhcmFtZXRlcicsIF90aGlzW0Zsb3dJbnRvU3ltYm9sXSA9IG51bGwsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVQYXJhbWV0ZXIsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIGJvdW5kT3JEZWZhdWx0ID0gdGhpcy5ib3VuZCB8fCB0aGlzLmRlZmF1bHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0aGlzLnJlY29yZGVkLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblxuICAgICAgaWYgKGJvdW5kT3JEZWZhdWx0IGluc3RhbmNlb2YgRmxvd0ludG9UeXBlIHx8IGJvdW5kT3JEZWZhdWx0IGluc3RhbmNlb2YgVHlwZUFsaWFzKSB7XG4gICAgICAgIC8vIFdlIGRlZmVyIHRvIHRoZSBvdGhlciB0eXBlIHBhcmFtZXRlciBzbyB0aGF0IHZhbHVlcyBmcm9tIHRoaXNcbiAgICAgICAgLy8gb25lIGNhbiBmbG93IFwidXB3YXJkc1wiLlxuICAgICAgICB5aWVsZCogYm91bmRPckRlZmF1bHQuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZCkge1xuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIGEgdmFsdWUgZm9yIHRoaXMgdHlwZSBwYXJhbWV0ZXJcbiAgICAgICAgeWllbGQqIHJlY29yZGVkLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRPckRlZmF1bHQpIHtcbiAgICAgICAgaWYgKGJvdW5kT3JEZWZhdWx0LnR5cGVOYW1lID09PSAnQW55VHlwZScgfHwgYm91bmRPckRlZmF1bHQudHlwZU5hbWUgPT09ICdFeGlzdGVudGlhbFR5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGJvdW5kT3JEZWZhdWx0LmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvcmRlZCA9IGNvbnRleHQudHlwZU9mKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGJvdW5kT3JEZWZhdWx0ID0gdGhpcy5ib3VuZCB8fCB0aGlzLmRlZmF1bHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0aGlzLnJlY29yZGVkLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmIChib3VuZE9yRGVmYXVsdCBpbnN0YW5jZW9mIEZsb3dJbnRvVHlwZSB8fCBib3VuZE9yRGVmYXVsdCBpbnN0YW5jZW9mIFR5cGVBbGlhcykge1xuICAgICAgICAvLyBXZSBkZWZlciB0byB0aGUgb3RoZXIgdHlwZSBwYXJhbWV0ZXIgc28gdGhhdCB2YWx1ZXMgZnJvbSB0aGlzXG4gICAgICAgIC8vIG9uZSBjYW4gZmxvdyBcInVwd2FyZHNcIi5cbiAgICAgICAgcmV0dXJuIGJvdW5kT3JEZWZhdWx0LmFjY2VwdHMoaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkZWQuYWNjZXB0cyhpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kT3JEZWZhdWx0KSB7XG4gICAgICAgIGlmIChib3VuZE9yRGVmYXVsdC50eXBlTmFtZSA9PT0gXCJBbnlUeXBlXCIgfHwgYm91bmRPckRlZmF1bHQudHlwZU5hbWUgPT09IFwiRXhpc3RlbnRpYWxUeXBlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghYm91bmRPckRlZmF1bHQuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvcmRlZCA9IGNvbnRleHQudHlwZU9mKGlucHV0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHZhciBib3VuZE9yRGVmYXVsdCA9IHRoaXMuYm91bmQgfHwgdGhpcy5kZWZhdWx0O1xuICAgICAgdmFyIHJlY29yZGVkID0gdGhpcy5yZWNvcmRlZDtcblxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVHlwZVBhcmFtZXRlcikge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBgcmVjb3JkZWRgIG9yIGBib3VuZGAgZmllbGRzXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGlucHV0IGhhcyBhbHJlYWR5IGJlZW4gdW53cmFwcGVkLCBzb1xuICAgICAgICAvLyBpZiB3ZSBnb3QgYSB0eXBlIHBhcmFtZXRlciBpdCBtdXN0IGJlIHRvdGFsbHkgZ2VuZXJpYyBhbmRcbiAgICAgICAgLy8gd2UgdHJlYXQgaXQgbGlrZSBBbnkuXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHJlY29yZGVkLCBpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kT3JEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoYm91bmRPckRlZmF1bHQsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgZ2VuZXJpYyB0eXBlIHBhcmFtZXRlciBhY2NlcHRzIGFueSBpbnB1dC5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgYm91bmRPckRlZmF1bHQgPSB0aGlzLmJvdW5kIHx8IHRoaXMuZGVmYXVsdDtcbiAgICAgIHZhciByZWNvcmRlZCA9IHRoaXMucmVjb3JkZWQ7XG5cbiAgICAgIGlmIChyZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkZWQudW53cmFwKCk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kT3JEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBib3VuZE9yRGVmYXVsdC51bndyYXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcod2l0aEJpbmRpbmcpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQsXG4gICAgICAgICAgYm91bmQgPSB0aGlzLmJvdW5kLFxuICAgICAgICAgIGRlZmF1bHRUeXBlID0gdGhpcy5kZWZhdWx0O1xuXG4gICAgICBpZiAod2l0aEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2lkfSA9ICR7ZGVmYXVsdFR5cGUudG9TdHJpbmcoKX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2lkfTogJHtib3VuZC50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICByZWNvcmRlZDogdGhpcy5yZWNvcmRlZFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVQYXJhbWV0ZXI7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiBmbG93SW50b1R5cGVQYXJhbWV0ZXIodHlwZVBhcmFtZXRlcikge1xuICB2YXIgZXhpc3RpbmcgPSB0eXBlUGFyYW1ldGVyW0Zsb3dJbnRvU3ltYm9sXTtcbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IG5ldyBGbG93SW50b1R5cGUodHlwZVBhcmFtZXRlci5jb250ZXh0KTtcbiAgdGFyZ2V0LnR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyO1xuICB0eXBlUGFyYW1ldGVyW0Zsb3dJbnRvU3ltYm9sXSA9IHRhcmdldDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiAjIEZsb3dJbnRvVHlwZVxuICpcbiAqIEEgdmlydHVhbCB0eXBlIHdoaWNoIGFsbG93cyB0eXBlcyBpdCByZWNlaXZlcyB0byBcImZsb3dcIiB1cHdhcmRzIGludG8gYSB0eXBlIHBhcmFtZXRlci5cbiAqIFRoZSB0eXBlIHBhcmFtZXRlciB3aWxsIGJlY29tZSBvZiBhIHVuaW9uIG9mIGFueSB0eXBlcyBzZWVuIGJ5IHRoaXMgaW5zdGFuY2UuXG4gKi9cblxudmFyIEZsb3dJbnRvVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhGbG93SW50b1R5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBGbG93SW50b1R5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxvd0ludG9UeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEZsb3dJbnRvVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsb3dJbnRvVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0Zsb3dJbnRvVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhGbG93SW50b1R5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnR5cGVQYXJhbWV0ZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciByZWNvcmRlZCA9IHR5cGVQYXJhbWV0ZXIucmVjb3JkZWQsXG4gICAgICAgICAgYm91bmQgPSB0eXBlUGFyYW1ldGVyLmJvdW5kO1xuXG5cbiAgICAgIGlmIChib3VuZCBpbnN0YW5jZW9mIEZsb3dJbnRvVHlwZSkge1xuICAgICAgICAvLyBXZSBkZWZlciB0byB0aGUgb3RoZXIgdHlwZSBzbyB0aGF0IHZhbHVlcyBmcm9tIHRoaXNcbiAgICAgICAgLy8gb25lIGNhbiBmbG93IFwidXB3YXJkc1wiLlxuICAgICAgICB5aWVsZCogYm91bmQuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlY29yZGVkKSB7XG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgYSB2YWx1ZSBmb3IgdGhpcyB0eXBlIHBhcmFtZXRlclxuICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGJvdW5kLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZGVkLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgLy8gb3VyIGV4aXN0aW5nIHR5cGUgYWxyZWFkeSBwZXJtaXRzIHRoaXMgdmFsdWUsIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGEgdW5pb25cbiAgICAgICAgICB0eXBlUGFyYW1ldGVyLnJlY29yZGVkID0gY29udGV4dC51bmlvbihyZWNvcmRlZCwgY29udGV4dC50eXBlT2YoaW5wdXQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYm91bmQpIHtcbiAgICAgICAgaWYgKGJvdW5kLnR5cGVOYW1lID09PSAnQW55VHlwZScgfHwgYm91bmQudHlwZU5hbWUgPT09ICdFeGlzdGVudGlhbFR5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBib3VuZC5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBfZXJyb3IgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgICAgeWllbGQgX2Vycm9yO1xuICAgICAgICAgICAgICBfaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2hhc0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHR5cGVQYXJhbWV0ZXIucmVjb3JkZWQgPSBjb250ZXh0LnR5cGVPZihpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdGhpcy50eXBlUGFyYW1ldGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0eXBlUGFyYW1ldGVyLnJlY29yZGVkLFxuICAgICAgICAgIGJvdW5kID0gdHlwZVBhcmFtZXRlci5ib3VuZDtcblxuXG4gICAgICBpZiAoYm91bmQgaW5zdGFuY2VvZiBGbG93SW50b1R5cGUpIHtcbiAgICAgICAgLy8gV2UgZGVmZXIgdG8gdGhlIG90aGVyIHR5cGUgc28gdGhhdCB2YWx1ZXMgZnJvbSB0aGlzXG4gICAgICAgIC8vIG9uZSBjYW4gZmxvdyBcInVwd2FyZHNcIi5cbiAgICAgICAgcmV0dXJuIGJvdW5kLmFjY2VwdHMoaW5wdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlY29yZGVkKSB7XG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgYSB2YWx1ZSBmb3IgdGhpcyB0eXBlIHBhcmFtZXRlclxuICAgICAgICBpZiAoYm91bmQgJiYgIWJvdW5kLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZGVkLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgLy8gb3VyIGV4aXN0aW5nIHR5cGUgYWxyZWFkeSBwZXJtaXRzIHRoaXMgdmFsdWUsIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgYSB1bmlvblxuICAgICAgICAgIHR5cGVQYXJhbWV0ZXIucmVjb3JkZWQgPSBjb250ZXh0LnVuaW9uKHJlY29yZGVkLCBjb250ZXh0LnR5cGVPZihpbnB1dCkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kKSB7XG4gICAgICAgIGlmIChib3VuZC50eXBlTmFtZSA9PT0gJ0FueVR5cGUnIHx8IGJvdW5kLnR5cGVOYW1lID09PSAnRXhpc3RlbnRpYWxUeXBlJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFib3VuZC5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0eXBlUGFyYW1ldGVyLnJlY29yZGVkID0gY29udGV4dC50eXBlT2YoaW5wdXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgdmFyIHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnR5cGVQYXJhbWV0ZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciByZWNvcmRlZCA9IHR5cGVQYXJhbWV0ZXIucmVjb3JkZWQsXG4gICAgICAgICAgYm91bmQgPSB0eXBlUGFyYW1ldGVyLmJvdW5kO1xuXG4gICAgICBpZiAoYm91bmQgaW5zdGFuY2VvZiBGbG93SW50b1R5cGUpIHtcbiAgICAgICAgLy8gV2UgZGVmZXIgdG8gdGhlIG90aGVyIHR5cGUgc28gdGhhdCB2YWx1ZXMgZnJvbSB0aGlzXG4gICAgICAgIC8vIG9uZSBjYW4gZmxvdyBcInVwd2FyZHNcIi5cbiAgICAgICAgcmV0dXJuIGJvdW5kLmNvbXBhcmVXaXRoKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmRlZCkge1xuICAgICAgICBpZiAoYm91bmQgJiYgY29tcGFyZVR5cGVzKGJvdW5kLCBpbnB1dCkgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXMocmVjb3JkZWQsIGlucHV0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgIC8vIG91ciBleGlzdGluZyB0eXBlIGFscmVhZHkgcGVybWl0cyB0aGlzIHZhbHVlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGEgdW5pb25cbiAgICAgICAgdHlwZVBhcmFtZXRlci5yZWNvcmRlZCA9IGNvbnRleHQudW5pb24ocmVjb3JkZWQsIGlucHV0KTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kKSB7XG4gICAgICAgIGlmIChib3VuZC50eXBlTmFtZSA9PT0gJ0FueVR5cGUnIHx8IGJvdW5kLnR5cGVOYW1lID09PSAnRXhpc3RlbnRpYWxUeXBlJykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcmVzdWx0ID0gY29tcGFyZVR5cGVzKGJvdW5kLCBpbnB1dCk7XG4gICAgICAgIGlmIChfcmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0eXBlUGFyYW1ldGVyLnJlY29yZGVkID0gaW5wdXQ7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVQYXJhbWV0ZXIudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoQmluZGluZykge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZVBhcmFtZXRlci50b1N0cmluZyh3aXRoQmluZGluZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZVBhcmFtZXRlci50b0pTT04oKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZsb3dJbnRvVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBGdW5jdGlvblR5cGVSZXN0UGFyYW0gPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoRnVuY3Rpb25UeXBlUmVzdFBhcmFtLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gRnVuY3Rpb25UeXBlUmVzdFBhcmFtKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBGdW5jdGlvblR5cGVSZXN0UGFyYW0uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvblR5cGVSZXN0UGFyYW0pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdGdW5jdGlvblR5cGVSZXN0UGFyYW0nLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25UeXBlUmVzdFBhcmFtLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB5aWVsZCogdHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgcmV0dXJuIHR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUGFyYW0gfHwgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGVSZXN0UGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0LnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiBgLi4uJHt0aGlzLm5hbWV9OiAke3R5cGUudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbTtcbn0oVHlwZSk7XG5cbnZhciBGdW5jdGlvblR5cGVQYXJhbSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhGdW5jdGlvblR5cGVQYXJhbSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uVHlwZVBhcmFtKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uVHlwZVBhcmFtKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEZ1bmN0aW9uVHlwZVBhcmFtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25UeXBlUGFyYW0pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdGdW5jdGlvblR5cGVQYXJhbScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhGdW5jdGlvblR5cGVQYXJhbSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmIChvcHRpb25hbCAmJiBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiB0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBvcHRpb25hbCA9IHRoaXMub3B0aW9uYWwsXG4gICAgICAgICAgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgaWYgKG9wdGlvbmFsICYmIGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvblR5cGVQYXJhbSB8fCBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9JHtvcHRpb25hbCA/ICc/JyA6ICcnfTogJHt0eXBlLnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25hbDogdGhpcy5vcHRpb25hbCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25UeXBlUGFyYW07XG59KFR5cGUpO1xuXG52YXIgRnVuY3Rpb25UeXBlUmV0dXJuID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uVHlwZVJldHVybiwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uVHlwZVJldHVybigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvblR5cGVSZXR1cm4pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gRnVuY3Rpb25UeXBlUmV0dXJuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25UeXBlUmV0dXJuKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnRnVuY3Rpb25UeXBlUmV0dXJuJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEZ1bmN0aW9uVHlwZVJldHVybiwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgeWllbGQqIHR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KCdbW1JldHVybiBUeXBlXV0nKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgcmV0dXJuIHR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUmV0dXJuKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dC50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy50eXBlLCBpbnB1dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiB0eXBlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uVHlwZVJldHVybjtcbn0oVHlwZSk7XG5cbnZhciBQYXJlbnRTeW1ib2wgPSBTeW1ib2woJ1BhcmVudCcpO1xudmFyIE5hbWVSZWdpc3RyeVN5bWJvbCA9IFN5bWJvbCgnTmFtZVJlZ2lzdHJ5Jyk7XG52YXIgTW9kdWxlUmVnaXN0cnlTeW1ib2wgPSBTeW1ib2woJ01vZHVsZVJlZ2lzdHJ5Jyk7XG52YXIgQ3VycmVudE1vZHVsZVN5bWJvbCA9IFN5bWJvbCgnQ3VycmVudE1vZHVsZScpO1xudmFyIFR5cGVDb25zdHJ1Y3RvclJlZ2lzdHJ5U3ltYm9sID0gU3ltYm9sKCdUeXBlQ29uc3RydWN0b3JSZWdpc3RyeScpO1xudmFyIEluZmVycmVyU3ltYm9sID0gU3ltYm9sKCdJbmZlcnJlcicpO1xuXG5cbnZhciBUeXBlU3ltYm9sID0gU3ltYm9sKCdUeXBlJyk7XG52YXIgVHlwZVBhcmFtZXRlcnNTeW1ib2wgPSBTeW1ib2woJ1R5cGVQYXJhbWV0ZXJzJyk7XG52YXIgVHlwZVByZWRpY2F0ZVJlZ2lzdHJ5U3ltYm9sID0gU3ltYm9sKCdUeXBlUHJlZGljYXRlUmVnaXN0cnknKTtcblxudmFyIEZ1bmN0aW9uVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhGdW5jdGlvblR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBGdW5jdGlvblR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25UeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEZ1bmN0aW9uVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ0Z1bmN0aW9uVHlwZScsIF90aGlzLnBhcmFtcyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25UeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9GVU5DVElPTicpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFubm90YXRpb24gPSBpbnB1dFtUeXBlU3ltYm9sXTtcbiAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXG4gICAgICBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoIWFubm90YXRpb24ucGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9uUGFyYW0gPSBhbm5vdGF0aW9uLnBhcmFtc1tpXTtcbiAgICAgICAgICBpZiAoIWFubm90YXRpb25QYXJhbSAmJiAhcGFyYW0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQVJHVU1FTlQnLCBwYXJhbS5uYW1lLCBwYXJhbS50eXBlLnRvU3RyaW5nKCkpLCB0aGlzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXJhbS5hY2NlcHRzVHlwZShhbm5vdGF0aW9uUGFyYW0pKSB7XG4gICAgICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0FSR1VNRU5UJywgcGFyYW0ubmFtZSwgcGFyYW0udHlwZS50b1N0cmluZygpKSwgdGhpc107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmV0dXJuVHlwZS5hY2NlcHRzVHlwZShhbm5vdGF0aW9uLnJldHVyblR5cGUpKSB7XG4gICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9SRVRVUk4nLCByZXR1cm5UeXBlLnRvU3RyaW5nKCkpLCB0aGlzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzYWZlbHkgY2hlY2sgYW4gdW5hbm5vdGF0ZWQgZnVuY3Rpb24uXG4gICAgICAgIC8vIEJ1dCB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSBgYW55YCB0eXBlIGZlZWRiYWNrIHVwd2FyZHMuXG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhcmFtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3BhcmFtID0gcGFyYW1zW19pXTtcbiAgICAgICAgICBfcGFyYW0uYWNjZXB0c1R5cGUoY29udGV4dC5hbnkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVHlwZS5hY2NlcHRzVHlwZShjb250ZXh0LmFueSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMucmV0dXJuVHlwZSxcbiAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcztcblxuICAgICAgdmFyIGFubm90YXRpb24gPSBpbnB1dFtUeXBlU3ltYm9sXTtcbiAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbi5wYXJhbXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgICB2YXIgYW5ub3RhdGlvblBhcmFtID0gYW5ub3RhdGlvbi5wYXJhbXNbaV07XG4gICAgICAgICAgaWYgKCFhbm5vdGF0aW9uUGFyYW0gJiYgIXBhcmFtLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICghcGFyYW0uYWNjZXB0c1R5cGUoYW5ub3RhdGlvblBhcmFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJldHVyblR5cGUuYWNjZXB0c1R5cGUoYW5ub3RhdGlvbi5yZXR1cm5UeXBlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAvLyBXZSBjYW5ub3Qgc2FmZWx5IGNoZWNrIGFuIHVuYW5ub3RhdGVkIGZ1bmN0aW9uLlxuICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBwcm9wYWdhdGUgYGFueWAgdHlwZSBmZWVkYmFjayB1cHdhcmRzLlxuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcmFtcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9wYXJhbTIgPSBwYXJhbXNbX2kyXTtcbiAgICAgICAgICBfcGFyYW0yLmFjY2VwdHNUeXBlKGNvbnRleHQuYW55KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblR5cGUuYWNjZXB0c1R5cGUoY29udGV4dC5hbnkoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMucmV0dXJuVHlwZTtcbiAgICAgIHZhciBpbnB1dFJldHVyblR5cGUgPSBpbnB1dC5yZXR1cm5UeXBlO1xuICAgICAgdmFyIGlzR3JlYXRlciA9IGZhbHNlO1xuICAgICAgdmFyIHJldHVyblR5cGVSZXN1bHQgPSBjb21wYXJlVHlwZXMocmV0dXJuVHlwZSwgaW5wdXRSZXR1cm5UeXBlKTtcbiAgICAgIGlmIChyZXR1cm5UeXBlUmVzdWx0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHJldHVyblR5cGVSZXN1bHQgPT09IDEpIHtcbiAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgdmFyIGlucHV0UGFyYW1zID0gaW5wdXQucGFyYW1zO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICB2YXIgaW5wdXRQYXJhbSA9IGkgPj0gaW5wdXRQYXJhbXMubGVuZ3RoID8gaW5wdXQucmVzdCA6IGlucHV0UGFyYW1zW2ldO1xuICAgICAgICBpZiAoaW5wdXRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXMocGFyYW0sIGlucHV0UGFyYW0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNHcmVhdGVyID8gMSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c1BhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNQYXJhbXMoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICAgICAgcmVzdCA9IHRoaXMucmVzdDtcblxuICAgICAgdmFyIHBhcmFtc0xlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICBpZiAoaSA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBhcmFtLmFjY2VwdHMoYXJnc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmFtLmFjY2VwdHModW5kZWZpbmVkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IHBhcmFtc0xlbmd0aCAmJiByZXN0KSB7XG4gICAgICAgIGZvciAodmFyIF9pMyA9IHBhcmFtc0xlbmd0aDsgX2kzIDwgYXJnc0xlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICBpZiAoIXJlc3QuYWNjZXB0cyhhcmdzW19pM10pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNSZXR1cm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzUmV0dXJuKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXR1cm5UeXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFBhcmFtcygpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcyxcbiAgICAgICAgICByZXN0ID0gdGhpcy5yZXN0O1xuXG4gICAgICB2YXIgcGFyYW1zTGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgIGlmIChpIDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHBhcmFtLmFzc2VydChhcmdzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbS5hc3NlcnQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IHBhcmFtc0xlbmd0aCAmJiByZXN0KSB7XG4gICAgICAgIGZvciAodmFyIF9pNCA9IHBhcmFtc0xlbmd0aDsgX2k0IDwgYXJnc0xlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICByZXN0LmFzc2VydChhcmdzW19pNF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFJldHVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFJldHVybihpbnB1dCkge1xuICAgICAgdGhpcy5yZXR1cm5UeXBlLmFzc2VydChpbnB1dCk7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW52b2tlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52b2tlKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuICAgICAgICAgIHJlc3QgPSB0aGlzLnJlc3QsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHBhcmFtc0xlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICBpZiAoaSA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBhcmFtLmFjY2VwdHNUeXBlKGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcGFyYW0uYWNjZXB0cyh1bmRlZmluZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IHBhcmFtc0xlbmd0aCAmJiByZXN0KSB7XG4gICAgICAgIGZvciAodmFyIF9pNSA9IHBhcmFtc0xlbmd0aDsgX2k1IDwgYXJnc0xlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgICBpZiAoIXJlc3QuYWNjZXB0c1R5cGUoYXJnc1tfaTVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZW1wdHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuVHlwZS50eXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICAgICAgcmVzdCA9IHRoaXMucmVzdCxcbiAgICAgICAgICByZXR1cm5UeXBlID0gdGhpcy5yZXR1cm5UeXBlO1xuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKHBhcmFtc1tpXS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgIGFyZ3MucHVzaChyZXN0LnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAoJHthcmdzLmpvaW4oJywgJyl9KSA9PiAke3JldHVyblR5cGUudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICByZXN0OiB0aGlzLnJlc3QsXG4gICAgICAgIHJldHVyblR5cGU6IHRoaXMucmV0dXJuVHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBHZW5lcmF0b3JUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEdlbmVyYXRvclR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3JUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEdlbmVyYXRvclR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gR2VuZXJhdG9yVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlbmVyYXRvclR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdHZW5lcmF0b3JUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEdlbmVyYXRvclR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIGlzVmFsaWQgPSBpbnB1dCAmJiB0eXBlb2YgaW5wdXQubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5wdXQucmV0dXJuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnB1dC50aHJvdyA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0dFTkVSQVRPUicpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ICYmIHR5cGVvZiBpbnB1dC5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnB1dC5yZXR1cm4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnRocm93ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgR2VuZXJhdG9yVHlwZSkpIHtcbiAgICAgICAgdmFyIF9yZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy55aWVsZFR5cGUsIGlucHV0KTtcbiAgICAgICAgaWYgKF9yZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaXNHcmVhdGVyID0gZmFsc2U7XG4gICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMueWllbGRUeXBlLCBpbnB1dC55aWVsZFR5cGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMucmV0dXJuVHlwZSwgaW5wdXQucmV0dXJuVHlwZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy5uZXh0VHlwZSwgaW5wdXQubmV4dFR5cGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzR3JlYXRlciA/IDEgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNZaWVsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNZaWVsZChpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMueWllbGRUeXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNSZXR1cm4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzUmV0dXJuKGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXR1cm5UeXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHNOZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c05leHQoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUeXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFlpZWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0WWllbGQoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnlpZWxkVHlwZS5hc3NlcnQoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFJldHVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFJldHVybihpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuVHlwZS5hc3NlcnQoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydE5leHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnROZXh0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VHlwZS5hc3NlcnQoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgeWllbGRUeXBlID0gdGhpcy55aWVsZFR5cGUsXG4gICAgICAgICAgcmV0dXJuVHlwZSA9IHRoaXMucmV0dXJuVHlwZSxcbiAgICAgICAgICBuZXh0VHlwZSA9IHRoaXMubmV4dFR5cGU7XG5cbiAgICAgIHJldHVybiBgR2VuZXJhdG9yPCR7eWllbGRUeXBlLnRvU3RyaW5nKCl9LCAke3JldHVyblR5cGUudG9TdHJpbmcoKX0sICR7bmV4dFR5cGUudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB5aWVsZFR5cGU6IHRoaXMueWllbGRUeXBlLFxuICAgICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG4gICAgICAgIG5leHRUeXBlOiB0aGlzLm5leHRUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gR2VuZXJhdG9yVHlwZTtcbn0oVHlwZSk7XG5cbnZhciB3YXJuZWRJbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xuXG52YXIgVHlwZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVDb25zdHJ1Y3RvciwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVDb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlQ29uc3RydWN0b3IpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZUNvbnN0cnVjdG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZUNvbnN0cnVjdG9yKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVHlwZUNvbnN0cnVjdG9yJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGVDb25zdHJ1Y3RvciwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7fVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgIGlmICghd2FybmVkSW5zdGFuY2VzLmhhcyh0aGlzKSkge1xuICAgICAgICBjb250ZXh0LmVtaXRXYXJuaW5nTWVzc2FnZShgVHlwZUNvbnN0cnVjdG9yICR7bmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IGFjY2VwdHMoKS5gKTtcbiAgICAgICAgd2FybmVkSW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICBpZiAoIXdhcm5lZEluc3RhbmNlcy5oYXModGhpcykpIHtcbiAgICAgICAgY29udGV4dC5lbWl0V2FybmluZ01lc3NhZ2UoYFR5cGVDb25zdHJ1Y3RvciAke25hbWV9IGRvZXMgbm90IGltcGxlbWVudCBjb21wYXJlV2l0aCgpLmApO1xuICAgICAgICB3YXJuZWRJbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZmVyVHlwZVBhcmFtZXRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVDb25zdHJ1Y3Rvcjtcbn0oVHlwZSk7XG5cbnZhciBHZW5lcmljVHlwZSA9IGZ1bmN0aW9uIChfVHlwZUNvbnN0cnVjdG9yKSB7XG4gIGluaGVyaXRzKEdlbmVyaWNUeXBlLCBfVHlwZUNvbnN0cnVjdG9yKTtcblxuICBmdW5jdGlvbiBHZW5lcmljVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHZW5lcmljVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBHZW5lcmljVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlbmVyaWNUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSBcIkdlbmVyaWNUeXBlXCIsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhHZW5lcmljVHlwZSwgW3tcbiAgICBrZXk6IFwiZXJyb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIGltcGwgPSB0aGlzLmltcGw7XG5cbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgaW1wbCkpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZShcIkVSUl9FWFBFQ1RfSU5TVEFOQ0VPRlwiLCBuYW1lKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFjY2VwdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGltcGwgPSB0aGlzLmltcGw7XG5cbiAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIGltcGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBpbXBsID0gdGhpcy5pbXBsO1xuXG4gICAgICB2YXIgYW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0QW5ub3RhdGlvbihpbXBsKTtcbiAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkID0gYW5ub3RhdGlvbi51bndyYXAuYXBwbHkoYW5ub3RhdGlvbiwgdG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpO1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGlucHV0LCBleHBlY3RlZCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgR2VuZXJpY1R5cGUgJiYgKGlucHV0LmltcGwgPT09IGltcGwgfHwgaW1wbCAmJiBpbXBsLmlzUHJvdG90eXBlT2YoaW5wdXQuaW1wbCkpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bndyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgaW1wbCA9IHRoaXMuaW1wbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbXBsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0QW5ub3RhdGlvbihpbXBsKTtcbiAgICAgIGlmIChhbm5vdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb24udW53cmFwLmFwcGx5KGFubm90YXRpb24sIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mZXJUeXBlUGFyYW1ldGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBHZW5lcmljVHlwZTtcbn0oVHlwZUNvbnN0cnVjdG9yKTtcblxuZnVuY3Rpb24gaW52YXJpYW50KGlucHV0LCBtZXNzYWdlKSB7XG4gIGlmICghaW5wdXQpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnRWaW9sYXRpb24nO1xuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBpbnZhcmlhbnQpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG52YXIgTnVsbExpdGVyYWxUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE51bGxMaXRlcmFsVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIE51bGxMaXRlcmFsVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdWxsTGl0ZXJhbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTnVsbExpdGVyYWxUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVsbExpdGVyYWxUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTnVsbExpdGVyYWxUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE51bGxMaXRlcmFsVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9OVUxMJyksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgPT09IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTnVsbExpdGVyYWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVsbExpdGVyYWxUeXBlO1xufShUeXBlKTtcblxudmFyIFZvaWRUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFZvaWRUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gVm9pZFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9pZFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVm9pZFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWb2lkVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1ZvaWRUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFZvaWRUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfVk9JRCcpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVm9pZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAndm9pZCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWb2lkVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBOdWxsYWJsZVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoTnVsbGFibGVUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gTnVsbGFibGVUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bGxhYmxlVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBOdWxsYWJsZVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdWxsYWJsZVR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdOdWxsYWJsZVR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTnVsbGFibGVUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLnR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmFjY2VwdHMoaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bGxMaXRlcmFsVHlwZSB8fCBpbnB1dCBpbnN0YW5jZW9mIFZvaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bGxhYmxlVHlwZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKHRoaXMudHlwZSwgaW5wdXQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgPyAke3RoaXMudHlwZS50b1N0cmluZygpfWA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bGxhYmxlVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBPYmplY3RUeXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoT2JqZWN0VHlwZVByb3BlcnR5LCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0VHlwZVByb3BlcnR5KCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFR5cGVQcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBPYmplY3RUeXBlUHJvcGVydHkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3RUeXBlUHJvcGVydHkpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdPYmplY3RUeXBlUHJvcGVydHknLCBfdGhpc1snc3RhdGljJ10gPSBmYWxzZSwgX3RoaXMuY29uc3RyYWludHMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuICAvLyBJZ25vcmVcblxuXG4gIGNyZWF0ZUNsYXNzKE9iamVjdFR5cGVQcm9wZXJ0eSwgW3tcbiAgICBrZXk6ICdhZGRDb25zdHJhaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29uc3RyYWludCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgY29uc3RyYWludHMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBjb25zdHJhaW50c1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBhZGRDb25zdHJhaW50cy5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY29uc3RyYWludHMpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgcHJvcGVydHkgaXMgbnVsbGFibGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzTnVsbGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc051bGxhYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgaW5zdGFuY2VvZiBOdWxsYWJsZVR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgZ2l2ZW4gaW5wdXQgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZXhpc3RzT24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGlzdHNPbihpbnB1dCkge1xuICAgICAgLy8gSWdub3JlXG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgaXNTdGF0aWMgPSB0aGlzLnN0YXRpYztcblxuICAgICAgcmV0dXJuIGtleSBpbiAoaXNTdGF0aWMgPyBpbnB1dC5jb25zdHJ1Y3RvciA6IGlucHV0KSA9PT0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICAgIHZhciBvcHRpb25hbCA9IHRoaXMub3B0aW9uYWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGlzU3RhdGljID0gdGhpcy5zdGF0aWM7XG5cbiAgICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgICB2YXIgdGFyZ2V0UGF0aCA9IHZvaWQgMDtcbiAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0UGF0aCA9IHBhdGguY29uY2F0KCdjb25zdHJ1Y3RvcicpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgICAgICAgeWllbGQgW3RhcmdldFBhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9GVU5DVElPTicpLCB0aGlzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFBhdGgucHVzaChrZXkpO1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5jb25zdHJ1Y3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXRba2V5XTtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IHBhdGguY29uY2F0KGtleSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uYWwgJiYgdGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNOdWxsYWJsZSgpICYmICF0aGlzLmV4aXN0c09uKGlucHV0KSkge1xuICAgICAgICB5aWVsZCBbdGFyZ2V0UGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfTUlTU0lOR19QUk9QRVJUWScpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbHVlLmVycm9ycyh2YWxpZGF0aW9uLCB0YXJnZXRQYXRoLCB0YXJnZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICB5aWVsZCBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRXJyb3JzKSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0Q29uc3RyYWludEVycm9ycyh0aGlzLCB2YWxpZGF0aW9uLCB0YXJnZXRQYXRoLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICAgIHZhciBvcHRpb25hbCA9IHRoaXMub3B0aW9uYWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGlzU3RhdGljID0gdGhpcy5zdGF0aWM7XG5cbiAgICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuY29uc3RydWN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0W2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25hbCAmJiB0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOdWxsYWJsZSgpICYmICF0aGlzLmV4aXN0c09uKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsdWUuYWNjZXB0cyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50c0FjY2VwdCh0aGlzLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0VHlwZVByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LmtleSAhPT0gdGhpcy5rZXkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnZhbHVlLCBpbnB1dC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleTtcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGtleSA9IGBbJHtrZXkudG9TdHJpbmcoKX1dYDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRpYykge1xuICAgICAgICByZXR1cm4gYHN0YXRpYyAke2tleX0ke3RoaXMub3B0aW9uYWwgPyAnPycgOiAnJ306ICR7dGhpcy52YWx1ZS50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX0ke3RoaXMub3B0aW9uYWwgPyAnPycgOiAnJ306ICR7dGhpcy52YWx1ZS50b1N0cmluZygpfTtgO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgb3B0aW9uYWw6IHRoaXMub3B0aW9uYWxcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPYmplY3RUeXBlUHJvcGVydHk7XG59KFR5cGUpO1xuXG52YXIgT2JqZWN0VHlwZUluZGV4ZXIgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoT2JqZWN0VHlwZUluZGV4ZXIsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBPYmplY3RUeXBlSW5kZXhlcigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RUeXBlSW5kZXhlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBPYmplY3RUeXBlSW5kZXhlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdFR5cGVJbmRleGVyKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnT2JqZWN0VHlwZUluZGV4ZXInLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT2JqZWN0VHlwZUluZGV4ZXIsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBrZXksIHZhbHVlKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgbnVtYmVyIHR5cGVzXG4gICAgICBpZiAodGhpcy5rZXkudHlwZU5hbWUgPT09ICdOdW1iZXJUeXBlJyB8fCB0aGlzLmtleS50eXBlTmFtZSA9PT0gJ051bWVyaWNMaXRlcmFsVHlwZScpIHtcbiAgICAgICAga2V5ID0gK2tleTtcbiAgICAgIH1cblxuICAgICAgeWllbGQqIHRoaXMua2V5LmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLmNvbmNhdCgnW1tLZXldXScpLCBrZXkpO1xuICAgICAgeWllbGQqIHRoaXMudmFsdWUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGguY29uY2F0KGtleSksIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuYWNjZXB0cyh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c0tleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNLZXkoa2V5KSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgbnVtYmVyIHR5cGVzXG4gICAgICBpZiAodGhpcy5rZXkudHlwZU5hbWUgPT09ICdOdW1iZXJUeXBlJyB8fCB0aGlzLmtleS50eXBlTmFtZSA9PT0gJ051bWVyaWNMaXRlcmFsVHlwZScpIHtcbiAgICAgICAga2V5ID0gK2tleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmtleS5hY2NlcHRzKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c1ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c1ZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5hY2NlcHRzKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlUHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleS5hY2NlcHRzKGlucHV0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnZhbHVlLCBpbnB1dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE9iamVjdFR5cGVJbmRleGVyKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlSZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy5rZXksIGlucHV0LmtleSk7XG4gICAgICBpZiAoa2V5UmVzdWx0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVSZXN1bHQgPSBjb21wYXJlVHlwZXModGhpcy52YWx1ZSwgaW5wdXQudmFsdWUpO1xuICAgICAgaWYgKHZhbHVlUmVzdWx0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlSZXN1bHQgPT09IDAgJiYgdmFsdWVSZXN1bHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGBbJHt0aGlzLmlkfTogJHt0aGlzLmtleS50b1N0cmluZygpfV06ICR7dGhpcy52YWx1ZS50b1N0cmluZygpfTtgO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPYmplY3RUeXBlSW5kZXhlcjtcbn0oVHlwZSk7XG5cbnZhciBPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE9iamVjdFR5cGVDYWxsUHJvcGVydHksIF9UeXBlKTtcblxuICBmdW5jdGlvbiBPYmplY3RUeXBlQ2FsbFByb3BlcnR5KCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFR5cGVDYWxsUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdFR5cGVDYWxsUHJvcGVydHkpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdPYmplY3RUeXBlQ2FsbFByb3BlcnR5JywgX3RoaXNbJ3N0YXRpYyddID0gZmFsc2UsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cbiAgLy8gSWdub3JlXG5cblxuICBjcmVhdGVDbGFzcyhPYmplY3RUeXBlQ2FsbFByb3BlcnR5LCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBpc1N0YXRpYyA9IHRoaXMuc3RhdGljO1xuXG5cbiAgICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgICB2YXIgdGFyZ2V0UGF0aCA9IHZvaWQgMDtcbiAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0UGF0aCA9IHBhdGguY29uY2F0KCdjb25zdHJ1Y3RvcicpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeWllbGQgW3RhcmdldFBhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9GVU5DVElPTicpLCB0aGlzXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuY29uc3RydWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dDtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IHBhdGg7XG4gICAgICB9XG4gICAgICB5aWVsZCogdmFsdWUuZXJyb3JzKHZhbGlkYXRpb24sIHRhcmdldFBhdGgsIHRhcmdldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBpc1N0YXRpYyA9IHRoaXMuc3RhdGljO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGlucHV0LmNvbnN0cnVjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUuYWNjZXB0cyh0YXJnZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnZhbHVlLCBpbnB1dC52YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRpYykge1xuICAgICAgICByZXR1cm4gYHN0YXRpYyAke3RoaXMudmFsdWUudG9TdHJpbmcoKX07YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbn0oVHlwZSk7XG5cbnZhciBEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhEZWNsYXJhdGlvbiwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIERlY2xhcmF0aW9uKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlY2xhcmF0aW9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGVjbGFyYXRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEZWNsYXJhdGlvbikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIERlY2xhcmF0aW9uO1xufShUeXBlKTtcblxudmFyIFZhckRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKF9EZWNsYXJhdGlvbikge1xuICBpbmhlcml0cyhWYXJEZWNsYXJhdGlvbiwgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBWYXJEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWYXJEZWNsYXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBWYXJEZWNsYXJhdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZhckRlY2xhcmF0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVmFyRGVjbGFyYXRpb24nLCBfdGhpcy5jb25zdHJhaW50cyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVmFyRGVjbGFyYXRpb24sIFt7XG4gICAga2V5OiAnYWRkQ29uc3RyYWludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbnN0cmFpbnRzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgY29uc3RyYWludHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgYWRkQ29uc3RyYWludHMuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNvbnN0cmFpbnRzKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNFcnJvcnMpIHtcbiAgICAgICAgeWllbGQqIGNvbGxlY3RDb25zdHJhaW50RXJyb3JzKHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmICghdHlwZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFjb25zdHJhaW50c0FjY2VwdCh0aGlzLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYGRlY2xhcmUgdmFyICR7dGhpcy5uYW1lfTogJHt0aGlzLnR5cGUudG9TdHJpbmcoKX07YDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZhckRlY2xhcmF0aW9uO1xufShEZWNsYXJhdGlvbik7XG5cbnZhciBUeXBlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKFR5cGVEZWNsYXJhdGlvbiwgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBUeXBlRGVjbGFyYXRpb24oKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZURlY2xhcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFR5cGVEZWNsYXJhdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGVEZWNsYXJhdGlvbikpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R5cGVEZWNsYXJhdGlvbicsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUeXBlRGVjbGFyYXRpb24sIFt7XG4gICAga2V5OiAnYWRkQ29uc3RyYWludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQoKSB7XG4gICAgICB2YXIgX3R5cGVBbGlhcztcblxuICAgICAgKF90eXBlQWxpYXMgPSB0aGlzLnR5cGVBbGlhcykuYWRkQ29uc3RyYWludC5hcHBseShfdHlwZUFsaWFzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZUFsaWFzLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciBfdHlwZUFsaWFzMjtcblxuICAgICAgcmV0dXJuIChfdHlwZUFsaWFzMiA9IHRoaXMudHlwZUFsaWFzKS5hcHBseS5hcHBseShfdHlwZUFsaWFzMiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZUFsaWFzLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy50eXBlQWxpYXMsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG5hbWUpIHtcbiAgICAgIHZhciBfdHlwZUFsaWFzMztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90eXBlQWxpYXMzID0gdGhpcy50eXBlQWxpYXMpLmhhc1Byb3BlcnR5LmFwcGx5KF90eXBlQWxpYXMzLCBbbmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgX3R5cGVBbGlhczQ7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdHlwZUFsaWFzNCA9IHRoaXMudHlwZUFsaWFzKS5nZXRQcm9wZXJ0eS5hcHBseShfdHlwZUFsaWFzNCwgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIF90eXBlQWxpYXM1O1xuXG4gICAgICByZXR1cm4gKF90eXBlQWxpYXM1ID0gdGhpcy50eXBlQWxpYXMpLnVud3JhcC5hcHBseShfdHlwZUFsaWFzNSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGBkZWNsYXJlICR7dGhpcy50eXBlQWxpYXMudG9TdHJpbmcodHJ1ZSl9O2A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlQWxpYXMudHlwZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVEZWNsYXJhdGlvbjtcbn0oRGVjbGFyYXRpb24pO1xuXG52YXIgTW9kdWxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKE1vZHVsZURlY2xhcmF0aW9uLCBfRGVjbGFyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIE1vZHVsZURlY2xhcmF0aW9uKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZURlY2xhcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE1vZHVsZURlY2xhcmF0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9kdWxlRGVjbGFyYXRpb24pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdNb2R1bGVEZWNsYXJhdGlvbicsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNb2R1bGVEZWNsYXJhdGlvbiwgW3tcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEobmFtZSkge1xuICAgICAgdmFyIG1vZHVsZUV4cG9ydHMgPSB0aGlzLm1vZHVsZUV4cG9ydHM7XG5cbiAgICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIHZhciBleHBvcnRpbmcgPSBtb2R1bGVFeHBvcnRzLnVud3JhcCgpO1xuICAgICAgICBpZiAodHlwZW9mIGV4cG9ydGluZy5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBwcm9wID0gZXhwb3J0aW5nLmdldFByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcC51bndyYXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMuZGVjbGFyYXRpb25zW25hbWVdO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb24udW53cmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICAvLyBDYW4ndCB2YWxpZGF0ZSBhIG1vZHVsZSBkaXJlY3RseS5cbiAgICAgIC8vIEB0b2RvIHNob3VsZCB0aGlzIHRocm93P1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbXBvcnQobW9kdWxlTmFtZSkge1xuICAgICAgaWYgKC9eXFwuXFwvLy50ZXN0KG1vZHVsZU5hbWUpKSB7XG4gICAgICAgIG1vZHVsZU5hbWUgPSBgJHt0aGlzLm5hbWV9JHttb2R1bGVOYW1lLnNsaWNlKDEpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbm5lckNvbnRleHQuaW1wb3J0KG1vZHVsZU5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgICBkZWNsYXJhdGlvbnMgPSB0aGlzLmRlY2xhcmF0aW9ucyxcbiAgICAgICAgICBtb2R1bGVzID0gdGhpcy5tb2R1bGVzLFxuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSB0aGlzLm1vZHVsZUV4cG9ydHM7XG5cbiAgICAgIHZhciBib2R5ID0gW107XG4gICAgICBmb3IgKHZhciBfbmFtZSBpbiBkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW19uYW1lXTtcbiAgICAgICAgYm9keS5wdXNoKGRlY2xhcmF0aW9uLnRvU3RyaW5nKHRydWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGVzKSB7XG4gICAgICAgIGZvciAodmFyIF9uYW1lMiBpbiBtb2R1bGVzKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tfbmFtZTJdO1xuICAgICAgICAgIGJvZHkucHVzaChtb2R1bGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIGJvZHkucHVzaChtb2R1bGVFeHBvcnRzLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBkZWNsYXJlIG1vZHVsZSBcIiR7bmFtZX1cIiB7XFxuJHtpbmRlbnQkMShib2R5LmpvaW4oJ1xcblxcbicpKX19YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb2R1bGVUeXBlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLm1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuICdjb21tb25qcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2VzNic7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNDb21tb25KUycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVFeHBvcnRzID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzRVM2JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZUV4cG9ydHMgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjbGFyYXRpb25zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciBpbm5lckNvbnRleHQgPSB0aGlzLmlubmVyQ29udGV4dDtcblxuICAgICAgcmV0dXJuIGlubmVyQ29udGV4dFtOYW1lUmVnaXN0cnlTeW1ib2xdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21vZHVsZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIGlubmVyQ29udGV4dCA9IHRoaXMuaW5uZXJDb250ZXh0O1xuXG4gICAgICByZXR1cm4gaW5uZXJDb250ZXh0W01vZHVsZVJlZ2lzdHJ5U3ltYm9sXTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1vZHVsZURlY2xhcmF0aW9uO1xufShEZWNsYXJhdGlvbik7XG5cbmZ1bmN0aW9uIGluZGVudCQxKGlucHV0KSB7XG4gIHZhciBsaW5lcyA9IGlucHV0LnNwbGl0KCdcXG4nKTtcbiAgdmFyIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGluZXNbaV0gPSBgICAke2xpbmVzW2ldfWA7XG4gIH1cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG52YXIgTW9kdWxlRXhwb3J0cyA9IGZ1bmN0aW9uIChfRGVjbGFyYXRpb24pIHtcbiAgaW5oZXJpdHMoTW9kdWxlRXhwb3J0cywgX0RlY2xhcmF0aW9uKTtcblxuICBmdW5jdGlvbiBNb2R1bGVFeHBvcnRzKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZUV4cG9ydHMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTW9kdWxlRXhwb3J0cy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1vZHVsZUV4cG9ydHMpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdNb2R1bGVFeHBvcnRzJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1vZHVsZUV4cG9ydHMsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgeWllbGQqIHRoaXMudHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0czogJHt0aGlzLnR5cGUudG9TdHJpbmcoKX07YDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1vZHVsZUV4cG9ydHM7XG59KERlY2xhcmF0aW9uKTtcblxudmFyIENsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKENsYXNzRGVjbGFyYXRpb24sIF9EZWNsYXJhdGlvbik7XG5cbiAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbGFzc0RlY2xhcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IENsYXNzRGVjbGFyYXRpb24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGFzc0RlY2xhcmF0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnQ2xhc3NEZWNsYXJhdGlvbicsIF90aGlzLnNoYXBlSUQgPSBTeW1ib2woKSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKENsYXNzRGVjbGFyYXRpb24sIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHk7XG5cbiAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcy5zdXBlckNsYXNzICYmIHRoaXMuc3VwZXJDbGFzcy51bndyYXAoKTtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0lOU1RBTkNFT0YnLCB0aGlzLm5hbWUpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gc3VwZXJDbGFzcy5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9yZWYyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBfcmVmMyA9IHNsaWNlZFRvQXJyYXkoX3JlZjIsIDMpO1xuXG4gICAgICAgICAgICB2YXIgZXJyb3JQYXRoID0gX3JlZjNbMF07XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gX3JlZjNbMV07XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gX3JlZjNbMl07XG5cbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBlcnJvclBhdGhbcGF0aC5sZW5ndGhdO1xuICAgICAgICAgICAgaWYgKGJvZHkuZ2V0UHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIFtlcnJvclBhdGgsIGVycm9yTWVzc2FnZSwgZXhwZWN0ZWRUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCogYm9keS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcblxuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzLnN1cGVyQ2xhc3MgJiYgdGhpcy5zdXBlckNsYXNzLnVud3JhcCgpO1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwZXJDbGFzcyAmJiAhc3VwZXJDbGFzcy5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFib2R5LmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1N1cGVyQ2xhc3NPZihpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy5ib2R5LCBpbnB1dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHksXG4gICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuc3VwZXJDbGFzcztcblxuICAgICAgdmFyIHByb3AgPSBib2R5LmdldFByb3BlcnR5KGtleSk7XG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH0gZWxzZSBpZiAoc3VwZXJDbGFzcyAmJiB0eXBlb2Ygc3VwZXJDbGFzcy5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc3VwZXJDbGFzcy5nZXRQcm9wZXJ0eShrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkoa2V5KSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuYm9keSxcbiAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5zdXBlckNsYXNzO1xuXG4gICAgICBpZiAoYm9keS5oYXNQcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdXBlckNsYXNzICYmIHR5cGVvZiBzdXBlckNsYXNzLmhhc1Byb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzdXBlckNsYXNzLmhhc1Byb3BlcnR5KGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBjbGFzcyBkZWNsYXJhdGlvbiByZXByZXNlbnRzIGEgc3VwZXIgY2xhc3Mgb2ZcbiAgICAgKiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTdXBlckNsYXNzT2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cGVyQ2xhc3NPZihjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgICAgIHNoYXBlSUQgPSB0aGlzLnNoYXBlSUQ7XG5cbiAgICAgIHZhciBjdXJyZW50ID0gY2FuZGlkYXRlO1xuXG4gICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzIHx8IGN1cnJlbnQgPT09IGJvZHkgfHwgY3VycmVudC5zaGFwZUlEID09PSBzaGFwZUlEKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBDbGFzc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3VwZXJDbGFzcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC51bndyYXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuc3VwZXJDbGFzcyxcbiAgICAgICAgICBib2R5ID0gdGhpcy5ib2R5O1xuXG4gICAgICBpZiAod2l0aERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHZhciBzdXBlckNsYXNzTmFtZSA9IHN1cGVyQ2xhc3MgJiYgKHR5cGVvZiBzdXBlckNsYXNzLm5hbWUgPT09ICdzdHJpbmcnICYmIHN1cGVyQ2xhc3MubmFtZSB8fCBzdXBlckNsYXNzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gYGRlY2xhcmUgY2xhc3MgJHtuYW1lfSR7c3VwZXJDbGFzc05hbWUgPyBgIGV4dGVuZHMgJHtzdXBlckNsYXNzTmFtZX1gIDogJyd9ICR7Ym9keS50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wZXJ0aWVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5LFxuICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLnN1cGVyQ2xhc3M7XG5cbiAgICAgIGlmIChzdXBlckNsYXNzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkucHJvcGVydGllcztcbiAgICAgIH1cbiAgICAgIHZhciBib2R5UHJvcHMgPSBib2R5LnByb3BlcnRpZXM7XG4gICAgICB2YXIgc3VwZXJQcm9wcyA9IHN1cGVyQ2xhc3MudW53cmFwKCkucHJvcGVydGllcztcbiAgICAgIGlmIChzdXBlclByb3BzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJvZHlQcm9wcztcbiAgICAgIH1cbiAgICAgIHZhciBzZWVuID0ge307XG4gICAgICB2YXIgc2VlblN0YXRpYyA9IHt9O1xuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cGVyUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBzdXBlclByb3BzW2ldO1xuICAgICAgICBwcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICBpZiAocHJvcC5zdGF0aWMpIHtcbiAgICAgICAgICBzZWVuU3RhdGljW3Byb3Aua2V5XSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbltwcm9wLmtleV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm9keVByb3BzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3Byb3AgPSBib2R5UHJvcHNbX2ldO1xuICAgICAgICBpZiAoc2VlbltfcHJvcC5rZXldKSB7XG4gICAgICAgICAgcHJvcHNbX2ldID0gX3Byb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHMucHVzaChfcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XG59KERlY2xhcmF0aW9uKTtcblxudmFyIFBhcnRpYWxUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFBhcnRpYWxUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gUGFydGlhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFydGlhbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gUGFydGlhbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXJ0aWFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1BhcnRpYWxUeXBlJywgX3RoaXMudHlwZVBhcmFtZXRlcnMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBhcnRpYWxUeXBlLCBbe1xuICAgIGtleTogJ3R5cGVQYXJhbWV0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlUGFyYW1ldGVyKGlkLCBib3VuZCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlcih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LmlkID0gaWQ7XG4gICAgICB0YXJnZXQuYm91bmQgPSBib3VuZDtcbiAgICAgIHRhcmdldC5kZWZhdWx0ID0gZGVmYXVsdFR5cGU7XG4gICAgICB0aGlzLnR5cGVQYXJhbWV0ZXJzLnB1c2godGFyZ2V0KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMsXG4gICAgICAgICAgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgeWllbGQgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0Vycm9ycyAmJiBjb25zdHJhaW50cykge1xuICAgICAgICB5aWVsZCogY29sbGVjdENvbnN0cmFpbnRFcnJvcnModGhpcywgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmICghdHlwZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzICYmICFjb25zdHJhaW50c0FjY2VwdCh0aGlzLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGV4cGFuZCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHJldHVybiB0eXBlLnRvU3RyaW5nKGV4cGFuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlUGFyYW1ldGVyczogdGhpcy50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFydGlhbFR5cGU7XG59KFR5cGUpO1xuXG52YXIgUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoX0RlY2xhcmF0aW9uKSB7XG4gIGluaGVyaXRzKFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uLCBfRGVjbGFyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24pKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbicsIF90aGlzLnNoYXBlSUQgPSBTeW1ib2woKSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBhcmFtZXRlcml6ZWRDbGFzc0RlY2xhcmF0aW9uLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yID4gMyA/IF9sZW4yIC0gMyA6IDApLCBfa2V5MiA9IDM7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MiAtIDNdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgeWllbGQqIGdldFBhcnRpYWwuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UGFydGlhbC5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCh0aGlzKS5jb21wYXJlV2l0aChpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UGFydGlhbC5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKS50eXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzU3VwZXJDbGFzc09mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBlckNsYXNzT2YoY2FuZGlkYXRlKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCh0aGlzKS50eXBlLmlzU3VwZXJDbGFzc09mKGNhbmRpZGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXBwbHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHlwZVBhcmFtZXRlckFwcGxpY2F0aW9uKHRoaXMuY29udGV4dCk7XG4gICAgICB0YXJnZXQucGFyZW50ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcod2l0aERlY2xhcmF0aW9uKSB7XG4gICAgICBpZiAoIXdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnRpYWwgPSBnZXRQYXJ0aWFsKHRoaXMpO1xuICAgICAgdmFyIHR5cGUgPSBwYXJ0aWFsLnR5cGUsXG4gICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJ0aWFsLnR5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsLnRvU3RyaW5nKHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcnNbaV07XG4gICAgICAgIGl0ZW1zLnB1c2godHlwZVBhcmFtZXRlci50b1N0cmluZyh0cnVlKSk7XG4gICAgICB9XG4gICAgICB2YXIgc3VwZXJDbGFzcyA9IHR5cGUuc3VwZXJDbGFzcyxcbiAgICAgICAgICBib2R5ID0gdHlwZS5ib2R5O1xuXG4gICAgICB2YXIgc3VwZXJDbGFzc05hbWUgPSBzdXBlckNsYXNzICYmICh0eXBlb2Ygc3VwZXJDbGFzcy5uYW1lID09PSAnc3RyaW5nJyAmJiBzdXBlckNsYXNzLm5hbWUgfHwgc3VwZXJDbGFzcy50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBgZGVjbGFyZSBjbGFzcyAke3RoaXMubmFtZX08JHtpdGVtcy5qb2luKCcsICcpfT4ke3N1cGVyQ2xhc3NOYW1lID8gYCBleHRlbmRzICR7c3VwZXJDbGFzc05hbWV9YCA6ICcnfSAke2JvZHkudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsKHRoaXMpLnRvSlNPTigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N1cGVyQ2xhc3MnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwodGhpcykudHlwZS5zdXBlckNsYXNzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JvZHknLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwodGhpcykudHlwZS5ib2R5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwodGhpcykudHlwZS5wcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGVQYXJhbWV0ZXJzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsKHRoaXMpLnR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb247XG59KERlY2xhcmF0aW9uKTtcblxuZnVuY3Rpb24gZ2V0UGFydGlhbChwYXJlbnQpIHtcbiAgdmFyIGNvbnRleHQgPSBwYXJlbnQuY29udGV4dCxcbiAgICAgIGJvZHlDcmVhdG9yID0gcGFyZW50LmJvZHlDcmVhdG9yO1xuXG4gIHZhciBwYXJ0aWFsID0gbmV3IFBhcnRpYWxUeXBlKGNvbnRleHQpO1xuICB2YXIgYm9keSA9IGJvZHlDcmVhdG9yKHBhcnRpYWwpO1xuICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgIHBhcnRpYWwudHlwZSA9IGNvbnRleHQuY2xhc3MuYXBwbHkoY29udGV4dCwgW3BhcmVudC5uYW1lXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYm9keSkpKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0aWFsLnR5cGUgPSBjb250ZXh0LmNsYXNzKHBhcmVudC5uYW1lLCBib2R5KTtcbiAgfVxuXG4gIHBhcnRpYWwudHlwZS5zaGFwZUlEID0gcGFyZW50LnNoYXBlSUQ7XG5cbiAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gcGFydGlhbC50eXBlUGFyYW1ldGVycztcblxuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgdHlwZUluc3RhbmNlc1tfa2V5NiAtIDFdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIHZhciBsaW1pdCA9IE1hdGgubWluKHR5cGVJbnN0YW5jZXMubGVuZ3RoLCB0eXBlUGFyYW1ldGVycy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgIHZhciB0eXBlSW5zdGFuY2UgPSB0eXBlSW5zdGFuY2VzW2ldO1xuICAgIGlmICh0eXBlUGFyYW1ldGVyLmJvdW5kICYmIHR5cGVQYXJhbWV0ZXIuYm91bmQgIT09IHR5cGVJbnN0YW5jZSkge1xuICAgICAgLy8gaWYgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIGFscmVhZHkgYm91bmQgd2UgbmVlZCB0b1xuICAgICAgLy8gY3JlYXRlIGFuIGludGVyc2VjdGlvbiB0eXBlIHdpdGggdGhpcyBvbmUuXG4gICAgICB0eXBlUGFyYW1ldGVyLmJvdW5kID0gY29udGV4dC5pbnRlcnNlY3QodHlwZVBhcmFtZXRlci5ib3VuZCwgdHlwZUluc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVBhcmFtZXRlci5ib3VuZCA9IHR5cGVJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydGlhbDtcbn1cblxudmFyIEV4dGVuZHNEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChfRGVjbGFyYXRpb24pIHtcbiAgaW5oZXJpdHMoRXh0ZW5kc0RlY2xhcmF0aW9uLCBfRGVjbGFyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIEV4dGVuZHNEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFeHRlbmRzRGVjbGFyYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gRXh0ZW5kc0RlY2xhcmF0aW9uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXh0ZW5kc0RlY2xhcmF0aW9uKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnRXh0ZW5kc0RlY2xhcmF0aW9uJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEV4dGVuZHNEZWNsYXJhdGlvbiwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHdpdGhEZWNsYXJhdGlvbikge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmICh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGBleHRlbmRzICR7dHlwZS50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRXh0ZW5kc0RlY2xhcmF0aW9uO1xufShEZWNsYXJhdGlvbik7XG5cbnZhciBPYmplY3RUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE9iamVjdFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBPYmplY3RUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gT2JqZWN0VHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdPYmplY3RUeXBlJywgX3RoaXMucHJvcGVydGllcyA9IFtdLCBfdGhpcy5pbmRleGVycyA9IFtdLCBfdGhpcy5jYWxsUHJvcGVydGllcyA9IFtdLCBfdGhpcy5leGFjdCA9IGZhbHNlLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT2JqZWN0VHlwZSwgW3tcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAocHJvcGVydHkua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEluZGV4ZXIoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvcHRpb25hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgbmV3UHJvcCA9IG5ldyBPYmplY3RUeXBlUHJvcGVydHkoY29udGV4dCk7XG4gICAgICBuZXdQcm9wLmtleSA9IGtleTtcbiAgICAgIG5ld1Byb3AudmFsdWUgPSB2YWx1ZTtcbiAgICAgIG5ld1Byb3Aub3B0aW9uYWwgPSBvcHRpb25hbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAocHJvcGVydHkua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzW2ldID0gbmV3UHJvcDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3BlcnRpZXMucHVzaChuZXdQcm9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KGtleSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhc0luZGV4ZXIoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaW5kZXhlciB3aXRoIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGtleSB0eXBlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJbmRleGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXhlcihrZXkpIHtcbiAgICAgIHZhciBpbmRleGVycyA9IHRoaXMuaW5kZXhlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gaW5kZXhlcnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleGVyID0gaW5kZXhlcnNbaV07XG4gICAgICAgIGlmIChpbmRleGVyLmFjY2VwdHNLZXkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYW4gaW5kZXhlciBleGlzdHMgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4ga2V5IHR5cGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhc0luZGV4ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNJbmRleGVyKGtleSkge1xuICAgICAgdmFyIGluZGV4ZXJzID0gdGhpcy5pbmRleGVycztcbiAgICAgIHZhciBsZW5ndGggPSBpbmRleGVycy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ZXIgPSBpbmRleGVyc1tpXTtcbiAgICAgICAgaWYgKGluZGV4ZXIuYWNjZXB0c0tleShrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0NhbGxQcm9wZXJ0aWVzID0gdGhpcy5jYWxsUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoaGFzQ2FsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCFhY2NlcHRzQ2FsbFByb3BlcnRpZXModGhpcywgaW5wdXQpKSB7XG4gICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9DQUxMQUJMRScpLCB0aGlzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfT0JKRUNUJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZGF0aW9uLmluQ3ljbGUodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRpb24uc3RhcnRDeWNsZSh0aGlzLCBpbnB1dCk7XG5cbiAgICAgIGlmICh0aGlzLmluZGV4ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0ICYmIEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9PQkpFQ1QnKSwgdGhpc107XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0RXJyb3JzV2l0aEluZGV4ZXJzKHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0RXJyb3JzV2l0aG91dEluZGV4ZXJzKHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICAgIHlpZWxkKiBjb2xsZWN0RXJyb3JzRXhhY3QodGhpcywgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGlvbi5lbmRDeWNsZSh0aGlzLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQ2FsbFByb3BlcnRpZXMgPSB0aGlzLmNhbGxQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmIChoYXNDYWxsUHJvcGVydGllcykge1xuICAgICAgICBpZiAoIWFjY2VwdHNDYWxsUHJvcGVydGllcyh0aGlzLCBpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaW5WYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3RhcnRWYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMuaW5kZXhlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQgPSBhY2NlcHRzV2l0aEluZGV4ZXJzKHRoaXMsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFjY2VwdHNXaXRob3V0SW5kZXhlcnModGhpcywgaW5wdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmV4YWN0KSB7XG4gICAgICAgIHJlc3VsdCA9IGFjY2VwdHNFeGFjdCh0aGlzLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBlbmRWYWxpZGF0aW9uQ3ljbGUodGhpcywgaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE9iamVjdFR5cGUgfHwgaW5wdXQgaW5zdGFuY2VvZiBDbGFzc0RlY2xhcmF0aW9uIHx8IGlucHV0IGluc3RhbmNlb2YgUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDYWxsUHJvcGVydGllcyA9IHRoaXMuY2FsbFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgICAgdmFyIGlzR3JlYXRlciA9IGZhbHNlO1xuICAgICAgaWYgKGhhc0NhbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBfcmVzdWx0ID0gY29tcGFyZVR5cGVDYWxsUHJvcGVydGllcyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIGlmIChfcmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChfcmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgaXNHcmVhdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMuaW5kZXhlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJlVHlwZVdpdGhJbmRleGVycyh0aGlzLCBpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJlVHlwZVdpdGhvdXRJbmRleGVycyh0aGlzLCBpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoaXNHcmVhdGVyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNhbGxQcm9wZXJ0aWVzID0gdGhpcy5jYWxsUHJvcGVydGllcyxcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGluZGV4ZXJzID0gdGhpcy5pbmRleGVycztcblxuICAgICAgaWYgKGluVG9TdHJpbmdDeWNsZSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gJyRDeWNsZTxPYmplY3Q+JztcbiAgICAgIH1cbiAgICAgIHN0YXJ0VG9TdHJpbmdDeWNsZSh0aGlzKTtcbiAgICAgIHZhciBib2R5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvZHkucHVzaChjYWxsUHJvcGVydGllc1tpXS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBib2R5LnB1c2gocHJvcGVydGllc1tfaV0udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmRleGVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGJvZHkucHVzaChpbmRleGVyc1tfaTJdLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgZW5kVG9TdHJpbmdDeWNsZSh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICAgIHJldHVybiBge3xcXG4ke2luZGVudChib2R5LmpvaW4oJ1xcbicpKX1cXG58fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYHtcXG4ke2luZGVudChib2R5LmpvaW4oJ1xcbicpKX1cXG59YDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgY2FsbFByb3BlcnRpZXM6IHRoaXMuY2FsbFByb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllcyxcbiAgICAgICAgaW5kZXhlcnM6IHRoaXMuaW5kZXhlcnMsXG4gICAgICAgIGV4YWN0OiB0aGlzLmV4YWN0XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JqZWN0VHlwZTtcbn0oVHlwZSk7XG5cbmZ1bmN0aW9uIGFjY2VwdHNDYWxsUHJvcGVydGllcyh0eXBlLCBpbnB1dCkge1xuICB2YXIgY2FsbFByb3BlcnRpZXMgPSB0eXBlLmNhbGxQcm9wZXJ0aWVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2FsbFByb3BlcnR5ID0gY2FsbFByb3BlcnRpZXNbaV07XG4gICAgaWYgKGNhbGxQcm9wZXJ0eS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVR5cGVDYWxsUHJvcGVydGllcyh0eXBlLCBpbnB1dCkge1xuICB2YXIgY2FsbFByb3BlcnRpZXMgPSB0eXBlLmNhbGxQcm9wZXJ0aWVzO1xuXG4gIHZhciBpbnB1dENhbGxQcm9wZXJ0aWVzID0gaW5wdXQuY2FsbFByb3BlcnRpZXM7XG4gIHZhciBpZGVudGljYWxDb3VudCA9IDA7XG4gIGxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2FsbFByb3BlcnR5ID0gY2FsbFByb3BlcnRpZXNbaV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0Q2FsbFByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbnB1dENhbGxQcm9wZXJ0eSA9IGlucHV0Q2FsbFByb3BlcnRpZXNbal07XG4gICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZVR5cGVzKGNhbGxQcm9wZXJ0eSwgaW5wdXRDYWxsUHJvcGVydHkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICBpZGVudGljYWxDb3VudCsrO1xuICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyLCBub3RoaW5nIGFjY2VwdGVkLlxuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoaWRlbnRpY2FsQ291bnQgPT09IGNhbGxQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY2VwdHNXaXRoSW5kZXhlcnModHlwZSwgaW5wdXQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXMsXG4gICAgICBpbmRleGVycyA9IHR5cGUuaW5kZXhlcnM7XG5cbiAgdmFyIHNlZW4gPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICBpZiAoIXByb3BlcnR5LmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlZW4ucHVzaChwcm9wZXJ0eS5rZXkpO1xuICB9XG4gIGxvb3A6IGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgIGlmIChzZWVuLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGluZGV4ZXJzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBpbmRleGVyID0gaW5kZXhlcnNbX2kzXTtcbiAgICAgIGlmIChpbmRleGVyLmFjY2VwdHNLZXkoa2V5KSAmJiBpbmRleGVyLmFjY2VwdHNWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIgdGhlIGtleSAvIHZhbHVlIGRpZCBub3QgYWNjZXB0cyBhbnkgaW5kZXhlcnMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlVHlwZVdpdGhJbmRleGVycyh0eXBlLCBpbnB1dCkge1xuICB2YXIgaW5kZXhlcnMgPSB0eXBlLmluZGV4ZXJzLFxuICAgICAgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcblxuICB2YXIgaW5wdXRJbmRleGVycyA9IGlucHV0LmluZGV4ZXJzO1xuICB2YXIgaW5wdXRQcm9wZXJ0aWVzID0gaW5wdXQucHJvcGVydGllcztcbiAgdmFyIGlzR3JlYXRlciA9IGZhbHNlO1xuICBsb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRQcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5wdXRQcm9wZXJ0eSA9IGlucHV0UHJvcGVydGllc1tqXTtcbiAgICAgIGlmIChpbnB1dFByb3BlcnR5LmtleSA9PT0gcHJvcGVydHkua2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXMocHJvcGVydHksIGlucHV0UHJvcGVydHkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvb3A6IGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGluZGV4ZXJzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgaW5kZXhlciA9IGluZGV4ZXJzW19pNF07XG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGlucHV0SW5kZXhlcnMubGVuZ3RoOyBfaisrKSB7XG4gICAgICB2YXIgaW5wdXRJbmRleGVyID0gaW5wdXRJbmRleGVyc1tfal07XG4gICAgICB2YXIgX3Jlc3VsdDIgPSBjb21wYXJlVHlwZXMoaW5kZXhlciwgaW5wdXRJbmRleGVyKTtcbiAgICAgIGlmIChfcmVzdWx0MiA9PT0gMSkge1xuICAgICAgICBpc0dyZWF0ZXIgPSB0cnVlO1xuICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgfSBlbHNlIGlmIChfcmVzdWx0MiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIsIG5vdGhpbmcgYWNjZXB0ZWRcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIGlzR3JlYXRlciA/IDEgOiAwO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRzV2l0aG91dEluZGV4ZXJzKHR5cGUsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKCFwcm9wZXJ0eS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYWNjZXB0c0V4YWN0KHR5cGUsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGtleSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgaWYgKCFwcm9wZXJ0aWVzLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkua2V5ID09PSBrZXk7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICB2YXIgX3JldDIgPSBfbG9vcChrZXkpO1xuXG4gICAgaWYgKHR5cGVvZiBfcmV0MiA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUeXBlV2l0aG91dEluZGV4ZXJzKHR5cGUsIGlucHV0KSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuXG4gIHZhciBpbnB1dFByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICB2YXIgaXNHcmVhdGVyID0gZmFsc2U7XG4gIGxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbnB1dFByb3BlcnR5ID0gaW5wdXRQcm9wZXJ0aWVzW2pdO1xuICAgICAgaWYgKGlucHV0UHJvcGVydHkua2V5ID09PSBwcm9wZXJ0eS5rZXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyhwcm9wZXJ0eS52YWx1ZSwgaW5wdXRQcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICAgIGlzR3JlYXRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBpc0dyZWF0ZXIgPyAxIDogMDtcbn1cblxuZnVuY3Rpb24qIGNvbGxlY3RFcnJvcnNXaXRoSW5kZXhlcnModHlwZSwgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXMsXG4gICAgICBpbmRleGVycyA9IHR5cGUuaW5kZXhlcnM7XG5cbiAgdmFyIHNlZW4gPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICB5aWVsZCogcHJvcGVydHkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICBzZWVuLnB1c2gocHJvcGVydHkua2V5KTtcbiAgfVxuICBsb29wOiBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICBpZiAoc2Vlbi5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gaW5wdXRba2V5XTtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBpbmRleGVycy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgaW5kZXhlciA9IGluZGV4ZXJzW19pNV07XG4gICAgICBpZiAoaW5kZXhlci5hY2NlcHRzS2V5KGtleSkgJiYgaW5kZXhlci5hY2NlcHRzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZ290IHRoaXMgZmFyIHRoZSBrZXkgLyB2YWx1ZSB3YXMgbm90IGFjY2VwdGVkIGJ5IGFueSBpbmRleGVycy5cbiAgICB5aWVsZCBbcGF0aC5jb25jYXQoa2V5KSwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfTk9fSU5ERVhFUicpLCB0eXBlXTtcbiAgfVxufVxuXG5mdW5jdGlvbiogY29sbGVjdEVycm9yc1dpdGhvdXRJbmRleGVycyh0eXBlLCB2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIHlpZWxkKiBwcm9wZXJ0eS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uKiBjb2xsZWN0RXJyb3JzRXhhY3QodHlwZSwgdmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG5cbiAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uKiBfbG9vcDIoa2V5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICBpZiAoIXByb3BlcnRpZXMuc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eS5rZXkgPT09IGtleTtcbiAgICB9KSkge1xuICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX1VOS05PV05fS0VZJywga2V5KSwgdHlwZV07XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgIHlpZWxkKiBfbG9vcDIoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRlbnQoaW5wdXQpIHtcbiAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuICB2YXIgbGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBsaW5lc1tpXSA9IGAgICR7bGluZXNbaV19YDtcbiAgfVxuICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG59XG5cbnZhciBJbnRlcnNlY3Rpb25UeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKEludGVyc2VjdGlvblR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb25UeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyc2VjdGlvblR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gSW50ZXJzZWN0aW9uVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEludGVyc2VjdGlvblR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdJbnRlcnNlY3Rpb25UeXBlJywgX3RoaXMudHlwZXMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEludGVyc2VjdGlvblR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQqIHR5cGVzW2ldLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgICAgdmFyIHR5cGVzID0gdGhpcy50eXBlcztcbiAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IHR5cGUuZ2V0UHJvcGVydHkoa2V5KTtcbiAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZS5oYXNQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmhhc1Byb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoIXR5cGUuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgaWRlbnRpY2FsQ291bnQgPSAwO1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgSW50ZXJzZWN0aW9uVHlwZSkge1xuICAgICAgICB2YXIgaW5wdXRUeXBlcyA9IGlucHV0LnR5cGVzO1xuICAgICAgICBsb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0VHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlVHlwZXModHlwZSwgaW5wdXRUeXBlc1tpXSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlkZW50aWNhbENvdW50Kys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiBub3RoaW5nIGFjY2VwdGVkIHRoaXMgdHlwZS5cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkZW50aWNhbENvdW50ID09PSB0eXBlcy5sZW5ndGggPyAwIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3R5cGUgPSB0eXBlc1tfaV07XG4gICAgICAgICAgdmFyIF9yZXN1bHQgPSBjb21wYXJlVHlwZXMoX3R5cGUsIGlucHV0KTtcbiAgICAgICAgICBpZiAoX3Jlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9yZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgIGlkZW50aWNhbENvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGljYWxDb3VudCA9PT0gdHlwZXMubGVuZ3RoID8gMCA6IDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICB2YXIgY2FsbFByb3BlcnRpZXMgPSBbXTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgICB2YXIgaW5kZXhlcnMgPSBbXTtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXMsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldLnVud3JhcCgpO1xuICAgICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSBpbnRlcnNlY3Qgb2JqZWN0IHR5cGVzJyk7XG4gICAgICAgIGNhbGxQcm9wZXJ0aWVzLnB1c2guYXBwbHkoY2FsbFByb3BlcnRpZXMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUuY2FsbFByb3BlcnRpZXMpKTtcbiAgICAgICAgaW5kZXhlcnMucHVzaC5hcHBseShpbmRleGVycywgdG9Db25zdW1hYmxlQXJyYXkodHlwZS5pbmRleGVycykpO1xuICAgICAgICBtZXJnZVByb3BlcnRpZXMocHJvcGVydGllcywgdHlwZS5wcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZjIgPSBjb250ZXh0KS5vYmplY3QuYXBwbHkoX3JlZjIsIGNhbGxQcm9wZXJ0aWVzLmNvbmNhdChwcm9wZXJ0aWVzLCBpbmRleGVycykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlcy5qb2luKCcgJiAnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZXM6IHRoaXMudHlwZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnRlcnNlY3Rpb25UeXBlO1xufShUeXBlKTtcblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmRleChuYW1lLCBwcm9wZXJ0aWVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcm9wZXJ0aWVzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlUHJvcCA9IHNvdXJjZVtpXTtcbiAgICB2YXIgaW5kZXggPSBnZXRQcm9wZXJ0eUluZGV4KHR5cGVQcm9wLmtleSwgdGFyZ2V0KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0YXJnZXQucHVzaCh0eXBlUHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtpbmRleF0gPSB0eXBlUHJvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIE1peGVkVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhNaXhlZFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBNaXhlZFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWl4ZWRUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE1peGVkVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1peGVkVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ01peGVkVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNaXhlZFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge31cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNaXhlZFR5cGU7XG59KFR5cGUpO1xuXG52YXIgTnVtZXJpY0xpdGVyYWxUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE51bWVyaWNMaXRlcmFsVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIE51bWVyaWNMaXRlcmFsVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1lcmljTGl0ZXJhbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTnVtZXJpY0xpdGVyYWxUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtZXJpY0xpdGVyYWxUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnTnVtZXJpY0xpdGVyYWxUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE51bWVyaWNMaXRlcmFsVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5wdXQgIT09IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfRVhBQ1RfVkFMVUUnLCB2YWx1ZSksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgPT09IHRoaXMudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTnVtZXJpY0xpdGVyYWxUeXBlICYmIGlucHV0LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy52YWx1ZX1gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWVyaWNMaXRlcmFsVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBOdW1iZXJUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKE51bWJlclR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBOdW1iZXJUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlclR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gTnVtYmVyVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlclR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdOdW1iZXJUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE51bWJlclR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9OVU1CRVInKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE51bWJlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgTnVtZXJpY0xpdGVyYWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJUeXBlO1xufShUeXBlKTtcblxudmFyIFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMgPSBmdW5jdGlvbiAoX1R5cGVBbGlhcykge1xuICBpbmhlcml0cyhQYXJhbWV0ZXJpemVkVHlwZUFsaWFzLCBfVHlwZUFsaWFzKTtcblxuICBmdW5jdGlvbiBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gUGFyYW1ldGVyaXplZFR5cGVBbGlhcy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdQYXJhbWV0ZXJpemVkVHlwZUFsaWFzJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCogZ2V0UGFydGlhbCQxLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRpYWwgPSBnZXRQYXJ0aWFsJDEuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgICBpZiAoIXBhcnRpYWwuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghY29uc3RyYWludHNBY2NlcHQodGhpcywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gMDsgLy8gc2hvdWxkIG5ldmVyIG5lZWQgdGhpcyBiZWNhdXNlIGl0J3MgdGFrZW4gY2FyZSBvZiBieSBjb21wYXJlVHlwZXMuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQ29uc3RyYWludHMpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBjb25zdHJhaW50cyB0aGUgdHlwZXMgY2Fubm90IGJlIHRoZSBzYW1lXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoZ2V0UGFydGlhbCQxKHRoaXMpLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwLmFwcGx5KHRoaXMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuaGFzUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmhhc1Byb3BlcnR5LmFwcGx5KGlubmVyLCBbbmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbm5lciA9IHRoaXMudW53cmFwLmFwcGx5KHRoaXMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmdldFByb3BlcnR5LmFwcGx5KGlubmVyLCBbbmFtZV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDEuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gZ2V0UGFydGlhbCQxKHRoaXMpO1xuICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gcGFydGlhbC50eXBlUGFyYW1ldGVycztcblxuICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcnNbaV07XG4gICAgICAgIGl0ZW1zLnB1c2godHlwZVBhcmFtZXRlci50b1N0cmluZyh0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICB2YXIgaWRlbnRpZmllciA9IHR5cGVQYXJhbWV0ZXJzLmxlbmd0aCA+IDAgPyBgJHtuYW1lfTwke2l0ZW1zLmpvaW4oJywgJyl9PmAgOiBuYW1lO1xuXG4gICAgICBpZiAod2l0aERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBgdHlwZSAke2lkZW50aWZpZXJ9ID0gJHtwYXJ0aWFsLnRvU3RyaW5nKCl9O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IGdldFBhcnRpYWwkMSh0aGlzKTtcbiAgICAgIHJldHVybiBwYXJ0aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMSh0aGlzKS50eXBlLnByb3BlcnRpZXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzO1xufShUeXBlQWxpYXMpO1xuXG5mdW5jdGlvbiBnZXRQYXJ0aWFsJDEocGFyZW50KSB7XG4gIHZhciB0eXBlQ3JlYXRvciA9IHBhcmVudC50eXBlQ3JlYXRvcixcbiAgICAgIGNvbnRleHQgPSBwYXJlbnQuY29udGV4dCxcbiAgICAgIG5hbWUgPSBwYXJlbnQubmFtZTtcblxuICB2YXIgcGFydGlhbCA9IG5ldyBQYXJ0aWFsVHlwZShjb250ZXh0KTtcbiAgcGFydGlhbC5uYW1lID0gbmFtZTtcbiAgcGFydGlhbC50eXBlID0gdHlwZUNyZWF0b3IocGFydGlhbCk7XG4gIHBhcnRpYWwuY29uc3RyYWludHMgPSBwYXJlbnQuY29uc3RyYWludHM7XG5cbiAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gcGFydGlhbC50eXBlUGFyYW1ldGVycztcblxuICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuNyA+IDEgPyBfbGVuNyAtIDEgOiAwKSwgX2tleTcgPSAxOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgdHlwZUluc3RhbmNlc1tfa2V5NyAtIDFdID0gYXJndW1lbnRzW19rZXk3XTtcbiAgfVxuXG4gIHZhciBsaW1pdCA9IE1hdGgubWluKHR5cGVJbnN0YW5jZXMubGVuZ3RoLCB0eXBlUGFyYW1ldGVycy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgIHZhciB0eXBlSW5zdGFuY2UgPSB0eXBlSW5zdGFuY2VzW2ldO1xuICAgIGlmICh0eXBlUGFyYW1ldGVyLmJvdW5kICYmIHR5cGVQYXJhbWV0ZXIuYm91bmQgIT09IHR5cGVJbnN0YW5jZSkge1xuICAgICAgLy8gaWYgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIGFscmVhZHkgYm91bmQgd2UgbmVlZCB0b1xuICAgICAgLy8gY3JlYXRlIGFuIGludGVyc2VjdGlvbiB0eXBlIHdpdGggdGhpcyBvbmUuXG4gICAgICB0eXBlUGFyYW1ldGVyLmJvdW5kID0gY29udGV4dC5pbnRlcnNlY3QodHlwZVBhcmFtZXRlci5ib3VuZCwgdHlwZUluc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVBhcmFtZXRlci5ib3VuZCA9IHR5cGVJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydGlhbDtcbn1cblxudmFyIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBQYXJhbWV0ZXJpemVkRnVuY3Rpb25UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1BhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTIgLSAzXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHlpZWxkKiBnZXRQYXJ0aWFsJDIuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSkuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0eXBlSW5zdGFuY2VzKSkpLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoZ2V0UGFydGlhbCQyKHRoaXMpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0c1BhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHNQYXJhbXMoKSB7XG4gICAgICB2YXIgX2dldFBhcnRpYWwkdHlwZTtcblxuICAgICAgcmV0dXJuIChfZ2V0UGFydGlhbCR0eXBlID0gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGUpLmFjY2VwdHNQYXJhbXMuYXBwbHkoX2dldFBhcnRpYWwkdHlwZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzUmV0dXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0c1JldHVybihpbnB1dCkge1xuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMih0aGlzKS50eXBlLmFjY2VwdHNSZXR1cm4oaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fzc2VydFBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydFBhcmFtcygpIHtcbiAgICAgIHZhciBfZ2V0UGFydGlhbCR0eXBlMjtcblxuICAgICAgcmV0dXJuIChfZ2V0UGFydGlhbCR0eXBlMiA9IGdldFBhcnRpYWwkMih0aGlzKS50eXBlKS5hc3NlcnRQYXJhbXMuYXBwbHkoX2dldFBhcnRpYWwkdHlwZTIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXNzZXJ0UmV0dXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0UmV0dXJuKGlucHV0KSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGUuYXNzZXJ0UmV0dXJuKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFBhcnRpYWwkMi5hcHBseSh1bmRlZmluZWQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpKS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHBhcnRpYWwgPSBnZXRQYXJ0aWFsJDIodGhpcyk7XG4gICAgICB2YXIgdHlwZSA9IHBhcnRpYWwudHlwZSxcbiAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IHBhcnRpYWwudHlwZVBhcmFtZXRlcnM7XG5cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlciA9IHR5cGVQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpdGVtcy5wdXNoKHR5cGVQYXJhbWV0ZXIudG9TdHJpbmcodHJ1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGA8JHtpdGVtcy5qb2luKCcsICcpfT4gJHt0eXBlLnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IGdldFBhcnRpYWwkMih0aGlzKTtcbiAgICAgIHJldHVybiBwYXJ0aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGVQYXJhbWV0ZXJzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDIodGhpcykudHlwZVBhcmFtZXRlcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGFyYW1zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDIodGhpcykudHlwZS5wYXJhbXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFydGlhbCQyKHRoaXMpLnR5cGUucmVzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXR1cm5UeXBlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBnZXRQYXJ0aWFsJDIodGhpcykudHlwZS5yZXR1cm5UeXBlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZTtcbn0oVHlwZSk7XG5cbmZ1bmN0aW9uIGdldFBhcnRpYWwkMihwYXJlbnQpIHtcbiAgdmFyIGNvbnRleHQgPSBwYXJlbnQuY29udGV4dCxcbiAgICAgIGJvZHlDcmVhdG9yID0gcGFyZW50LmJvZHlDcmVhdG9yO1xuXG4gIHZhciBwYXJ0aWFsID0gbmV3IFBhcnRpYWxUeXBlKGNvbnRleHQpO1xuICB2YXIgYm9keSA9IGJvZHlDcmVhdG9yKHBhcnRpYWwpO1xuICBwYXJ0aWFsLnR5cGUgPSBjb250ZXh0LmZ1bmN0aW9uLmFwcGx5KGNvbnRleHQsIHRvQ29uc3VtYWJsZUFycmF5KGJvZHkpKTtcblxuICB2YXIgdHlwZVBhcmFtZXRlcnMgPSBwYXJ0aWFsLnR5cGVQYXJhbWV0ZXJzO1xuXG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICB0eXBlSW5zdGFuY2VzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgdmFyIGxpbWl0ID0gTWF0aC5taW4odHlwZUluc3RhbmNlcy5sZW5ndGgsIHR5cGVQYXJhbWV0ZXJzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgIHZhciB0eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcnNbaV07XG4gICAgdmFyIHR5cGVJbnN0YW5jZSA9IHR5cGVJbnN0YW5jZXNbaV07XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXIuYm91bmQgJiYgdHlwZVBhcmFtZXRlci5ib3VuZCAhPT0gdHlwZUluc3RhbmNlKSB7XG4gICAgICAvLyBpZiB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgYWxyZWFkeSBib3VuZCB3ZSBuZWVkIHRvXG4gICAgICAvLyBjcmVhdGUgYW4gaW50ZXJzZWN0aW9uIHR5cGUgd2l0aCB0aGlzIG9uZS5cbiAgICAgIHR5cGVQYXJhbWV0ZXIuYm91bmQgPSBjb250ZXh0LmludGVyc2VjdCh0eXBlUGFyYW1ldGVyLmJvdW5kLCB0eXBlSW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlUGFyYW1ldGVyLmJvdW5kID0gdHlwZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG52YXIgUmVmaW5lbWVudFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoUmVmaW5lbWVudFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBSZWZpbmVtZW50VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZWZpbmVtZW50VHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBSZWZpbmVtZW50VHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlZmluZW1lbnRUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnUmVmaW5lbWVudFR5cGUnLCBfdGhpcy5jb25zdHJhaW50cyA9IFtdLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUmVmaW5lbWVudFR5cGUsIFt7XG4gICAga2V5OiAnYWRkQ29uc3RyYWludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbnN0cmFpbnRzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgY29uc3RyYWludHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgYWRkQ29uc3RyYWludHMuYXBwbHkodW5kZWZpbmVkLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNvbnN0cmFpbnRzKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNFcnJvcnMpIHtcbiAgICAgICAgeWllbGQqIGNvbGxlY3RDb25zdHJhaW50RXJyb3JzKHRoaXMsIHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGlmICghdHlwZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFjb25zdHJhaW50c0FjY2VwdCh0aGlzLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbih0aGlzLmNvbnRleHQpO1xuICAgICAgdGFyZ2V0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzUHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcCgpO1xuICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lci5oYXNQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5uZXIuaGFzUHJvcGVydHkobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnVud3JhcCgpO1xuICAgICAgaWYgKGlubmVyICYmIHR5cGVvZiBpbm5lci5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5uZXIuZ2V0UHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICByZXR1cm4gYCRSZWZpbm1lbnQ8JHt0eXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlZmluZW1lbnRUeXBlO1xufShUeXBlKTtcblxudmFyIFN0cmluZ0xpdGVyYWxUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFN0cmluZ0xpdGVyYWxUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbFR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nTGl0ZXJhbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gU3RyaW5nTGl0ZXJhbFR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdMaXRlcmFsVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1N0cmluZ0xpdGVyYWxUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0xpdGVyYWxUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgICAgIGlmIChpbnB1dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9FWEFDVF9WQUxVRScsIHRoaXMudG9TdHJpbmcoKSksIHRoaXNdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgPT09IHRoaXMudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbFR5cGUgJiYgaW5wdXQudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJpbmdMaXRlcmFsVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBTdHJpbmdUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFN0cmluZ1R5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBTdHJpbmdUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ1R5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gU3RyaW5nVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ1R5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdTdHJpbmdUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN0cmluZ1R5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9TVFJJTkcnKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN0cmluZ0xpdGVyYWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN0cmluZ1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ1R5cGU7XG59KFR5cGUpO1xuXG52YXIgU3ltYm9sTGl0ZXJhbFR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoU3ltYm9sTGl0ZXJhbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBTeW1ib2xMaXRlcmFsVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTeW1ib2xMaXRlcmFsVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBTeW1ib2xMaXRlcmFsVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bWJvbExpdGVyYWxUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnU3ltYm9sTGl0ZXJhbFR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU3ltYm9sTGl0ZXJhbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgaWYgKGlucHV0ICE9PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0VYQUNUX1ZBTFVFJywgdGhpcy50b1N0cmluZygpKSwgdGhpc107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCA9PT0gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTeW1ib2xMaXRlcmFsVHlwZSAmJiBpbnB1dC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGB0eXBlb2YgJHtTdHJpbmcodGhpcy52YWx1ZSl9YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTeW1ib2xMaXRlcmFsVHlwZTtcbn0oVHlwZSk7XG5cbnZhciBTeW1ib2xUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFN5bWJvbFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiBTeW1ib2xUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN5bWJvbFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gU3ltYm9sVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bWJvbFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdTeW1ib2xUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN5bWJvbFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3ltYm9sJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX1NZTUJPTCcpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N5bWJvbCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU3ltYm9sTGl0ZXJhbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgU3ltYm9sVHlwZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdTeW1ib2wnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3ltYm9sVHlwZTtcbn0oVHlwZSk7XG5cbi8qKlxuICogIyBUaGlzVHlwZVxuICogQ2FwdHVyZXMgYSByZWZlcmVuY2UgdG8gYSBwYXJ0aWN1bGFyIGluc3RhbmNlIG9mIGEgY2xhc3Mgb3IgYSB2YWx1ZSxcbiAqIGFuZCB1c2VzIHRoYXQgdmFsdWUgdG8gcGVyZm9ybSBhbiBpZGVudGl0eSBjaGVjay5cbiAqIEluIHRoZSBjYXNlIHRoYXQgYHRoaXNgIGlzIHVuZGVmaW5lZCwgYW55IHZhbHVlIHdpbGwgYmUgcGVybWl0dGVkLlxuICovXG5cbnZhciBUaGlzVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cyhUaGlzVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFRoaXNUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRoaXNUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFRoaXNUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhpc1R5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUaGlzVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUaGlzVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgcmVjb3JkZWQgPSB0aGlzLnJlY29yZGVkO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IHJlY29yZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlY29yZGVkID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgcmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlZCAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfVEhJUycpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHJlY29yZGVkID0gdGhpcy5yZWNvcmRlZDtcblxuICAgICAgaWYgKGlucHV0ID09PSByZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlY29yZGVkID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgcmVjb3JkZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZGVkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBUaGlzVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5yZWNvcmRlZCAmJiB0aGlzLnJlY29yZGVkKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZWNvcmRlZCA9PT0gdGhpcy5yZWNvcmRlZCA/IDAgOiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvcmRlZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyh3aXRoQmluZGluZykge1xuICAgICAgcmV0dXJuICd0aGlzJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRoaXNUeXBlO1xufShUeXBlKTtcblxudmFyIHdhcm5lZEluc3RhbmNlcyQxID0gbmV3IFdlYWtTZXQoKTtcblxudmFyIFR5cGVCb3ggPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHlwZUJveCwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVCb3goKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZUJveCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZUJveCkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R5cGVCb3gnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZUJveCwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24odGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5wYXJlbnQgPSB0aGlzLnR5cGU7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGVJbnN0YW5jZXMgPSB0eXBlSW5zdGFuY2VzO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlubmVyIHR5cGUgb3IgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnRvSlNPTigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5uYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3R5cGUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIHJldmVhbCA9IHRoaXMucmV2ZWFsO1xuXG4gICAgICB2YXIgdHlwZSA9IHJldmVhbCgpO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIGlmICghd2FybmVkSW5zdGFuY2VzJDEuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmVtaXRXYXJuaW5nTWVzc2FnZSgnRmFpbGVkIHRvIHJldmVhbCBib3hlZCB0eXBlLicpO1xuICAgICAgICAgIHdhcm5lZEluc3RhbmNlcyQxLmFkZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm1peGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICAgIC8vIHdlIGdvdCBhIGJveGVkIHJlZmVyZW5jZSB0byBzb21ldGhpbmcgbGlrZSBhIGNsYXNzXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucmVmKHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlQm94O1xufShUeXBlKTtcblxudmFyIHdhcm5lZE1pc3NpbmcgPSB7fTtcblxudmFyIFR5cGVSZWZlcmVuY2UgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoVHlwZVJlZmVyZW5jZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFR5cGVSZWZlcmVuY2UoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZVJlZmVyZW5jZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBUeXBlUmVmZXJlbmNlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZVJlZmVyZW5jZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJ1R5cGVSZWZlcmVuY2UnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZVJlZmVyZW5jZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnR5cGUsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24odGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVJbnN0YW5jZXMgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC50eXBlSW5zdGFuY2VzID0gdHlwZUluc3RhbmNlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbm5lciB0eXBlIG9yIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICB2YXIgdHlwZSA9IGNvbnRleHQuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIGlmICghd2FybmVkTWlzc2luZ1tuYW1lXSkge1xuICAgICAgICAgIGNvbnRleHQuZW1pdFdhcm5pbmdNZXNzYWdlKGBDYW5ub3QgcmVzb2x2ZSB0eXBlOiAke25hbWV9YCk7XG4gICAgICAgICAgd2FybmVkTWlzc2luZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYW55KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVSZWZlcmVuY2U7XG59KFR5cGUpO1xuXG52YXIgd2FybmVkSW5zdGFuY2VzJDIgPSBuZXcgV2Vha1NldCgpO1xuXG52YXIgUmV2ZWFsZWROYW1lID0gU3ltYm9sKCdSZXZlYWxlZE5hbWUnKTtcbnZhciBSZXZlYWxlZFZhbHVlID0gU3ltYm9sKCdSZXZlYWxlZFZhbHVlJyk7XG5cbnZhciBUeXBlVERaID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFR5cGVURFosIF9UeXBlKTtcblxuICBmdW5jdGlvbiBUeXBlVERaKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVURFopO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVHlwZVREWi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGVURFopKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdUeXBlVERaJywgX3RoaXNbUmV2ZWFsZWROYW1lXSA9IHVuZGVmaW5lZCwgX3RoaXNbUmV2ZWFsZWRWYWx1ZV0gPSB1bmRlZmluZWQsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIC8vIElzc3VlIDI1MlxuXG5cbiAgY3JlYXRlQ2xhc3MoVHlwZVREWiwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogZ2V0UmV2ZWFsZWQodGhpcykuZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIGdldFJldmVhbGVkKHRoaXMpLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXMoZ2V0UmV2ZWFsZWQodGhpcyksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlUGFyYW1ldGVyQXBwbGljYXRpb24odGhpcy5jb250ZXh0KTtcbiAgICAgIHRhcmdldC5wYXJlbnQgPSBnZXRSZXZlYWxlZCh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZUluc3RhbmNlcyA9IHR5cGVJbnN0YW5jZXM7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5uZXIgdHlwZSBvciB2YWx1ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIGdldFJldmVhbGVkKHRoaXMpLnVud3JhcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc1Byb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy51bndyYXAoKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuaGFzUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmhhc1Byb3BlcnR5KG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcGVydHkobmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gdGhpcy51bndyYXAoKTtcbiAgICAgIGlmIChpbm5lciAmJiB0eXBlb2YgaW5uZXIuZ2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmdldFByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZ2V0UmV2ZWFsZWQodGhpcykudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gZ2V0UmV2ZWFsZWQodGhpcykudG9KU09OKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXNbUmV2ZWFsZWROYW1lXTtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBuYW1lID0gZ2V0UmV2ZWFsZWQodGhpcykubmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsdWUpIHtcbiAgICAgIHRoaXNbUmV2ZWFsZWROYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZVREWjtcbn0oVHlwZSk7XG5cbmZ1bmN0aW9uIGdldFJldmVhbGVkKGNvbnRhaW5lcikge1xuICB2YXIgZXhpc3RpbmcgPSBjb250YWluZXJbUmV2ZWFsZWRWYWx1ZV07XG4gIGlmIChleGlzdGluZykge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmV2ZWFsID0gY29udGFpbmVyLnJldmVhbDtcblxuICAgIHZhciB0eXBlID0gcmV2ZWFsKCk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICBpZiAoIXdhcm5lZEluc3RhbmNlcyQyLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgIHZhciBuYW1lID0gY29udGFpbmVyW1JldmVhbGVkTmFtZV07XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgY29udGFpbmVyLmNvbnRleHQuZW1pdFdhcm5pbmdNZXNzYWdlKGBGYWlsZWQgdG8gcmV2ZWFsIHR5cGUgY2FsbGVkIFwiJHtuYW1lfVwiIGluIFRlbXBvcmFsIERlYWQgWm9uZS5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXIuY29udGV4dC5lbWl0V2FybmluZ01lc3NhZ2UoJ0ZhaWxlZCB0byByZXZlYWwgdW5rbm93biB0eXBlIGluIFRlbXBvcmFsIERlYWQgWm9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuZWRJbnN0YW5jZXMkMi5hZGQoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIuY29udGV4dC5taXhlZCgpO1xuICAgIH0gZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgIC8vIHdlIGdvdCBhIGJveGVkIHJlZmVyZW5jZSB0byBzb21ldGhpbmcgbGlrZSBhIGNsYXNzXG4gICAgICByZXR1cm4gY29udGFpbmVyLmNvbnRleHQucmVmKHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufVxuXG52YXIgVW5pb25UeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKFVuaW9uVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIFVuaW9uVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBVbmlvblR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gVW5pb25UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVW5pb25UeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnVW5pb25UeXBlJywgX3RoaXMudHlwZXMgPSBbXSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFVuaW9uVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX05PX1VOSU9OJywgdGhpcy50b1N0cmluZygpKSwgdGhpc107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVW5pb25UeXBlKSB7XG4gICAgICAgIHZhciBpbnB1dFR5cGVzID0gaW5wdXQudHlwZXM7XG4gICAgICAgIHZhciBpZGVudGljYWxDb3VudCA9IDA7XG4gICAgICAgIGxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXRUeXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyh0eXBlLCBpbnB1dFR5cGVzW2ldKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgICAgaWRlbnRpY2FsQ291bnQrKztcbiAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHdlIGdvdCB0aGlzIGZhciB0aGVuIG5vdGhpbmcgYWNjZXB0ZWQgdGhpcyB0eXBlLlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZGVudGljYWxDb3VudCA9PT0gdHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3R5cGUgPSB0eXBlc1tfaV07XG4gICAgICAgICAgaWYgKGNvbXBhcmVUeXBlcyhfdHlwZSwgaW5wdXQpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0eXBlcyA9IHRoaXMudHlwZXM7XG5cbiAgICAgIHZhciBub3JtYWxpemVkID0gbmV3IEFycmF5KHR5cGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlLnR5cGVOYW1lID09PSAnRnVuY3Rpb25UeXBlJyB8fCB0eXBlLnR5cGVOYW1lID09PSAnUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZScpIHtcbiAgICAgICAgICBub3JtYWxpemVkW2ldID0gYCgke3R5cGUudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3JtYWxpemVkW2ldID0gdHlwZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplZC5qb2luKCcgfCAnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZXM6IHRoaXMudHlwZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBVbmlvblR5cGU7XG59KFR5cGUpO1xuXG5mdW5jdGlvbiByZWdpc3RlclByaW1pdGl2ZVR5cGVzKHQpIHtcbiAgcHJpbWl0aXZlVHlwZXMubnVsbCA9IE9iamVjdC5mcmVlemUobmV3IE51bGxMaXRlcmFsVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLmVtcHR5ID0gT2JqZWN0LmZyZWV6ZShuZXcgRW1wdHlUeXBlKHQpKTtcbiAgcHJpbWl0aXZlVHlwZXMubnVtYmVyID0gT2JqZWN0LmZyZWV6ZShuZXcgTnVtYmVyVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLmJvb2xlYW4gPSBPYmplY3QuZnJlZXplKG5ldyBCb29sZWFuVHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLnN0cmluZyA9IE9iamVjdC5mcmVlemUobmV3IFN0cmluZ1R5cGUodCkpO1xuICBwcmltaXRpdmVUeXBlcy5zeW1ib2wgPSBPYmplY3QuZnJlZXplKG5ldyBTeW1ib2xUeXBlKHQpKTtcbiAgcHJpbWl0aXZlVHlwZXMuYW55ID0gT2JqZWN0LmZyZWV6ZShuZXcgQW55VHlwZSh0KSk7XG4gIHByaW1pdGl2ZVR5cGVzLm1peGVkID0gT2JqZWN0LmZyZWV6ZShuZXcgTWl4ZWRUeXBlKHQpKTtcbiAgcHJpbWl0aXZlVHlwZXMudm9pZCA9IE9iamVjdC5mcmVlemUobmV3IFZvaWRUeXBlKHQpKTtcbiAgcHJpbWl0aXZlVHlwZXMuZXhpc3RlbnRpYWwgPSBPYmplY3QuZnJlZXplKG5ldyBFeGlzdGVudGlhbFR5cGUodCkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJCdWlsdGluVHlwZUNvbnN0cnVjdG9ycyh0KSB7XG5cbiAgdC5kZWNsYXJlVHlwZUNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiAnRGF0ZScsXG4gICAgaW1wbDogRGF0ZSxcbiAgICB0eXBlTmFtZTogJ0RhdGVUeXBlJyxcbiAgICAqZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfSU5TVEFOQ0VPRicsICdEYXRlJyksIHRoaXNdO1xuICAgICAgfSBlbHNlIGlmIChpc05hTihpbnB1dC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9JTlZBTElEX0RBVEUnKSwgdGhpc107XG4gICAgICB9XG4gICAgfSxcbiAgICBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihpbnB1dC5nZXRUaW1lKCkpO1xuICAgIH0sXG4gICAgY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC50eXBlTmFtZSA9PT0gJ0RhdGVUeXBlJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGluZmVyVHlwZVBhcmFtZXRlcnMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuXG4gIHQuZGVjbGFyZVR5cGVDb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogJ1Byb21pc2UnLFxuICAgIGltcGw6IFByb21pc2UsXG4gICAgdHlwZU5hbWU6ICdQcm9taXNlVHlwZScsXG4gICAgKmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCwgZnV0dXJlVHlwZSkge1xuICAgICAgaW52YXJpYW50KGZ1dHVyZVR5cGUsICdNdXN0IHNwZWNpZnkgdHlwZSBwYXJhbWV0ZXIgZm9yIFByb21pc2UuJyk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdQcm9taXNlJywgaW5wdXQpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfUFJPTUlTRScsIGZ1dHVyZVR5cGUpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICByZXR1cm4gY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnUHJvbWlzZScsIGlucHV0KTtcbiAgICB9LFxuICAgIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQudHlwZU5hbWUgPT09ICdQcm9taXNlVHlwZScpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBpbmZlclR5cGVQYXJhbWV0ZXJzKGlucHV0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcblxuICB0LmRlY2xhcmVUeXBlQ29uc3RydWN0b3Ioe1xuICAgIG5hbWU6ICdNYXAnLFxuICAgIGltcGw6IE1hcCxcbiAgICB0eXBlTmFtZTogJ01hcFR5cGUnLFxuICAgICplcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQsIGtleVR5cGUsIHZhbHVlVHlwZSkge1xuICAgICAgaW52YXJpYW50KGtleVR5cGUsICdNdXN0IHNwZWNpZnkgdHdvIHR5cGUgcGFyYW1ldGVycyBmb3IgTWFwLicpO1xuICAgICAgaW52YXJpYW50KHZhbHVlVHlwZSwgJ011c3Qgc3BlY2lmeSB0d28gdHlwZSBwYXJhbWV0ZXJzIGZvciBNYXAuJyk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdNYXAnLCBpbnB1dCkpIHtcbiAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9JTlNUQU5DRU9GJywgJ01hcCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3JlZjIgPSBzbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgaWYgKCFrZXlUeXBlLmFjY2VwdHMoa2V5KSkge1xuICAgICAgICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX0VYUEVDVF9LRVlfVFlQRScsIGtleVR5cGUpLCB0aGlzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5aWVsZCogdmFsdWVUeXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLmNvbmNhdChrZXkpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWNjZXB0cyhpbnB1dCwga2V5VHlwZSwgdmFsdWVUeXBlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNoZWNrUHJlZGljYXRlKCdNYXAnLCBpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVmMyA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmNCA9IHNsaWNlZFRvQXJyYXkoX3JlZjMsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWY0WzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgaWYgKCFrZXlUeXBlLmFjY2VwdHMoa2V5KSB8fCAhdmFsdWVUeXBlLmFjY2VwdHModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC50eXBlTmFtZSA9PT0gJ01hcFR5cGUnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgaW5mZXJUeXBlUGFyYW1ldGVycyhpbnB1dCkge1xuICAgICAgdmFyIGtleVR5cGVzID0gW107XG4gICAgICB2YXIgdmFsdWVUeXBlcyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvb3A6IGZvciAodmFyIF9pdGVyYXRvcjMgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVmNSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmNiA9IHNsaWNlZFRvQXJyYXkoX3JlZjUsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWY2WzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWY2WzFdO1xuXG4gICAgICAgICAgZmluZEtleToge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGtleVR5cGVzW2ldO1xuICAgICAgICAgICAgICBpZiAodHlwZS5hY2NlcHRzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBicmVhayBmaW5kS2V5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlUeXBlcy5wdXNoKHQudHlwZU9mKGtleSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB2YWx1ZVR5cGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF90eXBlID0gdmFsdWVUeXBlc1tfaV07XG4gICAgICAgICAgICBpZiAoX3R5cGUuYWNjZXB0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVUeXBlcy5wdXNoKHQudHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVJbnN0YW5jZXMgPSBbXTtcblxuICAgICAgaWYgKGtleVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0eXBlSW5zdGFuY2VzLnB1c2godC5leGlzdGVudGlhbCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5VHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXMucHVzaChrZXlUeXBlc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlSW5zdGFuY2VzLnB1c2godC51bmlvbi5hcHBseSh0LCBrZXlUeXBlcykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdHlwZUluc3RhbmNlcy5wdXNoKHQuZXhpc3RlbnRpYWwoKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXMucHVzaCh2YWx1ZVR5cGVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVJbnN0YW5jZXMucHVzaCh0LnVuaW9uLmFwcGx5KHQsIHZhbHVlVHlwZXMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGVJbnN0YW5jZXM7XG4gICAgfVxuICB9KTtcblxuICB0LmRlY2xhcmVUeXBlQ29uc3RydWN0b3Ioe1xuICAgIG5hbWU6ICdTZXQnLFxuICAgIGltcGw6IFNldCxcbiAgICB0eXBlTmFtZTogJ1NldFR5cGUnLFxuICAgICplcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQsIHZhbHVlVHlwZSkge1xuICAgICAgaW52YXJpYW50KHZhbHVlVHlwZSwgJ011c3Qgc3BlY2lmeSB0eXBlIHBhcmFtZXRlciBmb3IgU2V0LicpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnU2V0JywgaW5wdXQpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfSU5TVEFOQ0VPRicsICdTZXQnKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICB5aWVsZCogdmFsdWVUeXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFjY2VwdHMoaW5wdXQsIHZhbHVlVHlwZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICghY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnU2V0JywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIXZhbHVlVHlwZS5hY2NlcHRzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQudHlwZU5hbWUgPT09ICdTZXRUeXBlJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGluZmVyVHlwZVBhcmFtZXRlcnMoaW5wdXQpIHtcbiAgICAgIHZhciB2YWx1ZVR5cGVzID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9vcDogZm9yICh2YXIgX2l0ZXJhdG9yNiA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHZhbHVlVHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZS5hY2NlcHRzKHZhbHVlKSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZVR5cGVzLnB1c2godC50eXBlT2YodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt0LmV4aXN0ZW50aWFsKCldO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlVHlwZXNbMF1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0LnVuaW9uLmFwcGx5KHQsIHZhbHVlVHlwZXMpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclR5cGVQcmVkaWNhdGVzKGNvbnRleHQpIHtcbiAgY29udGV4dC5zZXRQcmVkaWNhdGUoJ0FycmF5JywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpO1xuICB9KTtcbiAgY29udGV4dC5zZXRQcmVkaWNhdGUoJ01hcCcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIE1hcDtcbiAgfSk7XG4gIGNvbnRleHQuc2V0UHJlZGljYXRlKCdTZXQnLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBTZXQ7XG4gIH0pO1xuICBjb250ZXh0LnNldFByZWRpY2F0ZSgnUHJvbWlzZScsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXQgIT09IG51bGwgJiYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgVHlwZUluZmVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFR5cGVJbmZlcmVyKGNvbnRleHQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlSW5mZXJlcik7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVHlwZUluZmVyZXIsIFt7XG4gICAga2V5OiAnaW5mZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlcihpbnB1dCkge1xuICAgICAgdmFyIHByaW1pdGl2ZSA9IHRoaXMuaW5mZXJQcmltaXRpdmUoaW5wdXQpO1xuICAgICAgaWYgKHByaW1pdGl2ZSkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xuICAgICAgfVxuICAgICAgdmFyIGluZmVycmVkID0gbmV3IE1hcCgpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mZXJDb21wbGV4KGlucHV0LCBpbmZlcnJlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5mZXJJbnRlcm5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZmVySW50ZXJuYWwoaW5wdXQsIGluZmVycmVkKSB7XG4gICAgICB2YXIgcHJpbWl0aXZlID0gdGhpcy5pbmZlclByaW1pdGl2ZShpbnB1dCk7XG4gICAgICBpZiAocHJpbWl0aXZlKSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbmZlckNvbXBsZXgoaW5wdXQsIGluZmVycmVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlclByaW1pdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZmVyUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lm51bGwoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC52b2lkKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubnVtYmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJvb2xlYW4oKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5zdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LnN5bWJvbChpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZmVyQ29tcGxleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZmVyQ29tcGxleChpbnB1dCwgaW5mZXJyZWQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mZXJGdW5jdGlvbihpbnB1dCwgaW5mZXJyZWQpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZmVyT2JqZWN0KGlucHV0LCBpbmZlcnJlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5hbnkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlckZ1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mZXJGdW5jdGlvbihpbnB1dCwgaW5mZXJyZWQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdmFyIGJvZHkgPSBuZXcgQXJyYXkobGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvZHlbaV0gPSBjb250ZXh0LnBhcmFtKFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBpKSwgY29udGV4dC5leGlzdGVudGlhbCgpKTtcbiAgICAgIH1cbiAgICAgIGJvZHlbbGVuZ3RoXSA9IGNvbnRleHQucmV0dXJuKGNvbnRleHQuZXhpc3RlbnRpYWwoKSk7XG4gICAgICByZXR1cm4gY29udGV4dC5mbi5hcHBseShjb250ZXh0LCBib2R5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlck9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZmVyT2JqZWN0KGlucHV0LCBpbmZlcnJlZCkge1xuICAgICAgdmFyIGV4aXN0aW5nID0gaW5mZXJyZWQuZ2V0KGlucHV0KTtcbiAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHR5cGUgPSB2b2lkIDA7XG5cbiAgICAgIC8vIFRlbXBvcmFyaWx5IGNyZWF0ZSBhIGJveCBmb3IgdGhpcyB0eXBlIHRvIGNhdGNoIGN5Y2xpY2FsIHJlZmVyZW5jZXMuXG4gICAgICAvLyBOZXN0ZWQgcmVmZXJlbmNlcyB0byB0aGlzIG9iamVjdCB3aWxsIHJlY2VpdmUgdGhlIGJveGVkIHR5cGUuXG4gICAgICB2YXIgYm94ID0gY29udGV4dC5ib3goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0pO1xuICAgICAgaW5mZXJyZWQuc2V0KGlucHV0LCBib3gpO1xuXG4gICAgICBpZiAoY29udGV4dC5jaGVja1ByZWRpY2F0ZSgnQXJyYXknLCBpbnB1dCkpIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuaW5mZXJBcnJheShpbnB1dCwgaW5mZXJyZWQpO1xuICAgICAgfSBlbHNlIGlmICghKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICB0eXBlID0gdGhpcy5pbmZlckRpY3QoaW5wdXQsIGluZmVycmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNvbnRleHQuZ2V0VHlwZUNvbnN0cnVjdG9yKGlucHV0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSBoYW5kbGVyLmluZmVyVHlwZVBhcmFtZXRlcnMoaW5wdXQpO1xuICAgICAgICAgIHR5cGUgPSBoYW5kbGVyLmFwcGx5LmFwcGx5KGhhbmRsZXIsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGVQYXJhbWV0ZXJzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IGNvbnRleHQucmVmKGlucHV0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgICAgYm9keS5wdXNoKGNvbnRleHQucHJvcGVydHkoa2V5LCB0aGlzLmluZmVySW50ZXJuYWwodmFsdWUsIGluZmVycmVkKSkpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBjb250ZXh0Lm9iamVjdC5hcHBseShjb250ZXh0LCBib2R5KTtcbiAgICAgIH1cblxuICAgICAgLy8gT3ZlcndyaXRlIHRoZSBib3ggd2l0aCB0aGUgcmVhbCB2YWx1ZS5cbiAgICAgIGluZmVycmVkLnNldChpbnB1dCwgdHlwZSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmZlckRpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlckRpY3QoaW5wdXQsIGluZmVycmVkKSB7XG4gICAgICB2YXIgbnVtZXJpY0luZGV4ZXJzID0gW107XG4gICAgICB2YXIgc3RyaW5nSW5kZXhlcnMgPSBbXTtcbiAgICAgIGxvb3A6IGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgIHZhciB0eXBlcyA9IGlzTmFOKCtrZXkpID8gc3RyaW5nSW5kZXhlcnMgOiBudW1lcmljSW5kZXhlcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgIGlmICh0eXBlLmFjY2VwdHModmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5wdXNoKHRoaXMuaW5mZXJJbnRlcm5hbCh2YWx1ZSwgaW5mZXJyZWQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciBib2R5ID0gW107XG4gICAgICBpZiAobnVtZXJpY0luZGV4ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBib2R5LnB1c2goY29udGV4dC5pbmRleGVyKCdpbmRleCcsIGNvbnRleHQubnVtYmVyKCksIG51bWVyaWNJbmRleGVyc1swXSkpO1xuICAgICAgfSBlbHNlIGlmIChudW1lcmljSW5kZXhlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBib2R5LnB1c2goY29udGV4dC5pbmRleGVyKCdpbmRleCcsIGNvbnRleHQubnVtYmVyKCksIGNvbnRleHQudW5pb24uYXBwbHkoY29udGV4dCwgbnVtZXJpY0luZGV4ZXJzKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaW5nSW5kZXhlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGJvZHkucHVzaChjb250ZXh0LmluZGV4ZXIoJ2tleScsIGNvbnRleHQuc3RyaW5nKCksIHN0cmluZ0luZGV4ZXJzWzBdKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ0luZGV4ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYm9keS5wdXNoKGNvbnRleHQuaW5kZXhlcigna2V5JywgY29udGV4dC5zdHJpbmcoKSwgY29udGV4dC51bmlvbi5hcHBseShjb250ZXh0LCBzdHJpbmdJbmRleGVycykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQub2JqZWN0LmFwcGx5KGNvbnRleHQsIGJvZHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZmVyQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZlckFycmF5KGlucHV0LCBpbmZlcnJlZCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0eXBlcyA9IFtdO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgbG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGlucHV0W2ldO1xuICAgICAgICB2YXIgaW5mZXJyZWRUeXBlID0gdGhpcy5pbmZlckludGVybmFsKGl0ZW0sIGluZmVycmVkKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0eXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZXNbal07XG4gICAgICAgICAgaWYgKHR5cGUuYWNjZXB0cyhpdGVtKSAmJiBpbmZlcnJlZFR5cGUuYWNjZXB0cyh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5wdXNoKGluZmVycmVkVHlwZSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5hcnJheShjb250ZXh0LmFueSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmFycmF5KHR5cGVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmFycmF5KGNvbnRleHQudW5pb24uYXBwbHkoY29udGV4dCwgdHlwZXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR5cGVJbmZlcmVyO1xufSgpO1xuXG5mdW5jdGlvbiBtYWtlUmVhY3RQcm9wVHlwZXMob2JqZWN0VHlwZSkge1xuICB2YXIgb3V0cHV0ID0ge307XG4gIGlmICghb2JqZWN0VHlwZS5wcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3BlcnR5KSB7XG4gICAgb3V0cHV0W3Byb3BlcnR5LmtleV0gPSBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICByZXR1cm4gbWFrZUVycm9yKHByb3BlcnR5LCBwcm9wcyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBvYmplY3RUeXBlLnByb3BlcnRpZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgX2xvb3AocHJvcGVydHkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG52YXIgZGVsaW1pdGVyJDEgPSAnXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbic7XG5cbmZ1bmN0aW9uIG1ha2VXYXJuaW5nTWVzc2FnZSh2YWxpZGF0aW9uKSB7XG4gIGlmICghdmFsaWRhdGlvbi5oYXNFcnJvcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5wdXQgPSB2YWxpZGF0aW9uLmlucHV0LFxuICAgICAgY29udGV4dCA9IHZhbGlkYXRpb24uY29udGV4dDtcblxuICB2YXIgY29sbGVjdGVkID0gW107XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbGlkYXRpb24uZXJyb3JzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCAzKTtcblxuICAgICAgdmFyIHBhdGggPSBfcmVmMlswXTtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjJbMV07XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gX3JlZjJbMl07XG5cbiAgICAgIHZhciBleHBlY3RlZCA9IGV4cGVjdGVkVHlwZSA/IGV4cGVjdGVkVHlwZS50b1N0cmluZygpIDogXCIqXCI7XG4gICAgICB2YXIgYWN0dWFsID0gY29udGV4dC50eXBlT2YoX3Jlc29sdmVQYXRoKGlucHV0LCBwYXRoKSkudG9TdHJpbmcoKTtcblxuICAgICAgdmFyIGZpZWxkID0gc3RyaW5naWZ5UGF0aCh2YWxpZGF0aW9uLnBhdGguY29uY2F0KHBhdGgpKTtcblxuICAgICAgY29sbGVjdGVkLnB1c2goYCR7ZmllbGR9ICR7bWVzc2FnZX1cXG5cXG5FeHBlY3RlZDogJHtleHBlY3RlZH1cXG5cXG5BY3R1YWw6ICR7YWN0dWFsfVxcbmApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYFdhcm5pbmc6ICR7Y29sbGVjdGVkLmpvaW4oZGVsaW1pdGVyJDEpfWA7XG59XG5cbmZ1bmN0aW9uIG1ha2VVbmlvbihjb250ZXh0LCB0eXBlcykge1xuICB2YXIgbGVuZ3RoID0gdHlwZXMubGVuZ3RoO1xuICB2YXIgbWVyZ2VkID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgQW55VHlwZSB8fCB0eXBlIGluc3RhbmNlb2YgTWl4ZWRUeXBlIHx8IHR5cGUgaW5zdGFuY2VvZiBFeGlzdGVudGlhbFR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFVuaW9uVHlwZSkge1xuICAgICAgbWVyZ2VVbmlvblR5cGVzKG1lcmdlZCwgdHlwZS50eXBlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlZC5wdXNoKHR5cGUpO1xuICAgIH1cbiAgfVxuICB2YXIgdW5pb24gPSBuZXcgVW5pb25UeXBlKGNvbnRleHQpO1xuICB1bmlvbi50eXBlcyA9IG1lcmdlZDtcbiAgcmV0dXJuIHVuaW9uO1xufVxuXG5mdW5jdGlvbiBtZXJnZVVuaW9uVHlwZXMoYVR5cGVzLCBiVHlwZXMpIHtcbiAgbG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBiVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYlR5cGUgPSBiVHlwZXNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhVHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBhVHlwZSA9IGFUeXBlc1tqXTtcbiAgICAgIGlmIChjb21wYXJlVHlwZXMoYVR5cGUsIGJUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgYVR5cGVzLnB1c2goYlR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9wZXJ0eURlc2NyaXB0b3IodHlwZVNvdXJjZSwgaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgc2hvdWxkQXNzZXJ0KSB7XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGF1Z21lbnRFeGlzdGluZ0FjY2Vzc29ycyh0eXBlU291cmNlLCBpbnB1dCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLCBzaG91bGRBc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvQWNjZXNzb3IodHlwZVNvdXJjZSwgaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgc2hvdWxkQXNzZXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIGBfZmxvd1J1bnRpbWUkJHtuYW1lfWA7XG59XG5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlucHV0Lm5hbWUgfHwgJ1tDbGFzcyBhbm9ueW1vdXNdJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2V0Q2xhc3NOYW1lKGlucHV0LmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1tDbGFzcyBhbm9ueW1vdXNdJztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHlwZShyZWNlaXZlciwgdHlwZVNvdXJjZSkge1xuICBpZiAodHlwZW9mIHR5cGVTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZVNvdXJjZS5jYWxsKHJlY2VpdmVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZVNvdXJjZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eVRvQWNjZXNzb3IodHlwZVNvdXJjZSwgaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgc2hvdWxkQXNzZXJ0KSB7XG4gIHZhciBzYWZlTmFtZSA9IG1ha2VQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShpbnB1dCk7XG4gIHZhciBpbml0aWFsaXplciA9IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIsXG4gICAgICB3cml0YWJsZSA9IGRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICBjb25maWcgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhkZXNjcmlwdG9yLCBbJ2luaXRpYWxpemVyJywgJ3dyaXRhYmxlJ10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgdmFyIHByb3BlcnR5UGF0aCA9IFtjbGFzc05hbWUsIHByb3BlcnR5TmFtZV07XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb25maWcsIHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIGdldCgpIHtcbiAgICAgIGlmIChzYWZlTmFtZSBpbiB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3NhZmVOYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSByZXNvbHZlVHlwZSh0aGlzLCB0eXBlU291cmNlKTtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGluaXRpYWxpemVyLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZS5jb250ZXh0O1xuICAgICAgICBjb250ZXh0LmNoZWNrKHR5cGUsIF92YWx1ZSwgJ0RlZmF1bHQgdmFsdWUgZm9yIHByb3BlcnR5JywgcHJvcGVydHlQYXRoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHNhZmVOYW1lLCB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzYWZlTmFtZSwge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gcmVzb2x2ZVR5cGUodGhpcywgdHlwZVNvdXJjZSk7XG4gICAgICB2YXIgY29udGV4dCA9IHR5cGUuY29udGV4dDtcbiAgICAgIGlmIChzaG91bGRBc3NlcnQpIHtcbiAgICAgICAgY29udGV4dC5hc3NlcnQodHlwZSwgdmFsdWUsICdQcm9wZXJ0eScsIHByb3BlcnR5UGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Lndhcm4odHlwZSwgdmFsdWUsICdQcm9wZXJ0eScsIHByb3BlcnR5UGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoc2FmZU5hbWUgaW4gdGhpcykge1xuICAgICAgICB0aGlzW3NhZmVOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHNhZmVOYW1lLCB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRFeGlzdGluZ0FjY2Vzc29ycyh0eXBlU291cmNlLCBpbnB1dCwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yLCBzaG91bGRBc3NlcnQpIHtcblxuICB2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKGlucHV0KTtcbiAgdmFyIHByb3BlcnR5UGF0aCA9IFtjbGFzc05hbWUsIHByb3BlcnR5TmFtZV07XG5cbiAgdmFyIG9yaWdpbmFsU2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG5cbiAgZGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiBzZXQkJDEodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHJlc29sdmVUeXBlKHRoaXMsIHR5cGVTb3VyY2UpO1xuICAgIHZhciBjb250ZXh0ID0gdHlwZS5jb250ZXh0O1xuICAgIGlmIChzaG91bGRBc3NlcnQpIHtcbiAgICAgIGNvbnRleHQuYXNzZXJ0KHR5cGUsIHZhbHVlLCAnUHJvcGVydHknLCBwcm9wZXJ0eVBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lndhcm4odHlwZSwgdmFsdWUsICdQcm9wZXJ0eScsIHByb3BlcnR5UGF0aCk7XG4gICAgfVxuICAgIG9yaWdpbmFsU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBhbm5vdGF0ZVZhbHVlKGlucHV0LCB0eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG4gIGlmICh0eXBlIGluc3RhbmNlb2YgVHlwZSkge1xuICAgIGlucHV0W1R5cGVTeW1ib2xdID0gdHlwZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gaW5wdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaW5wdXRbVHlwZVN5bWJvbF0gPSBfdHlwZTtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuICB9XG59XG5cbi8vIElmIEEgYW5kIEIgYXJlIG9iamVjdCB0eXBlcywgJERpZmY8QSxCPiBpcyB0aGUgdHlwZSBvZiBvYmplY3RzIHRoYXQgaGF2ZVxuLy8gcHJvcGVydGllcyBkZWZpbmVkIGluIEEsIGJ1dCBub3QgaW4gQi5cbi8vIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiBib3RoIEEgYW5kIEIgYXJlIGFsbG93ZWQgdG9vLlxuXG52YXIgJERpZmZUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCREaWZmVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICREaWZmVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkRGlmZlR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJERpZmZUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJERpZmZUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJERpZmZUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCREaWZmVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgYVR5cGUgPSB0aGlzLmFUeXBlLFxuICAgICAgICAgIGJUeXBlID0gdGhpcy5iVHlwZTtcblxuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfT0JKRUNUJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhVHlwZSA9IGFUeXBlLnVud3JhcCgpO1xuICAgICAgYlR5cGUgPSBiVHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudChhVHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUgJiYgYlR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJERpZmYgb2JqZWN0IHR5cGVzLicpO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBhVHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChiVHlwZS5oYXNQcm9wZXJ0eShwcm9wZXJ0eS5rZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHByb3BlcnR5LmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLmNvbmNhdChwcm9wZXJ0eS5rZXkpLCBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHZhciBhVHlwZSA9IHRoaXMuYVR5cGUsXG4gICAgICAgICAgYlR5cGUgPSB0aGlzLmJUeXBlO1xuXG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYVR5cGUgPSBhVHlwZS51bndyYXAoKTtcbiAgICAgIGJUeXBlID0gYlR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQoYVR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlICYmIGJUeXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICREaWZmIG9iamVjdCB0eXBlcy4nKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gYVR5cGUucHJvcGVydGllcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAoYlR5cGUuaGFzUHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvcGVydHkuYWNjZXB0cyhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy51bndyYXAoKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgdmFyIGFUeXBlID0gdGhpcy5hVHlwZSxcbiAgICAgICAgICBiVHlwZSA9IHRoaXMuYlR5cGU7XG5cbiAgICAgIGFUeXBlID0gYVR5cGUudW53cmFwKCk7XG4gICAgICBiVHlwZSA9IGJUeXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KGFUeXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSAmJiBiVHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkRGlmZiBvYmplY3QgdHlwZXMuJyk7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IGFUeXBlLnByb3BlcnRpZXM7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChiVHlwZS5oYXNQcm9wZXJ0eShwcm9wZXJ0eS5rZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX2NvbnRleHQgPSB0aGlzLmNvbnRleHQpLm9iamVjdC5hcHBseShfY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJERpZmY8JHt0aGlzLmFUeXBlLnRvU3RyaW5nKCl9LCAke3RoaXMuYlR5cGUudG9TdHJpbmcoKX0+YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgYVR5cGU6IHRoaXMuYVR5cGUsXG4gICAgICAgIGJUeXBlOiB0aGlzLmJUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gJERpZmZUeXBlO1xufShUeXBlKTtcblxuLy8gQW55IHN1YnR5cGUgb2YgVFxuXG52YXIgJEZsb3dGaXhNZVR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJEZsb3dGaXhNZVR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkRmxvd0ZpeE1lVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkRmxvd0ZpeE1lVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkRmxvd0ZpeE1lVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRGbG93Rml4TWVUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJEZsb3dGaXhNZVR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJEZsb3dGaXhNZVR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBpbnB1dCkge1xuICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICckRmxvd0ZpeE1lJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRGbG93Rml4TWVUeXBlO1xufShUeXBlKTtcblxuLy8gVGhlIHNldCBvZiBrZXlzIG9mIFQuXG5cbnZhciAkS2V5c1R5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJEtleXNUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJEtleXNUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRLZXlzVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkS2V5c1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkS2V5c1R5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckS2V5c1R5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJEtleXNUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJEtleXM8VD4gb2JqZWN0IHR5cGVzLicpO1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBwcm9wZXJ0eS5rZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2ldID0gcHJvcGVydGllc1tfaV0ua2V5O1xuICAgICAgfVxuICAgICAgeWllbGQgW3BhdGgsIGdldEVycm9yTWVzc2FnZSgnRVJSX05PX1VOSU9OJywga2V5cy5qb2luKCcgfCAnKSksIHRoaXNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICRLZXlzPFQ+IG9iamVjdCB0eXBlcy4nKTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChpbnB1dCA9PT0gcHJvcGVydHkua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkS2V5czxUPiBvYmplY3QgdHlwZXMuJyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAga2V5c1tpXSA9IGNvbnRleHQubGl0ZXJhbChwcm9wZXJ0eS5rZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfY29udGV4dCA9IHRoaXMuY29udGV4dCkudW5pb24uYXBwbHkoX2NvbnRleHQsIGtleXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCRLZXlzPCR7dGhpcy50eXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRLZXlzVHlwZTtcbn0oVHlwZSk7XG5cbi8vIE1hcCBvdmVyIHRoZSBrZXlzIGFuZCB2YWx1ZXMgaW4gYW4gb2JqZWN0LlxuXG52YXIgJE9iak1hcGlUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRPYmpNYXBpVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRPYmpNYXBpVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkT2JqTWFwaVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJE9iak1hcGlUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJE9iak1hcGlUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJE9iak1hcGlUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRPYmpNYXBpVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IG9iamVjdC51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0IHR5cGUuJyk7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGFyZ2V0LnByb3BlcnRpZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICAgIGludmFyaWFudChhcHBsaWVkIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlLCAnTWFwcGVyIG11c3QgYmUgYSBmdW5jdGlvbiB0eXBlLicpO1xuXG4gICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpLCBwcm9wLnZhbHVlKTtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W3Byb3Aua2V5XTtcbiAgICAgICAgICB5aWVsZCogcmV0dXJuVHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQocHJvcC5rZXkpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IG9iamVjdC51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0IHR5cGUuJyk7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGFyZ2V0LnByb3BlcnRpZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICAgIGludmFyaWFudChhcHBsaWVkIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlLCAnTWFwcGVyIG11c3QgYmUgYSBmdW5jdGlvbiB0eXBlLicpO1xuXG4gICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpLCBwcm9wLnZhbHVlKTtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W3Byb3Aua2V5XTtcbiAgICAgICAgICBpZiAoIXJldHVyblR5cGUuYWNjZXB0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIGFyZ3MucHVzaChjb250ZXh0LnByb3BlcnR5KHByb3Aua2V5LCBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpLCBwcm9wLnZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0Lm9iamVjdC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkT2JqTWFwaTwke3RoaXMub2JqZWN0LnRvU3RyaW5nKCl9LCAke3RoaXMubWFwcGVyLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIG9iamVjdDogdGhpcy5vYmplY3QsXG4gICAgICAgIG1hcHBlcjogdGhpcy5tYXBwZXJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkT2JqTWFwaVR5cGU7XG59KFR5cGUpO1xuXG4vLyBNYXAgb3ZlciB0aGUga2V5cyBpbiBhbiBvYmplY3QuXG5cbnZhciAkT2JqTWFwVHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkT2JqTWFwVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRPYmpNYXBUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRPYmpNYXBUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRPYmpNYXBUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJE9iak1hcFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckT2JqTWFwVHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkT2JqTWFwVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IG9iamVjdC51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0IHR5cGUuJyk7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX09CSkVDVCcpLCB0aGlzXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGFyZ2V0LnByb3BlcnRpZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICAgIGludmFyaWFudChhcHBsaWVkIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlLCAnTWFwcGVyIG11c3QgYmUgYSBmdW5jdGlvbiB0eXBlLicpO1xuXG4gICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpKTtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W3Byb3Aua2V5XTtcbiAgICAgICAgICB5aWVsZCogcmV0dXJuVHlwZS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQocHJvcC5rZXkpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QsXG4gICAgICAgICAgbWFwcGVyID0gdGhpcy5tYXBwZXIsXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHRhcmdldCA9IG9iamVjdC51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0IHR5cGUuJyk7XG5cbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGFyZ2V0LnByb3BlcnRpZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICAgIGludmFyaWFudChhcHBsaWVkIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlLCAnTWFwcGVyIG11c3QgYmUgYSBmdW5jdGlvbiB0eXBlLicpO1xuXG4gICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpKTtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W3Byb3Aua2V5XTtcbiAgICAgICAgICBpZiAoIXJldHVyblR5cGUuYWNjZXB0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0LFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCB0eXBlLicpO1xuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRhcmdldC5wcm9wZXJ0aWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgYXBwbGllZCA9IG1hcHBlci51bndyYXAoKTtcbiAgICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICAgIGFyZ3MucHVzaChjb250ZXh0LnByb3BlcnR5KHByb3Aua2V5LCBhcHBsaWVkLmludm9rZShjb250ZXh0LmxpdGVyYWwocHJvcC5rZXkpKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0Lm9iamVjdC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkT2JqTWFwPCR7dGhpcy5vYmplY3QudG9TdHJpbmcoKX0sICR7dGhpcy5tYXBwZXIudG9TdHJpbmcoKX0+YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLm9iamVjdCxcbiAgICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRPYmpNYXBUeXBlO1xufShUeXBlKTtcblxuLy8gVGhlIHR5cGUgb2YgdGhlIG5hbWVkIG9iamVjdCBwcm9wZXJ0eVxuXG52YXIgJFByb3BlcnR5VHlwZSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICBpbmhlcml0cygkUHJvcGVydHlUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJFByb3BlcnR5VHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkUHJvcGVydHlUeXBlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9ICRQcm9wZXJ0eVR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkUHJvcGVydHlUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJFByb3BlcnR5VHlwZScsIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcygkUHJvcGVydHlUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLnVud3JhcCgpLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpLmFjY2VwdHMoaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBhcmVXaXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVdpdGgoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjb21wYXJlVHlwZXModGhpcy51bndyYXAoKSwgaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Vud3JhcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdCxcbiAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHk7XG5cbiAgICAgIHZhciB1bndyYXBwZWQgPSBvYmplY3QudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodHlwZW9mIHVud3JhcHBlZC5nZXRQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJywgJ0NhbiBvbmx5IHVzZSAkUHJvcGVydHlUeXBlIG9uIE9iamVjdHMuJyk7XG4gICAgICByZXR1cm4gdW53cmFwcGVkLmdldFByb3BlcnR5KHByb3BlcnR5KS51bndyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkUHJvcGVydHlUeXBlPCR7dGhpcy5vYmplY3QudG9TdHJpbmcoKX0sICR7U3RyaW5nKHRoaXMucHJvcGVydHkpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICBvYmplY3Q6IHRoaXMub2JqZWN0LFxuICAgICAgICBwcm9wZXJ0eTogdGhpcy5wcm9wZXJ0eVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRQcm9wZXJ0eVR5cGU7XG59KFR5cGUpO1xuXG4vLyBBbiBvYmplY3Qgb2YgdHlwZSAkU2hhcGU8VD4gZG9lcyBub3QgaGF2ZSB0byBoYXZlIGFsbCBvZiB0aGUgcHJvcGVydGllc1xuLy8gdGhhdCB0eXBlIFQgZGVmaW5lcy4gQnV0IHRoZSB0eXBlcyBvZiB0aGUgcHJvcGVydGllcyB0aGF0IGl0IGRvZXMgaGF2ZVxuLy8gbXVzdCBhY2NlcHRzIHRoZSB0eXBlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0aWVzIGluIFQuXG5cbnZhciAkU2hhcGVUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRTaGFwZVR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkU2hhcGVUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRTaGFwZVR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJFNoYXBlVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRTaGFwZVR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckU2hhcGVUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRTaGFwZVR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblxuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfT0JKRUNUJyksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nLCAnQ2FuIG9ubHkgJFNoYXBlPFQ+IG9iamVjdCB0eXBlcy4nKTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHR5cGUuZ2V0UHJvcGVydHkoa2V5KTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiBwcm9wZXJ0eS5lcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlLmdldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nLCAnQ2FuIG9ubHkgJFNoYXBlPFQ+IG9iamVjdCB0eXBlcy4nKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0eXBlLmdldFByb3BlcnR5KGtleSk7XG4gICAgICAgIGlmICghcHJvcGVydHkgfHwgIXByb3BlcnR5LmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB0eXBlID0gdHlwZS51bndyYXAoKTtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJFNoYXBlPFQ+IG9iamVjdCB0eXBlcy4nKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkocHJvcGVydGllcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGFyZ3NbaV0gPSBjb250ZXh0LnByb3BlcnR5KHByb3BlcnR5LmtleSwgcHJvcGVydHkudmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfY29udGV4dCA9IHRoaXMuY29udGV4dCkub2JqZWN0LmFwcGx5KF9jb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkU2hhcGU8JHt0aGlzLnR5cGUudG9TdHJpbmcoKX0+YDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZTogdGhpcy50eXBlTmFtZSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gJFNoYXBlVHlwZTtcbn0oVHlwZSk7XG5cbi8vIEFueSBzdWJ0eXBlIG9mIFRcblxudmFyICRTdWJUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRTdWJUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gJFN1YlR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJFN1YlR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJFN1YlR5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZigkU3ViVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRTdWJUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRTdWJUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLnR5cGUuZXJyb3JzKGlucHV0LCBwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5hY2NlcHRzKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCRTdWJ0eXBlPCR7dGhpcy50eXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRTdWJUeXBlO1xufShUeXBlKTtcblxuLy8gQW55LCBidXQgYXQgbGVhc3QgVC5cblxudmFyICRTdXBlclR5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJFN1cGVyVHlwZSwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uICRTdXBlclR5cGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgJFN1cGVyVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkU3VwZXJUeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJFN1cGVyVHlwZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnR5cGVOYW1lID0gJyRTdXBlclR5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJFN1cGVyVHlwZSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiogZXJyb3JzKHZhbGlkYXRpb24sIHBhdGgsIGlucHV0KSB7XG4gICAgICB5aWVsZCogdGhpcy50eXBlLmVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWNjZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuYWNjZXB0cyhpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcGFyZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlV2l0aChpbnB1dCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyh0aGlzLnVud3JhcCgpLCBpbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW53cmFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkU3VwZXJ0eXBlPCR7dGhpcy50eXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuICRTdXBlclR5cGU7XG59KFR5cGUpO1xuXG4vLyBNYXAgb3ZlciB0aGUgdmFsdWVzIGluIGEgdHVwbGUuXG5cbnZhciAkVHVwbGVNYXBUeXBlID0gZnVuY3Rpb24gKF9UeXBlKSB7XG4gIGluaGVyaXRzKCRUdXBsZU1hcFR5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkVHVwbGVNYXBUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsICRUdXBsZU1hcFR5cGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gJFR1cGxlTWFwVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRUdXBsZU1hcFR5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICckVHVwbGVNYXBUeXBlJywgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKCRUdXBsZU1hcFR5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR1cGxlID0gdGhpcy50dXBsZSxcbiAgICAgICAgICBtYXBwZXIgPSB0aGlzLm1hcHBlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdHVwbGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgVHVwbGVUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYSB0dXBsZSB0eXBlLicpO1xuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ0FycmF5JywgaW5wdXQpKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQVJSQVknKSwgdGhpc107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICB2YXIgZXhwZWN0ZWQgPSBhcHBsaWVkLmludm9rZSh0eXBlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICAgIHlpZWxkKiBleHBlY3RlZC5lcnJvcnModmFsaWRhdGlvbiwgcGF0aC5jb25jYXQoaSksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIHR1cGxlID0gdGhpcy50dXBsZSxcbiAgICAgICAgICBtYXBwZXIgPSB0aGlzLm1hcHBlcixcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gdHVwbGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodGFyZ2V0IGluc3RhbmNlb2YgVHVwbGVUeXBlLCAnVGFyZ2V0IG11c3QgYmUgYSB0dXBsZSB0eXBlLicpO1xuXG4gICAgICBpZiAoIWNvbnRleHQuY2hlY2tQcmVkaWNhdGUoJ0FycmF5JywgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICBpZiAoIWFwcGxpZWQuaW52b2tlKHR5cGUpLmFjY2VwdHMoaW5wdXRbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlLFxuICAgICAgICAgIG1hcHBlciA9IHRoaXMubWFwcGVyLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB0YXJnZXQgPSB0dXBsZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0YXJnZXQgaW5zdGFuY2VvZiBUdXBsZVR5cGUsICdUYXJnZXQgbXVzdCBiZSBhbiB0dXBsZSB0eXBlLicpO1xuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIHZhciBhcHBsaWVkID0gbWFwcGVyLnVud3JhcCgpO1xuICAgICAgICBpbnZhcmlhbnQoYXBwbGllZCBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSwgJ01hcHBlciBtdXN0IGJlIGEgZnVuY3Rpb24gdHlwZS4nKTtcblxuICAgICAgICBhcmdzLnB1c2goYXBwbGllZC5pbnZva2UodHlwZSkudW53cmFwKCkudW53cmFwKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dC50dXBsZS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAkVHVwbGVNYXA8JHt0aGlzLnR1cGxlLnRvU3RyaW5nKCl9LCAke3RoaXMubWFwcGVyLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIHR1cGxlOiB0aGlzLnR1cGxlLFxuICAgICAgICBtYXBwZXI6IHRoaXMubWFwcGVyXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gJFR1cGxlTWFwVHlwZTtcbn0oVHlwZSk7XG5cbi8vIFRoZSBzZXQgb2Yga2V5cyBvZiBULlxuXG52YXIgJFZhbHVlc1R5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoJFZhbHVlc1R5cGUsIF9UeXBlKTtcblxuICBmdW5jdGlvbiAkVmFsdWVzVHlwZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCAkVmFsdWVzVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSAkVmFsdWVzVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKCRWYWx1ZXNUeXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMudHlwZU5hbWUgPSAnJFZhbHVlc1R5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoJFZhbHVlc1R5cGUsIFt7XG4gICAga2V5OiAnZXJyb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24qIGVycm9ycyh2YWxpZGF0aW9uLCBwYXRoLCBpbnB1dCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUudW53cmFwKCk7XG4gICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUsICdDYW4gb25seSAkVmFsdWVzPFQ+IG9iamVjdCB0eXBlcy4nKTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0eXBlLnByb3BlcnRpZXM7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS5hY2NlcHRzKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2ldID0gcHJvcGVydGllc1tfaV0udmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9OT19VTklPTicsIHZhbHVlcy5qb2luKCcgfCAnKSksIHRoaXNdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FjY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHRzKGlucHV0KSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS51bndyYXAoKTtcbiAgICAgIGludmFyaWFudCh0eXBlIGluc3RhbmNlb2YgT2JqZWN0VHlwZSwgJ0NhbiBvbmx5ICRWYWx1ZXM8VD4gb2JqZWN0IHR5cGVzLicpO1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGUucHJvcGVydGllcztcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5LnZhbHVlLmFjY2VwdHMoaW5wdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZVR5cGVzKHRoaXMudW53cmFwKCksIGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bndyYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLnVud3JhcCgpO1xuICAgICAgaW52YXJpYW50KHR5cGUgaW5zdGFuY2VvZiBPYmplY3RUeXBlLCAnQ2FuIG9ubHkgJFZhbHVlczxUPiBvYmplY3QgdHlwZXMuJyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdHlwZS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YWx1ZXNbaV0gPSBwcm9wZXJ0eS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0LnVuaW9uLmFwcGx5KGNvbnRleHQsIHZhbHVlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJFZhbHVlczwke3RoaXMudHlwZS50b1N0cmluZygpfT5gO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnR5cGVOYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiAkVmFsdWVzVHlwZTtcbn0oVHlwZSk7XG5cbmZ1bmN0aW9uIGNoZWNrR2VuZXJpY1R5cGUoY29udGV4dCwgZXhwZWN0ZWQsIGlucHV0KSB7XG4gIHZhciBpbXBsID0gZXhwZWN0ZWQuaW1wbDtcblxuICBpZiAodHlwZW9mIGltcGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGVyZSBpcyBsaXR0bGUgZWxzZSB3ZSBjYW4gZG8gaGVyZSwgc28gYWNjZXB0IGFueXRoaW5nLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGltcGwgPT09IGlucHV0IHx8IGltcGwuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhbm5vdGF0aW9uID0gY29udGV4dC5nZXRBbm5vdGF0aW9uKGltcGwpO1xuICBpZiAoYW5ub3RhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaGVja1R5cGUoY29udGV4dCwgYW5ub3RhdGlvbiwgaW5wdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZShjb250ZXh0LCBleHBlY3RlZCwgaW5wdXQpIHtcbiAgdmFyIGFubm90YXRpb24gPSBjb250ZXh0LmdldEFubm90YXRpb24oaW5wdXQpO1xuICBpZiAoYW5ub3RhdGlvbiAhPSBudWxsKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVUeXBlcyhleHBlY3RlZCwgYW5ub3RhdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gLTE7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBDbGFzc1R5cGUgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoQ2xhc3NUeXBlLCBfVHlwZSk7XG5cbiAgZnVuY3Rpb24gQ2xhc3NUeXBlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENsYXNzVHlwZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBDbGFzc1R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGFzc1R5cGUpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy50eXBlTmFtZSA9ICdDbGFzc1R5cGUnLCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQ2xhc3NUeXBlLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBlcnJvcnModmFsaWRhdGlvbiwgcGF0aCwgaW5wdXQpIHtcbiAgICAgIHZhciBpbnN0YW5jZVR5cGUgPSB0aGlzLmluc3RhbmNlVHlwZSxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHlpZWxkIFtwYXRoLCBnZXRFcnJvck1lc3NhZ2UoJ0VSUl9FWFBFQ1RfQ0xBU1MnLCBpbnN0YW5jZVR5cGUudG9TdHJpbmcoKSksIHRoaXNdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gaW5zdGFuY2VUeXBlLnR5cGVOYW1lID09PSAnQ2xhc3NEZWNsYXJhdGlvbicgPyBpbnN0YW5jZVR5cGUgOiBpbnN0YW5jZVR5cGUudW53cmFwKCk7XG4gICAgICB2YXIgaXNWYWxpZCA9IGV4cGVjdGVkVHlwZSBpbnN0YW5jZW9mIEdlbmVyaWNUeXBlID8gY2hlY2tHZW5lcmljVHlwZShjb250ZXh0LCBleHBlY3RlZFR5cGUsIGlucHV0KSA6IGNoZWNrVHlwZShjb250ZXh0LCBleHBlY3RlZFR5cGUsIGlucHV0KTtcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB5aWVsZCBbcGF0aCwgZ2V0RXJyb3JNZXNzYWdlKCdFUlJfRVhQRUNUX0NMQVNTJywgaW5zdGFuY2VUeXBlLnRvU3RyaW5nKCkpLCB0aGlzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY2NlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNjZXB0cyhpbnB1dCkge1xuICAgICAgdmFyIGluc3RhbmNlVHlwZSA9IHRoaXMuaW5zdGFuY2VUeXBlLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IGluc3RhbmNlVHlwZS50eXBlTmFtZSA9PT0gJ0NsYXNzRGVjbGFyYXRpb24nID8gaW5zdGFuY2VUeXBlIDogaW5zdGFuY2VUeXBlLnVud3JhcCgpO1xuICAgICAgaWYgKGV4cGVjdGVkVHlwZSBpbnN0YW5jZW9mIEdlbmVyaWNUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGVja0dlbmVyaWNUeXBlKGNvbnRleHQsIGV4cGVjdGVkVHlwZSwgaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrVHlwZShjb250ZXh0LCBleHBlY3RlZFR5cGUsIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKGlucHV0KSB7XG4gICAgICB2YXIgaW5zdGFuY2VUeXBlID0gdGhpcy5pbnN0YW5jZVR5cGU7XG5cbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENsYXNzVHlwZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZVR5cGVzKGluc3RhbmNlVHlwZSwgaW5wdXQuaW5zdGFuY2VUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGBDbGFzczwke3RoaXMuaW5zdGFuY2VUeXBlLnRvU3RyaW5nKCl9PmA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZU5hbWU6IHRoaXMudHlwZU5hbWUsXG4gICAgICAgIGluc3RhbmNlVHlwZTogdGhpcy5pbnN0YW5jZVR5cGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbGFzc1R5cGU7XG59KFR5cGUpO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIGludmFsaWQgcmVmZXJlbmNlcyBpbiBvcmRlciB0byBwcmV2ZW50XG4gKiBtdWx0aXBsZSB3YXJuaW5ncy5cbiAqL1xudmFyIHdhcm5lZEludmFsaWRSZWZlcmVuY2VzID0gbmV3IFdlYWtTZXQoKTtcblxudmFyIFR5cGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUeXBlQ29udGV4dCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlQ29udGV4dCk7XG4gICAgdGhpcy5tb2RlID0gJ2Fzc2VydCc7XG4gICAgdGhpc1tOYW1lUmVnaXN0cnlTeW1ib2xdID0ge307XG4gICAgdGhpc1tUeXBlUHJlZGljYXRlUmVnaXN0cnlTeW1ib2xdID0ge307XG4gICAgdGhpc1tUeXBlQ29uc3RydWN0b3JSZWdpc3RyeVN5bWJvbF0gPSBuZXcgTWFwKCk7XG4gICAgdGhpc1tJbmZlcnJlclN5bWJvbF0gPSBuZXcgVHlwZUluZmVyZXIodGhpcyk7XG4gICAgdGhpc1tNb2R1bGVSZWdpc3RyeVN5bWJvbF0gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0byBgdC5jaGVjayguLi4pYCB3aWxsIGNhbGwgZWl0aGVyXG4gICAqIGB0LmFzc2VydCguLi4pYCBvciBgdC53YXJuKC4uLilgIGRlcGVuZGluZyBvbiB0aGlzIHNldHRpbmcuXG4gICAqL1xuXG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIC8vIElzc3VlIDI1MlxuXG5cbiAgLy8gSXNzdWUgMjUyXG5cblxuICAvLyBJc3N1ZSAyNTJcblxuXG4gIC8vIElzc3VlIDI1MlxuXG5cbiAgY3JlYXRlQ2xhc3MoVHlwZUNvbnRleHQsIFt7XG4gICAga2V5OiAnbWFrZUpTT05FcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VKU09ORXJyb3IkJDEodmFsaWRhdGlvbikge1xuICAgICAgcmV0dXJuIG1ha2VKU09ORXJyb3IodmFsaWRhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFrZVR5cGVFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VUeXBlRXJyb3IkJDEodmFsaWRhdGlvbikge1xuICAgICAgcmV0dXJuIG1ha2VUeXBlRXJyb3IodmFsaWRhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IG5ldyBUeXBlQ29udGV4dCgpO1xuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICBjb250ZXh0W1BhcmVudFN5bWJvbF0gPSB0aGlzO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZU9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZU9mKGlucHV0KSB7XG5cbiAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uKGlucHV0KTtcbiAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgJiYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBDbGFzc0RlY2xhcmF0aW9uIHx8IGFubm90YXRpb24gaW5zdGFuY2VvZiBQYXJhbWV0ZXJpemVkQ2xhc3NEZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5DbGFzcyhhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgdmFyIGluZmVycmVyID0gdGhpc1tJbmZlcnJlclN5bWJvbF07XG4gICAgICBpbmZlcnJlcjtcblxuICAgICAgcmV0dXJuIGluZmVycmVyLmluZmVyKGlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wYXJlVHlwZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVHlwZXMkJDEoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmVUeXBlcyhhLCBiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEobmFtZSkge1xuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICB2YXIgaXRlbSA9IHRoaXNbTmFtZVJlZ2lzdHJ5U3ltYm9sXVtuYW1lXTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnR5TmFtZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHByb3BlcnR5TmFtZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgPyBuZXcgaXRlbSh0aGlzKSA6IGl0ZW07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudC5nZXRQcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC51bndyYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbUGFyZW50U3ltYm9sXTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGZyb21QYXJlbnQgPSBwYXJlbnQuZ2V0LmFwcGx5KHBhcmVudCwgW25hbWVdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShwcm9wZXJ0eU5hbWVzKSkpO1xuICAgICAgICBpZiAoZnJvbVBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBmcm9tUGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGdvdCB0aGlzIGZhciwgc2VlIGlmIHdlIGhhdmUgYSBnbG9iYWwgdHlwZSB3aXRoIHRoaXMgbmFtZS5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgR2VuZXJpY1R5cGUodGhpcyk7XG4gICAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgICAgdGFyZ2V0LmltcGwgPSBnbG9iYWxbbmFtZV07XG4gICAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgICB0aGlzW05hbWVSZWdpc3RyeVN5bWJvbF1bbmFtZV0gPSB0YXJnZXQ7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmVkaWNhdGUgZm9yIGEgZ2l2ZW4gdHlwZSBuYW1lLlxuICAgICAqIGUuZy4gYHQuZ2V0UHJlZGljYXRlKCdBcnJheScpYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJlZGljYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJlZGljYXRlKG5hbWUpIHtcbiAgICAgIHZhciBpdGVtID0gdGhpc1tUeXBlUHJlZGljYXRlUmVnaXN0cnlTeW1ib2xdW25hbWVdO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1tQYXJlbnRTeW1ib2xdO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmdldFByZWRpY2F0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByZWRpY2F0ZSBmb3IgYSBnaXZlbiB0eXBlIG5hbWUuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBjdXN0b21pc2UgdGhlIGJlaGF2aW91ciBvZiB0aGluZ3MgbGlrZSBBcnJheVxuICAgICAqIGRldGVjdGlvbiBvciBhbGxvd2luZyBUaGVuYWJsZXMgaW4gcGxhY2Ugb2YgdGhlIGdsb2JhbCBQcm9taXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRQcmVkaWNhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcmVkaWNhdGUobmFtZSwgcHJlZGljYXRlKSB7XG4gICAgICB0aGlzW1R5cGVQcmVkaWNhdGVSZWdpc3RyeVN5bWJvbF1bbmFtZV0gPSBwcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGdpdmVuIHZhbHVlIGFnYWluc3QgdGhlIG5hbWVkIHByZWRpY2F0ZS5cbiAgICAgKiBSZXR1cm5zIGZhbHNlIGlmIG5vIHN1Y2ggcHJlZGljYXRlIGV4aXN0cy5cbiAgICAgKiBlLmcuIGB0LmNoZWNrUHJlZGljYXRlKCdBcnJheScsIFsxLCAyLCAzXSlgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrUHJlZGljYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tQcmVkaWNhdGUobmFtZSwgaW5wdXQpIHtcbiAgICAgIHZhciBwcmVkaWNhdGUgPSB0aGlzLmdldFByZWRpY2F0ZShuYW1lKTtcbiAgICAgIGlmIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZShpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlY29yYXRvciBmb3IgYSBmdW5jdGlvbiBvciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVjb3JhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvcmF0ZSh0eXBlLCBzaG91bGRBc3NlcnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoc2hvdWxkQXNzZXJ0ID09IG51bGwpIHtcbiAgICAgICAgc2hvdWxkQXNzZXJ0ID0gdGhpcy5tb2RlID09PSAnYXNzZXJ0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgcHJvcGVydHlOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBtYWtlUHJvcGVydHlEZXNjcmlwdG9yKHR5cGUsIGlucHV0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IsIEJvb2xlYW4oc2hvdWxkQXNzZXJ0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nLCAnQ2Fubm90IGRlY29yYXRlIGFuIG9iamVjdCBvciBmdW5jdGlvbiBhcyBhIG1ldGhvZC4nKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFubm90YXRlKGlucHV0LCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIHR5cGUuXG4gICAgICogSWYgYSB0eXBlIGlzIHNwZWNpZmllZCBhcyB0aGUgc29sZSBhcmd1bWVudCwgcmV0dXJucyBhXG4gICAgICogZnVuY3Rpb24gd2hpY2ggY2FuIGRlY29yYXRlIGNsYXNzZXMgb3IgZnVuY3Rpb25zIHdpdGggdGhlIGdpdmVuIHR5cGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fubm90YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5ub3RhdGUoaW5wdXQsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFubm90YXRlVmFsdWUoaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFubm90YXRlVmFsdWUoaW5wdXQsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEFubm90YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbm5vdGF0aW9uKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICAgIHJldHVybiBpbnB1dFtUeXBlU3ltYm9sXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNBbm5vdGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQW5ub3RhdGlvbihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlucHV0W1R5cGVTeW1ib2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldEFubm90YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBbm5vdGF0aW9uKGlucHV0LCB0eXBlKSB7XG4gICAgICBpbnB1dFtUeXBlU3ltYm9sXSA9IHR5cGU7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUobmFtZSwgX3R5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgX3R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzKHRoaXMpO1xuICAgICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICAgIHRhcmdldC50eXBlQ3JlYXRvciA9IF90eXBlO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90YXJnZXQgPSBuZXcgVHlwZUFsaWFzKHRoaXMpO1xuICAgICAgICBfdGFyZ2V0Lm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGFyZ2V0LnR5cGUgPSBfdHlwZTtcbiAgICAgICAgcmV0dXJuIF90YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVjbGFyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2xhcmUobmFtZSwgdHlwZSkge1xuXG4gICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHR5cGUgPSBuYW1lO1xuICAgICAgICBuYW1lID0gdHlwZS5uYW1lO1xuICAgICAgfSBlbHNlIGlmIChuYW1lIGluc3RhbmNlb2YgVHlwZUFsaWFzKSB7XG4gICAgICAgIHR5cGUgPSBuYW1lO1xuICAgICAgICBuYW1lID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHR5cGUgPSB0aGlzLnR5cGUobmFtZSwgdHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIE1vZHVsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgIHZhciBtb2R1bGVSZWdpc3RyeSA9IHRoaXNbTW9kdWxlUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgICBtb2R1bGVSZWdpc3RyeVtuYW1lXSA9IHR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ05hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICBpbnZhcmlhbnQodHlwZSBpbnN0YW5jZW9mIFR5cGUsICdUeXBlIG11c3QgYmUgc3VwcGxpZWQgdG8gZGVjbGFyYXRpb24nKTtcbiAgICAgICAgdmFyIG5hbWVSZWdpc3RyeSA9IHRoaXNbTmFtZVJlZ2lzdHJ5U3ltYm9sXTtcblxuICAgICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgbmFtZVJlZ2lzdHJ5W25hbWVdID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgVHlwZUFsaWFzIHx8IHR5cGUgaW5zdGFuY2VvZiBQYXJhbWV0ZXJpemVkVHlwZUFsaWFzKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBUeXBlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICAgICAgdGFyZ2V0Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRhcmdldC50eXBlQWxpYXMgPSB0eXBlO1xuICAgICAgICAgIG5hbWVSZWdpc3RyeVtuYW1lXSA9IHRhcmdldDtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGFyZ2V0MiA9IHRoaXMudmFyKG5hbWUsIHR5cGUpO1xuICAgICAgICAgIG5hbWVSZWdpc3RyeVtuYW1lXSA9IF90YXJnZXQyO1xuICAgICAgICAgIHJldHVybiBfdGFyZ2V0MjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlY2xhcmF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBkZWNsYXJhdGlvbnMoKSB7XG4gICAgICB2YXIgbmFtZVJlZ2lzdHJ5ID0gdGhpc1tOYW1lUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWVSZWdpc3RyeSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICB5aWVsZCBba2V5LCBuYW1lUmVnaXN0cnlba2V5XV07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW9kdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKiBtb2R1bGVzKCkge1xuICAgICAgdmFyIG1vZHVsZVJlZ2lzdHJ5ID0gdGhpc1tNb2R1bGVSZWdpc3RyeVN5bWJvbF07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbW9kdWxlUmVnaXN0cnkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgeWllbGQgbW9kdWxlUmVnaXN0cnlba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbXBvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW1wb3J0KG1vZHVsZU5hbWUpIHtcbiAgICAgIHZhciBtb2R1bGVSZWdpc3RyeSA9IHRoaXNbTW9kdWxlUmVnaXN0cnlTeW1ib2xdO1xuICAgICAgaWYgKG1vZHVsZVJlZ2lzdHJ5W21vZHVsZU5hbWVdKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVSZWdpc3RyeVttb2R1bGVOYW1lXTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9tb2R1bGVOYW1lJHNwbGl0ID0gbW9kdWxlTmFtZS5zcGxpdCgnLycpLFxuICAgICAgICAgIF9tb2R1bGVOYW1lJHNwbGl0MiA9IHNsaWNlZFRvQXJyYXkoX21vZHVsZU5hbWUkc3BsaXQsIDEpLFxuICAgICAgICAgIGhlYWQgPSBfbW9kdWxlTmFtZSRzcGxpdDJbMF07XG5cbiAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVSZWdpc3RyeVtoZWFkXTtcbiAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5pbXBvcnQobW9kdWxlTmFtZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1tQYXJlbnRTeW1ib2xdO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmltcG9ydChtb2R1bGVOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWNsYXJlVHlwZUNvbnN0cnVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjbGFyZVR5cGVDb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICBpbXBsID0gX3JlZi5pbXBsLFxuICAgICAgICAgIHR5cGVOYW1lID0gX3JlZi50eXBlTmFtZSxcbiAgICAgICAgICBlcnJvcnMgPSBfcmVmLmVycm9ycyxcbiAgICAgICAgICBhY2NlcHRzID0gX3JlZi5hY2NlcHRzLFxuICAgICAgICAgIGluZmVyVHlwZVBhcmFtZXRlcnMgPSBfcmVmLmluZmVyVHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgY29tcGFyZVdpdGggPSBfcmVmLmNvbXBhcmVXaXRoO1xuXG4gICAgICB2YXIgbmFtZVJlZ2lzdHJ5ID0gdGhpc1tOYW1lUmVnaXN0cnlTeW1ib2xdO1xuXG4gICAgICBpZiAobmFtZVJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICAgIHRoaXMuZW1pdFdhcm5pbmdNZXNzYWdlKGBSZWRlY2xhcmluZyB0eXBlOiAke25hbWV9LCB0aGlzIG1heSBiZSB1bmludGVuZGVkLmApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgIHRhcmdldC50eXBlTmFtZSA9IHR5cGVOYW1lO1xuICAgICAgdGFyZ2V0LmltcGwgPSBpbXBsO1xuICAgICAgdGFyZ2V0LmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRhcmdldC5hY2NlcHRzID0gYWNjZXB0cztcbiAgICAgIHRhcmdldC5pbmZlclR5cGVQYXJhbWV0ZXJzID0gaW5mZXJUeXBlUGFyYW1ldGVycztcbiAgICAgIGlmICh0eXBlb2YgY29tcGFyZVdpdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFyZ2V0LmNvbXBhcmVXaXRoID0gY29tcGFyZVdpdGg7XG4gICAgICB9XG5cbiAgICAgIG5hbWVSZWdpc3RyeVtuYW1lXSA9IHRhcmdldDtcblxuICAgICAgaWYgKHR5cGVvZiBpbXBsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgICB2YXIgaGFuZGxlclJlZ2lzdHJ5ID0gdGhpc1tUeXBlQ29uc3RydWN0b3JSZWdpc3RyeVN5bWJvbF07XG4gICAgICAgIGhhbmRsZXJSZWdpc3RyeTtcblxuICAgICAgICBpZiAoaGFuZGxlclJlZ2lzdHJ5LmhhcyhpbXBsKSkge1xuICAgICAgICAgIHRoaXMuZW1pdFdhcm5pbmdNZXNzYWdlKGBBIHR5cGUgaGFuZGxlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIGdpdmVuIGltcGxlbWVudGF0aW9uIG9mICR7bmFtZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZ2lzdHJ5LnNldChpbXBsLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUeXBlQ29uc3RydWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlQ29uc3RydWN0b3IoaW1wbCkge1xuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICB2YXIgaGFuZGxlclJlZ2lzdHJ5ID0gdGhpc1tUeXBlQ29uc3RydWN0b3JSZWdpc3RyeVN5bWJvbF07XG4gICAgICBoYW5kbGVyUmVnaXN0cnk7XG5cbiAgICAgIHJldHVybiBoYW5kbGVyUmVnaXN0cnkuZ2V0KGltcGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpdGVyYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXRlcmFsKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52b2lkKCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGwoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9vbGVhbihpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcoaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gSXNzdWUgMjUyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlT2YoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbnVsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9udWxsKCkge1xuICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLm51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbnVsbGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudWxsYWJsZSh0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE51bGxhYmxlVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXhpc3RlbnRpYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGlzdGVudGlhbCgpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5leGlzdGVudGlhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbXB0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLmVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FueScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFueSgpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5hbnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWl4ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaXhlZCgpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVUeXBlcy5taXhlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2b2lkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZvaWQoKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMudm9pZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0aGlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RoaXMoaW5wdXQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVGhpc1R5cGUodGhpcyk7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXQucmVjb3JkZWQgPSBpbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbnVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtYmVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IE51bWVyaWNMaXRlcmFsVHlwZSh0aGlzKTtcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gaW5wdXQ7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMubnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Jvb2xlYW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBib29sZWFuKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IEJvb2xlYW5MaXRlcmFsVHlwZSh0aGlzKTtcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gaW5wdXQ7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlVHlwZXMuYm9vbGVhbjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJpbmcoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgU3RyaW5nTGl0ZXJhbFR5cGUodGhpcyk7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IGlucHV0O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLnN0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzeW1ib2wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW1ib2woaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgU3ltYm9sTGl0ZXJhbFR5cGUodGhpcyk7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IGlucHV0O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLnN5bWJvbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlUGFyYW1ldGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZVBhcmFtZXRlcihpZCwgYm91bmQsIGRlZmF1bHRUeXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IFR5cGVQYXJhbWV0ZXIodGhpcyk7XG4gICAgICB0YXJnZXQuaWQgPSBpZDtcbiAgICAgIHRhcmdldC5ib3VuZCA9IGJvdW5kO1xuICAgICAgdGFyZ2V0LmRlZmF1bHQgPSBkZWZhdWx0VHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmxvd0ludG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbG93SW50byh0eXBlUGFyYW1ldGVyKSB7XG4gICAgICByZXR1cm4gZmxvd0ludG9UeXBlUGFyYW1ldGVyKHR5cGVQYXJhbWV0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhlIHR5cGUgcGFyYW1ldGVycyBmb3IgdGhlIHBhcmVudCBjbGFzcyBvZiB0aGUgZ2l2ZW4gaW5zdGFuY2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JpbmRUeXBlUGFyYW1ldGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRUeXBlUGFyYW1ldGVycyhzdWJqZWN0KSB7XG4gICAgICB2YXIgaW5zdGFuY2VQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViamVjdCk7XG4gICAgICAvLyBJc3N1ZVxuICAgICAgdmFyIHBhcmVudFByb3RvdHlwZSA9IGluc3RhbmNlUHJvdG90eXBlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZVByb3RvdHlwZSk7XG4gICAgICAvLyBJc3N1ZVxuICAgICAgdmFyIHBhcmVudENsYXNzID0gcGFyZW50UHJvdG90eXBlICYmIHBhcmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuICAgICAgaWYgKCFwYXJlbnRDbGFzcykge1xuICAgICAgICB0aGlzLmVtaXRXYXJuaW5nTWVzc2FnZSgnQ291bGQgbm90IGJpbmQgdHlwZSBwYXJhbWV0ZXJzIGZvciBub24tZXhpc3RlbnQgcGFyZW50IGNsYXNzLicpO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzUG9pbnRlciA9IHBhcmVudENsYXNzW1R5cGVQYXJhbWV0ZXJzU3ltYm9sXTtcblxuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzUG9pbnRlcikge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSBzdWJqZWN0W3R5cGVQYXJhbWV0ZXJzUG9pbnRlcl07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModHlwZVBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleXMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHlwZVBhcmFtID0gdHlwZVBhcmFtZXRlcnNba2V5c1tpXV07XG4gICAgICAgICAgdHlwZVBhcmFtLmJvdW5kID0gdHlwZUluc3RhbmNlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kdWxlKG5hbWUsIGJvZHkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgTW9kdWxlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICB2YXIgaW5uZXJDb250ZXh0ID0gdGhpcy5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAvLyBJc3N1ZSAyNTJcbiAgICAgIGlubmVyQ29udGV4dFtQYXJlbnRTeW1ib2xdID0gdGhpcztcbiAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgaW5uZXJDb250ZXh0W0N1cnJlbnRNb2R1bGVTeW1ib2xdID0gdGFyZ2V0O1xuXG4gICAgICB0YXJnZXQuaW5uZXJDb250ZXh0ID0gaW5uZXJDb250ZXh0O1xuICAgICAgYm9keShpbm5lckNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb2R1bGVFeHBvcnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kdWxlRXhwb3J0cyh0eXBlKSB7XG4gICAgICB2YXIgY3VycmVudE1vZHVsZSA9IHRoaXNbQ3VycmVudE1vZHVsZVN5bWJvbF07XG4gICAgICBpZiAoIWN1cnJlbnRNb2R1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjbGFyZSBtb2R1bGUuZXhwb3J0cyBvdXRzaWRlIG9mIGEgbW9kdWxlLicpO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IG5ldyBNb2R1bGVFeHBvcnRzKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgY3VycmVudE1vZHVsZS5tb2R1bGVFeHBvcnRzID0gdGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFyKG5hbWUsIHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVmFyRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB0YXJnZXQubmFtZSA9IG5hbWU7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsYXNzKG5hbWUsIGhlYWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaGVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX3RhcmdldDMgPSBuZXcgUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICAgIF90YXJnZXQzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGFyZ2V0My5ib2R5Q3JlYXRvciA9IGhlYWQ7XG4gICAgICAgIHJldHVybiBfdGFyZ2V0MztcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgQ2xhc3NEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB0YWlsID0gQXJyYXkoX2xlbjMgPiAyID8gX2xlbjMgLSAyIDogMCksIF9rZXkzID0gMjsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICB0YWlsW19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZCAhPSBudWxsKSB7XG4gICAgICAgIHRhaWwudW5zaGlmdChoZWFkKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSB0YWlsLmxlbmd0aDtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGFpbFtpXTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3RUeXBlUHJvcGVydHkgfHwgaXRlbSBpbnN0YW5jZW9mIE9iamVjdFR5cGVJbmRleGVyKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3RUeXBlKSB7XG4gICAgICAgICAgaW52YXJpYW50KCFib2R5LCAnQ2xhc3MgYm9keSBtdXN0IG9ubHkgYmUgZGVjbGFyZWQgb25jZS4nKTtcbiAgICAgICAgICBib2R5ID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRXh0ZW5kc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgaW52YXJpYW50KCF0YXJnZXQuc3VwZXJDbGFzcywgJ0NsYXNzZXMgY2FuIG9ubHkgaGF2ZSBvbmUgc3VwZXIgY2xhc3MuJyk7XG4gICAgICAgICAgdGFyZ2V0LnN1cGVyQ2xhc3MgPSBpdGVtO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIShpdGVtIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucHJvcGVydHkocHJvcGVydHlOYW1lLCBpdGVtW3Byb3BlcnR5TmFtZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzc0RlY2xhcmF0aW9uIGNhbm5vdCBjb250YWluIHRoZSBnaXZlbiB0eXBlIGRpcmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IG5ldyBPYmplY3RUeXBlKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfYm9keSRwcm9wZXJ0aWVzO1xuXG4gICAgICAgIChfYm9keSRwcm9wZXJ0aWVzID0gYm9keS5wcm9wZXJ0aWVzKS5wdXNoLmFwcGx5KF9ib2R5JHByb3BlcnRpZXMsIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0LmJvZHkgPSBib2R5O1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleHRlbmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dGVuZHMoc3ViamVjdCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBFeHRlbmRzRGVjbGFyYXRpb24odGhpcyk7XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZUluc3RhbmNlcyA9IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgdHlwZUluc3RhbmNlc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnR5cGUgPSB0aGlzLnJlZi5hcHBseSh0aGlzLCBbc3ViamVjdF0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHR5cGVJbnN0YW5jZXMpKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm4oaGVhZCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCB0YWlsID0gQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICB0YWlsW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbi5hcHBseSh0aGlzLCBbaGVhZF0uY29uY2F0KHRhaWwpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mdW5jdGlvbihoZWFkKSB7XG4gICAgICBpZiAodHlwZW9mIGhlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90YXJnZXQ0ID0gbmV3IFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUodGhpcyk7XG4gICAgICAgIF90YXJnZXQ0LmJvZHlDcmVhdG9yID0gaGVhZDtcbiAgICAgICAgcmV0dXJuIF90YXJnZXQ0O1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IG5ldyBGdW5jdGlvblR5cGUodGhpcyk7XG4gICAgICBpZiAoaGVhZCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW42ID4gMSA/IF9sZW42IC0gMSA6IDApLCBfa2V5NiA9IDE7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICB0YWlsW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC51bnNoaWZ0KGhlYWQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGFpbC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gdGFpbFtpXTtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZVBhcmFtKSB7XG4gICAgICAgICAgICB0YXJnZXQucGFyYW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUmVzdFBhcmFtKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVzdCA9IGl0ZW07XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRnVuY3Rpb25UeXBlUmV0dXJuKSB7XG4gICAgICAgICAgICB0YXJnZXQucmV0dXJuVHlwZSA9IGl0ZW07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb25UeXBlIGNhbm5vdCBjb250YWluIHRoZSBnaXZlbiB0eXBlIGRpcmVjdGx5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0YXJnZXQucmV0dXJuVHlwZSkge1xuICAgICAgICB0YXJnZXQucmV0dXJuVHlwZSA9IHRoaXMuYW55KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhcmFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgdmFyIG9wdGlvbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIHRhcmdldCA9IG5ldyBGdW5jdGlvblR5cGVQYXJhbSh0aGlzKTtcbiAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHRhcmdldC5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdChuYW1lLCB0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSh0aGlzKTtcbiAgICAgIHRhcmdldC5uYW1lID0gbmFtZTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmV0dXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldHVybih0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IEZ1bmN0aW9uVHlwZVJldHVybih0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2VuZXJhdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdG9yKHlpZWxkVHlwZSwgcmV0dXJuVHlwZSwgbmV4dFR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgR2VuZXJhdG9yVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC55aWVsZFR5cGUgPSB5aWVsZFR5cGU7XG4gICAgICB0YXJnZXQucmV0dXJuVHlwZSA9IHJldHVyblR5cGUgfHwgdGhpcy5hbnkoKTtcbiAgICAgIHRhcmdldC5uZXh0VHlwZSA9IG5leHRUeXBlIHx8IHRoaXMuYW55KCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9iamVjdChoZWFkKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGUodGhpcyk7XG4gICAgICBpZiAoaGVhZCAhPSBudWxsICYmIHR5cGVvZiBoZWFkID09PSAnb2JqZWN0JyAmJiAhKGhlYWQgaW5zdGFuY2VvZiBUeXBlKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gaGVhZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB0YXJnZXQucHJvcGVydGllcy5wdXNoKHRoaXMucHJvcGVydHkocHJvcGVydHlOYW1lLCBoZWFkW3Byb3BlcnR5TmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCB0YWlsID0gQXJyYXkoX2xlbjcgPiAxID8gX2xlbjcgLSAxIDogMCksIF9rZXk3ID0gMTsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICAgIHRhaWxbX2tleTcgLSAxXSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZCkge1xuICAgICAgICAgIGJvZHkgPSBbaGVhZF0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KHRhaWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib2R5ID0gdGFpbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2JvZHkgPSBib2R5LFxuICAgICAgICAgICAgbGVuZ3RoID0gX2JvZHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGJvZHlbaV07XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3RUeXBlUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wcm9wZXJ0aWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0VHlwZUluZGV4ZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5pbmRleGVycy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdFR5cGVDYWxsUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRhcmdldC5jYWxsUHJvcGVydGllcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdFR5cGUgY2Fubm90IGNvbnRhaW4gdGhlIGdpdmVuIHR5cGUgZGlyZWN0bHkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4YWN0T2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhhY3RPYmplY3QoaGVhZCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCB0YWlsID0gQXJyYXkoX2xlbjggPiAxID8gX2xlbjggLSAxIDogMCksIF9rZXk4ID0gMTsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICB0YWlsW19rZXk4IC0gMV0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QuYXBwbHkodGhpcywgW2hlYWRdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheSh0YWlsKSkpO1xuICAgICAgb2JqZWN0LmV4YWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsbFByb3BlcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbFByb3BlcnR5KHZhbHVlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGVDYWxsUHJvcGVydHkodGhpcyk7XG4gICAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvcGVydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9uYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGVQcm9wZXJ0eSh0aGlzKTtcbiAgICAgIHRhcmdldC5rZXkgPSBrZXk7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgIHRhcmdldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnZhbHVlID0gdGhpcy5vYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Lm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZGV4ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleGVyKGlkLCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGVJbmRleGVyKHRoaXMpO1xuICAgICAgdGFyZ2V0LmlkID0gaWQ7XG4gICAgICB0YXJnZXQua2V5ID0ga2V5O1xuICAgICAgdGFyZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21ldGhvZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ldGhvZChuYW1lLCBoZWFkKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3IE9iamVjdFR5cGVQcm9wZXJ0eSh0aGlzKTtcbiAgICAgIHRhcmdldC5rZXkgPSBuYW1lO1xuXG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhaWwgPSBBcnJheShfbGVuOSA+IDIgPyBfbGVuOSAtIDIgOiAwKSwgX2tleTkgPSAyOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgIHRhaWxbX2tleTkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5OV07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC52YWx1ZSA9IHRoaXMuZnVuY3Rpb24uYXBwbHkodGhpcywgW2hlYWRdLmNvbmNhdCh0YWlsKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0YXRpY0NhbGxQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXRpY0NhbGxQcm9wZXJ0eSh2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmNhbGxQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICBwcm9wLnN0YXRpYyA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGF0aWNQcm9wZXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXRpY1Byb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvcHRpb25hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0eShrZXksIHZhbHVlLCBvcHRpb25hbCk7XG4gICAgICBwcm9wLnN0YXRpYyA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGF0aWNNZXRob2QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0aWNNZXRob2QobmFtZSwgaGVhZCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgdGFpbCA9IEFycmF5KF9sZW4xMCA+IDIgPyBfbGVuMTAgLSAyIDogMCksIF9rZXkxMCA9IDI7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgdGFpbFtfa2V5MTAgLSAyXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcCA9IHRoaXMubWV0aG9kLmFwcGx5KHRoaXMsIFtuYW1lLCBoZWFkXS5jb25jYXQodGFpbCkpO1xuICAgICAgcHJvcC5zdGF0aWMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3ByZWFkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ByZWFkKCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBPYmplY3RUeXBlKHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlcyA9IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIHtcbiAgICAgICAgdHlwZXNbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV0udW53cmFwKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUuY2FsbFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgdmFyIF90YXJnZXQkY2FsbFByb3BlcnRpZTtcblxuICAgICAgICAgIChfdGFyZ2V0JGNhbGxQcm9wZXJ0aWUgPSB0YXJnZXQuY2FsbFByb3BlcnRpZXMpLnB1c2guYXBwbHkoX3RhcmdldCRjYWxsUHJvcGVydGllLCB0b0NvbnN1bWFibGVBcnJheSh0eXBlLmNhbGxQcm9wZXJ0aWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5pbmRleGVycykpIHtcbiAgICAgICAgICB2YXIgX3RhcmdldCRpbmRleGVycztcblxuICAgICAgICAgIChfdGFyZ2V0JGluZGV4ZXJzID0gdGFyZ2V0LmluZGV4ZXJzKS5wdXNoLmFwcGx5KF90YXJnZXQkaW5kZXhlcnMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUuaW5kZXhlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0eXBlLnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gdHlwZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICAgICAgaW52YXJpYW50KHByb3AgaW5zdGFuY2VvZiBPYmplY3RUeXBlUHJvcGVydHkpO1xuICAgICAgICAgICAgdGFyZ2V0LnNldFByb3BlcnR5KHByb3Aua2V5LCBwcm9wLnZhbHVlLCBwcm9wLm9wdGlvbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHVwbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0dXBsZSgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHVwbGVUeXBlKHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlcyA9IEFycmF5KF9sZW4xMiksIF9rZXkxMiA9IDA7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICAgICAgdHlwZXNbX2tleTEyXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZXMgPSB0eXBlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheShlbGVtZW50VHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBBcnJheVR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQuZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZSB8fCB0aGlzLmFueSgpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bmlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEzID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBBcnJheShfbGVuMTMpLCBfa2V5MTMgPSAwOyBfa2V5MTMgPCBfbGVuMTM7IF9rZXkxMysrKSB7XG4gICAgICAgIHR5cGVzW19rZXkxM10gPSBhcmd1bWVudHNbX2tleTEzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VVbmlvbih0aGlzLCB0eXBlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW50ZXJzZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0KCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBJbnRlcnNlY3Rpb25UeXBlKHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMTQgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlcyA9IEFycmF5KF9sZW4xNCksIF9rZXkxNCA9IDA7IF9rZXkxNCA8IF9sZW4xNDsgX2tleTE0KyspIHtcbiAgICAgICAgdHlwZXNbX2tleTE0XSA9IGFyZ3VtZW50c1tfa2V5MTRdO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQudHlwZXMgPSB0eXBlcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW50ZXJzZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYm94JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYm94KHJldmVhbCkge1xuICAgICAgdmFyIGJveCA9IG5ldyBUeXBlQm94KHRoaXMpO1xuICAgICAgYm94LnJldmVhbCA9IHJldmVhbDtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGR6JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGR6KHJldmVhbCwgbmFtZSkge1xuICAgICAgdmFyIHRkeiA9IG5ldyBUeXBlVERaKHRoaXMpO1xuICAgICAgdGR6LnJldmVhbCA9IHJldmVhbDtcbiAgICAgIHRkei5uYW1lID0gbmFtZTtcbiAgICAgIHJldHVybiB0ZHo7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmKHN1YmplY3QpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHRyeSBhbmQgZWFnZXJseSByZXNvbHZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5nZXQoc3ViamVjdCk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgLy8gZGVmZXIgZGVyZWZlcmVuY2luZyBmb3Igbm93XG4gICAgICAgICAgdGFyZ2V0ID0gbmV3IFR5cGVSZWZlcmVuY2UodGhpcyk7XG4gICAgICAgICAgdGFyZ2V0Lm5hbWUgPSBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElzc3VlIDI1MlxuICAgICAgICB2YXIgaGFuZGxlclJlZ2lzdHJ5ID0gdGhpc1tUeXBlQ29uc3RydWN0b3JSZWdpc3RyeVN5bWJvbF07XG4gICAgICAgIGhhbmRsZXJSZWdpc3RyeTtcblxuICAgICAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhIGRlZGljYXRlZCBUeXBlQ29uc3RydWN0b3IgZm9yIHRoaXMuXG4gICAgICAgIHRhcmdldCA9IGhhbmRsZXJSZWdpc3RyeS5nZXQoc3ViamVjdCk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAvLyBqdXN0IHVzZSBhIGdlbmVyaWMgdHlwZSBoYW5kbGVyLlxuICAgICAgICAgIHRhcmdldCA9IG5ldyBHZW5lcmljVHlwZSh0aGlzKTtcbiAgICAgICAgICB0YXJnZXQuaW1wbCA9IHN1YmplY3Q7XG4gICAgICAgICAgdGFyZ2V0Lm5hbWUgPSBzdWJqZWN0Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgdGFyZ2V0ID0gc3ViamVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdWJqZWN0ID09IG51bGwgfHwgdHlwZW9mIHN1YmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhpcy5lbWl0V2FybmluZ01lc3NhZ2UoYENvdWxkIG5vdCByZWZlcmVuY2UgdGhlIGdpdmVuIHR5cGUsIHRyeSB0LnR5cGVPZih2YWx1ZSkgaW5zdGVhZC4gKGdvdCAke1N0cmluZyhzdWJqZWN0KX0pYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXdhcm5lZEludmFsaWRSZWZlcmVuY2VzLmhhcyhzdWJqZWN0KSkge1xuICAgICAgICAgIHRoaXMuZW1pdFdhcm5pbmdNZXNzYWdlKCdDb3VsZCBub3QgcmVmZXJlbmNlIHRoZSBnaXZlbiB0eXBlLCB0cnkgdC50eXBlT2YodmFsdWUpIGluc3RlYWQuJyk7XG4gICAgICAgICAgd2FybmVkSW52YWxpZFJlZmVyZW5jZXMuYWRkKHN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFueSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuMTUgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlSW5zdGFuY2VzID0gQXJyYXkoX2xlbjE1ID4gMSA/IF9sZW4xNSAtIDEgOiAwKSwgX2tleTE1ID0gMTsgX2tleTE1IDwgX2xlbjE1OyBfa2V5MTUrKykge1xuICAgICAgICB0eXBlSW5zdGFuY2VzW19rZXkxNSAtIDFdID0gYXJndW1lbnRzW19rZXkxNV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICB2YXIgX3RhcmdldDU7XG5cbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0YXJnZXQuYXBwbHkgPT09ICdmdW5jdGlvbicsIGBDYW5ub3QgYXBwbHkgbm9uLWFwcGxpY2FibGUgdHlwZTogJHt0YXJnZXQudHlwZU5hbWV9LmApO1xuICAgICAgICByZXR1cm4gKF90YXJnZXQ1ID0gdGFyZ2V0KS5hcHBseS5hcHBseShfdGFyZ2V0NSwgdG9Db25zdW1hYmxlQXJyYXkodHlwZUluc3RhbmNlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWxpZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKHR5cGUsIGlucHV0KSB7XG4gICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnJztcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IG5ldyBWYWxpZGF0aW9uKHRoaXMsIGlucHV0KTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBfdmFsaWRhdGlvbiRwYXRoO1xuXG4gICAgICAgIChfdmFsaWRhdGlvbiRwYXRoID0gdmFsaWRhdGlvbi5wYXRoKS5wdXNoLmFwcGx5KF92YWxpZGF0aW9uJHBhdGgsIHRvQ29uc3VtYWJsZUFycmF5KHBhdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGlvbi5wYXRoLnB1c2godHlwZS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRpb24ucHJlZml4ID0gcHJlZml4O1xuICAgICAgdmFsaWRhdGlvbi5lcnJvcnMgPSBBcnJheS5mcm9tKHR5cGUuZXJyb3JzKHZhbGlkYXRpb24sIFtdLCBpbnB1dCkpO1xuICAgICAgcmV0dXJuIHZhbGlkYXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjayh0eXBlLCBpbnB1dCkge1xuICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Fzc2VydCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHR5cGUsIGlucHV0LCBwcmVmaXgsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Fybih0eXBlLCBpbnB1dCwgcHJlZml4LCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnQodHlwZSwgaW5wdXQpIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICAgICAgdmFyIHBhdGggPSBhcmd1bWVudHNbM107XG5cbiAgICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSh0eXBlLCBpbnB1dCwgcHJlZml4LCBwYXRoKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMubWFrZVR5cGVFcnJvcih2YWxpZGF0aW9uKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd3YXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2Fybih0eXBlLCBpbnB1dCkge1xuICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gICAgICB2YXIgcGF0aCA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKHR5cGUsIGlucHV0LCBwcmVmaXgsIHBhdGgpO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBtYWtlV2FybmluZ01lc3NhZ2UodmFsaWRhdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuZW1pdFdhcm5pbmdNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgd2FybmluZyBtZXNzYWdlLCB1c2luZyBgY29uc29sZS53YXJuKClgIGJ5IGRlZmF1bHQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VtaXRXYXJuaW5nTWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRXYXJuaW5nTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2Zsb3ctcnVudGltZTonLCBtZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9wVHlwZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wVHlwZXModHlwZSkge1xuICAgICAgcmV0dXJuIG1ha2VSZWFjdFByb3BUeXBlcyh0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4xNiksIF9rZXkxNiA9IDA7IF9rZXkxNiA8IF9sZW4xNjsgX2tleTE2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGF1c2VzID0gYXJncy5wb3AoKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjbGF1c2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0dGVybiwgbGFzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgfVxuICAgICAgY2xhdXNlcztcbiAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLmFwcGx5KHRoaXMsIHRvQ29uc3VtYWJsZUFycmF5KGNsYXVzZXMpKTtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGF0dGVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm4oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTcgPSBhcmd1bWVudHMubGVuZ3RoLCBjbGF1c2VzID0gQXJyYXkoX2xlbjE3KSwgX2tleTE3ID0gMDsgX2tleTE3IDwgX2xlbjE3OyBfa2V5MTcrKykge1xuICAgICAgICBjbGF1c2VzW19rZXkxN10gPSBhcmd1bWVudHNbX2tleTE3XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGNsYXVzZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgdGVzdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsYXVzZSA9IGNsYXVzZXNbaV07XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uKGNsYXVzZSk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbikge1xuICAgICAgICAgIGlmIChpICE9PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgUGF0dGVybiAtIGZvdW5kIHVuYW5ub3RhdGVkIGZ1bmN0aW9uIGluIHBvc2l0aW9uICR7aX0sIGRlZmF1bHQgY2xhdXNlcyBtdXN0IGJlIGxhc3QuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlc3RzW2ldID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZhcmlhbnQoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uVHlwZSB8fCBhbm5vdGF0aW9uIGluc3RhbmNlb2YgUGFyYW1ldGVyaXplZEZ1bmN0aW9uVHlwZSwgJ1BhdHRlcm4gY2xhdXNlcyBtdXN0IGJlIGFubm90YXRlZCBmdW5jdGlvbnMuJyk7XG4gICAgICAgICAgdGVzdHNbaV0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGVzdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHRlc3QgPSB0ZXN0c1tfaV07XG4gICAgICAgICAgdmFyIF9jbGF1c2UgPSBjbGF1c2VzW19pXTtcbiAgICAgICAgICBpZiAodGVzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jbGF1c2UuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGVzdC5hY2NlcHRzUGFyYW1zLmFwcGx5KHRlc3QsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBfY2xhdXNlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gbmV3IFR5cGVFcnJvcignVmFsdWUgZGlkIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGNhbmRpZGF0ZXMuJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnUnVudGltZVR5cGVFcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd3cmFwSXRlcmF0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cmFwSXRlcmF0b3IodHlwZSkge1xuICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiB3cmFwcGVkSXRlcmF0b3IoaW5wdXQpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICB5aWVsZCB0LmNoZWNrKHR5cGUsIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVmaW5lbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZmluZW1lbnQodHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBSZWZpbmVtZW50VHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcblxuICAgICAgZm9yICh2YXIgX2xlbjE4ID0gYXJndW1lbnRzLmxlbmd0aCwgY29uc3RyYWludHMgPSBBcnJheShfbGVuMTggPiAxID8gX2xlbjE4IC0gMSA6IDApLCBfa2V5MTggPSAxOyBfa2V5MTggPCBfbGVuMTg7IF9rZXkxOCsrKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzW19rZXkxOCAtIDFdID0gYXJndW1lbnRzW19rZXkxOF07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5hZGRDb25zdHJhaW50LmFwcGx5KHRhcmdldCwgdG9Db25zdW1hYmxlQXJyYXkoY29uc3RyYWludHMpKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJGV4YWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJGV4YWN0KHR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgT2JqZWN0VHlwZSh0aGlzKTtcbiAgICAgIHR5cGUgPSB0eXBlLnVud3JhcCgpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5jYWxsUHJvcGVydGllcykpIHtcbiAgICAgICAgdmFyIF90YXJnZXQkY2FsbFByb3BlcnRpZTI7XG5cbiAgICAgICAgKF90YXJnZXQkY2FsbFByb3BlcnRpZTIgPSB0YXJnZXQuY2FsbFByb3BlcnRpZXMpLnB1c2guYXBwbHkoX3RhcmdldCRjYWxsUHJvcGVydGllMiwgdG9Db25zdW1hYmxlQXJyYXkodHlwZS5jYWxsUHJvcGVydGllcykpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5pbmRleGVycykpIHtcbiAgICAgICAgdmFyIF90YXJnZXQkaW5kZXhlcnMyO1xuXG4gICAgICAgIChfdGFyZ2V0JGluZGV4ZXJzMiA9IHRhcmdldC5pbmRleGVycykucHVzaC5hcHBseShfdGFyZ2V0JGluZGV4ZXJzMiwgdG9Db25zdW1hYmxlQXJyYXkodHlwZS5pbmRleGVycykpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICB2YXIgX3RhcmdldCRwcm9wZXJ0aWVzO1xuXG4gICAgICAgIChfdGFyZ2V0JHByb3BlcnRpZXMgPSB0YXJnZXQucHJvcGVydGllcykucHVzaC5hcHBseShfdGFyZ2V0JHByb3BlcnRpZXMsIHRvQ29uc3VtYWJsZUFycmF5KHR5cGUucHJvcGVydGllcykpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0LmV4YWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJGRpZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkZGlmZihhVHlwZSwgYlR5cGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJERpZmZUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LmFUeXBlID0gYVR5cGU7XG4gICAgICB0YXJnZXQuYlR5cGUgPSBiVHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJGZsb3dGaXhNZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRmbG93Rml4TWUoKSB7XG4gICAgICByZXR1cm4gbmV3ICRGbG93Rml4TWVUeXBlKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRrZXlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJGtleXModHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkS2V5c1R5cGUodGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRvYmpNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkb2JqTWFwKG9iamVjdCwgbWFwcGVyKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICRPYmpNYXBUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0Lm9iamVjdCA9IG9iamVjdDtcbiAgICAgIHRhcmdldC5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRvYmpNYXBpJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJG9iak1hcGkob2JqZWN0LCBtYXBwZXIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJE9iak1hcGlUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0Lm9iamVjdCA9IG9iamVjdDtcbiAgICAgIHRhcmdldC5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRwcm9wZXJ0eVR5cGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkcHJvcGVydHlUeXBlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgJFByb3BlcnR5VHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgIHZhciB1bndyYXBwZWQgPSBwcm9wZXJ0eS51bndyYXAoKTtcbiAgICAgICAgdGFyZ2V0LnByb3BlcnR5ID0gdW53cmFwcGVkLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRzaGFwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRzaGFwZSh0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICRTaGFwZVR5cGUodGhpcyk7XG4gICAgICB0YXJnZXQudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJyRzdWJ0eXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJHN1YnR5cGUodHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkU3ViVHlwZSh0aGlzKTtcbiAgICAgIHRhcmdldC50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnJHN1cGVydHlwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRzdXBlcnR5cGUodHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkU3VwZXJUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckdHVwbGVNYXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAkdHVwbGVNYXAodHVwbGUsIG1hcHBlcikge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyAkVHVwbGVNYXBUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR1cGxlID0gdHVwbGU7XG4gICAgICB0YXJnZXQubWFwcGVyID0gbWFwcGVyO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICckdmFsdWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gJHZhbHVlcyh0eXBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3ICRWYWx1ZXNUeXBlKHRoaXMpO1xuICAgICAgdGFyZ2V0LnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIENsYXNzKGluc3RhbmNlVHlwZSkge1xuICAgICAgdmFyIHRhcmdldCA9IG5ldyBDbGFzc1R5cGUodGhpcyk7XG4gICAgICB0YXJnZXQuaW5zdGFuY2VUeXBlID0gaW5zdGFuY2VUeXBlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdUeXBlUGFyYW1ldGVyc1N5bWJvbCcsXG5cblxuICAgIC8vIElzc3VlIDI1MlxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIFR5cGVQYXJhbWV0ZXJzU3ltYm9sO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHlwZUNvbnRleHQ7XG59KCk7XG5cbnZhciBnbG9iYWxDb250ZXh0JDEgPSB2b2lkIDA7XG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5fX0ZMT1dfUlVOVElNRV9HTE9CQUxfQ09OVEVYVF9ET19OT1RfVVNFX1RISVNfVkFSSUFCTEVfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsQ29udGV4dCQxID0gZ2xvYmFsLl9fRkxPV19SVU5USU1FX0dMT0JBTF9DT05URVhUX0RPX05PVF9VU0VfVEhJU19WQVJJQUJMRV9fO1xufSBlbHNlIHtcbiAgZ2xvYmFsQ29udGV4dCQxID0gbmV3IFR5cGVDb250ZXh0KCk7XG4gIHJlZ2lzdGVyUHJpbWl0aXZlVHlwZXMoZ2xvYmFsQ29udGV4dCQxKTtcbiAgcmVnaXN0ZXJCdWlsdGluVHlwZUNvbnN0cnVjdG9ycyhnbG9iYWxDb250ZXh0JDEpO1xuICByZWdpc3RlclR5cGVQcmVkaWNhdGVzKGdsb2JhbENvbnRleHQkMSk7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5fX0ZMT1dfUlVOVElNRV9HTE9CQUxfQ09OVEVYVF9ET19OT1RfVVNFX1RISVNfVkFSSUFCTEVfXyA9IGdsb2JhbENvbnRleHQkMTtcbiAgfVxufVxuXG52YXIgZ2xvYmFsQ29udGV4dCQyID0gZ2xvYmFsQ29udGV4dCQxO1xuXG5leHBvcnQgeyBBbnlUeXBlLCBBcnJheVR5cGUsIEJvb2xlYW5MaXRlcmFsVHlwZSwgQm9vbGVhblR5cGUsIEVtcHR5VHlwZSwgRXhpc3RlbnRpYWxUeXBlLCBGbG93SW50b1R5cGUsIEZ1bmN0aW9uVHlwZSwgRnVuY3Rpb25UeXBlUGFyYW0sIEZ1bmN0aW9uVHlwZVJlc3RQYXJhbSwgRnVuY3Rpb25UeXBlUmV0dXJuLCBHZW5lcmF0b3JUeXBlLCBHZW5lcmljVHlwZSwgSW50ZXJzZWN0aW9uVHlwZSwgTWl4ZWRUeXBlLCBUeXBlQWxpYXMsIE51bGxhYmxlVHlwZSwgTnVsbExpdGVyYWxUeXBlLCBOdW1iZXJUeXBlLCBOdW1lcmljTGl0ZXJhbFR5cGUsIE9iamVjdFR5cGUsIE9iamVjdFR5cGVDYWxsUHJvcGVydHksIE9iamVjdFR5cGVJbmRleGVyLCBPYmplY3RUeXBlUHJvcGVydHksIFBhcmFtZXRlcml6ZWRUeXBlQWxpYXMsIFBhcmFtZXRlcml6ZWRGdW5jdGlvblR5cGUsIFBhcnRpYWxUeXBlLCBSZWZpbmVtZW50VHlwZSwgU3RyaW5nTGl0ZXJhbFR5cGUsIFN0cmluZ1R5cGUsIFN5bWJvbExpdGVyYWxUeXBlLCBTeW1ib2xUeXBlLCBUaGlzVHlwZSwgVHVwbGVUeXBlLCBUeXBlLCBUeXBlQm94LCBUeXBlQ29uc3RydWN0b3IsIFR5cGVQYXJhbWV0ZXIsIFR5cGVQYXJhbWV0ZXJBcHBsaWNhdGlvbiwgVHlwZVJlZmVyZW5jZSwgVHlwZVREWiwgVW5pb25UeXBlLCBWb2lkVHlwZSwgRGVjbGFyYXRpb24sIFR5cGVEZWNsYXJhdGlvbiwgVmFyRGVjbGFyYXRpb24sIE1vZHVsZURlY2xhcmF0aW9uLCBNb2R1bGVFeHBvcnRzIGFzIE1vZHVsZUV4cG9ydHNEZWNsYXJhdGlvbiwgQ2xhc3NEZWNsYXJhdGlvbiwgUGFyYW1ldGVyaXplZENsYXNzRGVjbGFyYXRpb24sIEV4dGVuZHNEZWNsYXJhdGlvbiwgVHlwZVBhcmFtZXRlcnNTeW1ib2wsIFR5cGVTeW1ib2wgfTtleHBvcnQgZGVmYXVsdCBnbG9iYWxDb250ZXh0JDI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbG93LXJ1bnRpbWUuZXMyMDE1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmxvdy1ydW50aW1lL2Rpc3QvZmxvdy1ydW50aW1lLmVzMjAxNS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);